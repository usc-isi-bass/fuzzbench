diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/CMakeLists.txt b/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/LICENSE.md b/LICENSE.md
old mode 100644
new mode 100755
diff --git a/Makefile.am b/Makefile.am
old mode 100644
new mode 100755
diff --git a/Makefile.nmake b/Makefile.nmake
old mode 100644
new mode 100755
diff --git a/Manual.md b/Manual.md
old mode 100644
new mode 100755
diff --git a/Manual.tex b/Manual.tex
old mode 100644
new mode 100755
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
diff --git a/configure.ac b/configure.ac
old mode 100644
new mode 100755
diff --git a/fuzzer/CMakeLists.txt b/fuzzer/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/crash-0a63175dc6b51474dc08197431ec36d11db5e77b b/fuzzer/CORPUS_CONNECT/crash-0a63175dc6b51474dc08197431ec36d11db5e77b
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/crash-27ffd53d682a7908bf7569e32d904f049066b5d6 b/fuzzer/CORPUS_CONNECT/crash-27ffd53d682a7908bf7569e32d904f049066b5d6
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/data-1.bin b/fuzzer/CORPUS_CONNECT/data-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/init-ack-1.bin b/fuzzer/CORPUS_CONNECT/init-ack-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/leak-00bd871f5ce0596083fe8642c803c97f424b0c70 b/fuzzer/CORPUS_CONNECT/leak-00bd871f5ce0596083fe8642c803c97f424b0c70
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/shutdown-1.bin b/fuzzer/CORPUS_CONNECT/shutdown-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/shutdown-ack-1.bin b/fuzzer/CORPUS_CONNECT/shutdown-ack-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/shutdown-complete-1.bin b/fuzzer/CORPUS_CONNECT/shutdown-complete-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/timeout-00b96dd43f1251438bb44daa0a5a24ae4df5bce5 b/fuzzer/CORPUS_CONNECT/timeout-00b96dd43f1251438bb44daa0a5a24ae4df5bce5
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000000 b/fuzzer/CORPUS_CONNECT/tsctp-0-000000
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000001 b/fuzzer/CORPUS_CONNECT/tsctp-0-000001
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000002 b/fuzzer/CORPUS_CONNECT/tsctp-0-000002
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000003 b/fuzzer/CORPUS_CONNECT/tsctp-0-000003
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000004 b/fuzzer/CORPUS_CONNECT/tsctp-0-000004
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000005 b/fuzzer/CORPUS_CONNECT/tsctp-0-000005
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000006 b/fuzzer/CORPUS_CONNECT/tsctp-0-000006
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000007 b/fuzzer/CORPUS_CONNECT/tsctp-0-000007
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000008 b/fuzzer/CORPUS_CONNECT/tsctp-0-000008
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000009 b/fuzzer/CORPUS_CONNECT/tsctp-0-000009
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000010 b/fuzzer/CORPUS_CONNECT/tsctp-0-000010
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000011 b/fuzzer/CORPUS_CONNECT/tsctp-0-000011
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000012 b/fuzzer/CORPUS_CONNECT/tsctp-0-000012
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000013 b/fuzzer/CORPUS_CONNECT/tsctp-0-000013
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000014 b/fuzzer/CORPUS_CONNECT/tsctp-0-000014
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000015 b/fuzzer/CORPUS_CONNECT/tsctp-0-000015
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000016 b/fuzzer/CORPUS_CONNECT/tsctp-0-000016
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000017 b/fuzzer/CORPUS_CONNECT/tsctp-0-000017
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000018 b/fuzzer/CORPUS_CONNECT/tsctp-0-000018
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000019 b/fuzzer/CORPUS_CONNECT/tsctp-0-000019
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000020 b/fuzzer/CORPUS_CONNECT/tsctp-0-000020
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000021 b/fuzzer/CORPUS_CONNECT/tsctp-0-000021
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000022 b/fuzzer/CORPUS_CONNECT/tsctp-0-000022
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000023 b/fuzzer/CORPUS_CONNECT/tsctp-0-000023
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000024 b/fuzzer/CORPUS_CONNECT/tsctp-0-000024
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000025 b/fuzzer/CORPUS_CONNECT/tsctp-0-000025
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000026 b/fuzzer/CORPUS_CONNECT/tsctp-0-000026
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000027 b/fuzzer/CORPUS_CONNECT/tsctp-0-000027
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000028 b/fuzzer/CORPUS_CONNECT/tsctp-0-000028
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000029 b/fuzzer/CORPUS_CONNECT/tsctp-0-000029
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000030 b/fuzzer/CORPUS_CONNECT/tsctp-0-000030
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000031 b/fuzzer/CORPUS_CONNECT/tsctp-0-000031
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000032 b/fuzzer/CORPUS_CONNECT/tsctp-0-000032
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000033 b/fuzzer/CORPUS_CONNECT/tsctp-0-000033
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000034 b/fuzzer/CORPUS_CONNECT/tsctp-0-000034
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000035 b/fuzzer/CORPUS_CONNECT/tsctp-0-000035
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000036 b/fuzzer/CORPUS_CONNECT/tsctp-0-000036
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000037 b/fuzzer/CORPUS_CONNECT/tsctp-0-000037
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000038 b/fuzzer/CORPUS_CONNECT/tsctp-0-000038
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000039 b/fuzzer/CORPUS_CONNECT/tsctp-0-000039
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000040 b/fuzzer/CORPUS_CONNECT/tsctp-0-000040
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000041 b/fuzzer/CORPUS_CONNECT/tsctp-0-000041
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000042 b/fuzzer/CORPUS_CONNECT/tsctp-0-000042
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000043 b/fuzzer/CORPUS_CONNECT/tsctp-0-000043
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000044 b/fuzzer/CORPUS_CONNECT/tsctp-0-000044
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000045 b/fuzzer/CORPUS_CONNECT/tsctp-0-000045
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000046 b/fuzzer/CORPUS_CONNECT/tsctp-0-000046
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000047 b/fuzzer/CORPUS_CONNECT/tsctp-0-000047
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000048 b/fuzzer/CORPUS_CONNECT/tsctp-0-000048
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000049 b/fuzzer/CORPUS_CONNECT/tsctp-0-000049
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000050 b/fuzzer/CORPUS_CONNECT/tsctp-0-000050
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000051 b/fuzzer/CORPUS_CONNECT/tsctp-0-000051
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000052 b/fuzzer/CORPUS_CONNECT/tsctp-0-000052
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000053 b/fuzzer/CORPUS_CONNECT/tsctp-0-000053
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000054 b/fuzzer/CORPUS_CONNECT/tsctp-0-000054
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000055 b/fuzzer/CORPUS_CONNECT/tsctp-0-000055
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000056 b/fuzzer/CORPUS_CONNECT/tsctp-0-000056
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000057 b/fuzzer/CORPUS_CONNECT/tsctp-0-000057
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000058 b/fuzzer/CORPUS_CONNECT/tsctp-0-000058
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000059 b/fuzzer/CORPUS_CONNECT/tsctp-0-000059
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000060 b/fuzzer/CORPUS_CONNECT/tsctp-0-000060
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000061 b/fuzzer/CORPUS_CONNECT/tsctp-0-000061
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000062 b/fuzzer/CORPUS_CONNECT/tsctp-0-000062
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000063 b/fuzzer/CORPUS_CONNECT/tsctp-0-000063
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000064 b/fuzzer/CORPUS_CONNECT/tsctp-0-000064
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000065 b/fuzzer/CORPUS_CONNECT/tsctp-0-000065
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000066 b/fuzzer/CORPUS_CONNECT/tsctp-0-000066
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000067 b/fuzzer/CORPUS_CONNECT/tsctp-0-000067
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000068 b/fuzzer/CORPUS_CONNECT/tsctp-0-000068
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000069 b/fuzzer/CORPUS_CONNECT/tsctp-0-000069
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000070 b/fuzzer/CORPUS_CONNECT/tsctp-0-000070
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000071 b/fuzzer/CORPUS_CONNECT/tsctp-0-000071
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000072 b/fuzzer/CORPUS_CONNECT/tsctp-0-000072
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000073 b/fuzzer/CORPUS_CONNECT/tsctp-0-000073
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000074 b/fuzzer/CORPUS_CONNECT/tsctp-0-000074
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000075 b/fuzzer/CORPUS_CONNECT/tsctp-0-000075
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000076 b/fuzzer/CORPUS_CONNECT/tsctp-0-000076
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000077 b/fuzzer/CORPUS_CONNECT/tsctp-0-000077
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000078 b/fuzzer/CORPUS_CONNECT/tsctp-0-000078
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000079 b/fuzzer/CORPUS_CONNECT/tsctp-0-000079
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000080 b/fuzzer/CORPUS_CONNECT/tsctp-0-000080
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000081 b/fuzzer/CORPUS_CONNECT/tsctp-0-000081
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000082 b/fuzzer/CORPUS_CONNECT/tsctp-0-000082
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000083 b/fuzzer/CORPUS_CONNECT/tsctp-0-000083
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000084 b/fuzzer/CORPUS_CONNECT/tsctp-0-000084
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000085 b/fuzzer/CORPUS_CONNECT/tsctp-0-000085
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000086 b/fuzzer/CORPUS_CONNECT/tsctp-0-000086
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000087 b/fuzzer/CORPUS_CONNECT/tsctp-0-000087
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000088 b/fuzzer/CORPUS_CONNECT/tsctp-0-000088
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000089 b/fuzzer/CORPUS_CONNECT/tsctp-0-000089
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000090 b/fuzzer/CORPUS_CONNECT/tsctp-0-000090
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000091 b/fuzzer/CORPUS_CONNECT/tsctp-0-000091
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000092 b/fuzzer/CORPUS_CONNECT/tsctp-0-000092
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000093 b/fuzzer/CORPUS_CONNECT/tsctp-0-000093
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000094 b/fuzzer/CORPUS_CONNECT/tsctp-0-000094
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000095 b/fuzzer/CORPUS_CONNECT/tsctp-0-000095
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000096 b/fuzzer/CORPUS_CONNECT/tsctp-0-000096
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000097 b/fuzzer/CORPUS_CONNECT/tsctp-0-000097
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000098 b/fuzzer/CORPUS_CONNECT/tsctp-0-000098
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000099 b/fuzzer/CORPUS_CONNECT/tsctp-0-000099
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000100 b/fuzzer/CORPUS_CONNECT/tsctp-0-000100
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000101 b/fuzzer/CORPUS_CONNECT/tsctp-0-000101
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000102 b/fuzzer/CORPUS_CONNECT/tsctp-0-000102
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000103 b/fuzzer/CORPUS_CONNECT/tsctp-0-000103
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000104 b/fuzzer/CORPUS_CONNECT/tsctp-0-000104
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000105 b/fuzzer/CORPUS_CONNECT/tsctp-0-000105
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000106 b/fuzzer/CORPUS_CONNECT/tsctp-0-000106
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000107 b/fuzzer/CORPUS_CONNECT/tsctp-0-000107
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000108 b/fuzzer/CORPUS_CONNECT/tsctp-0-000108
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000109 b/fuzzer/CORPUS_CONNECT/tsctp-0-000109
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000110 b/fuzzer/CORPUS_CONNECT/tsctp-0-000110
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000111 b/fuzzer/CORPUS_CONNECT/tsctp-0-000111
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000112 b/fuzzer/CORPUS_CONNECT/tsctp-0-000112
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000113 b/fuzzer/CORPUS_CONNECT/tsctp-0-000113
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000114 b/fuzzer/CORPUS_CONNECT/tsctp-0-000114
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000115 b/fuzzer/CORPUS_CONNECT/tsctp-0-000115
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000116 b/fuzzer/CORPUS_CONNECT/tsctp-0-000116
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-0-000117 b/fuzzer/CORPUS_CONNECT/tsctp-0-000117
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000000 b/fuzzer/CORPUS_CONNECT/tsctp-000000
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000001 b/fuzzer/CORPUS_CONNECT/tsctp-000001
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000002 b/fuzzer/CORPUS_CONNECT/tsctp-000002
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000003 b/fuzzer/CORPUS_CONNECT/tsctp-000003
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000004 b/fuzzer/CORPUS_CONNECT/tsctp-000004
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000005 b/fuzzer/CORPUS_CONNECT/tsctp-000005
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000006 b/fuzzer/CORPUS_CONNECT/tsctp-000006
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000007 b/fuzzer/CORPUS_CONNECT/tsctp-000007
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000008 b/fuzzer/CORPUS_CONNECT/tsctp-000008
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000009 b/fuzzer/CORPUS_CONNECT/tsctp-000009
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000010 b/fuzzer/CORPUS_CONNECT/tsctp-000010
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000011 b/fuzzer/CORPUS_CONNECT/tsctp-000011
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000012 b/fuzzer/CORPUS_CONNECT/tsctp-000012
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000013 b/fuzzer/CORPUS_CONNECT/tsctp-000013
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000014 b/fuzzer/CORPUS_CONNECT/tsctp-000014
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000015 b/fuzzer/CORPUS_CONNECT/tsctp-000015
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000016 b/fuzzer/CORPUS_CONNECT/tsctp-000016
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000017 b/fuzzer/CORPUS_CONNECT/tsctp-000017
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000018 b/fuzzer/CORPUS_CONNECT/tsctp-000018
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000019 b/fuzzer/CORPUS_CONNECT/tsctp-000019
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000020 b/fuzzer/CORPUS_CONNECT/tsctp-000020
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000021 b/fuzzer/CORPUS_CONNECT/tsctp-000021
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000022 b/fuzzer/CORPUS_CONNECT/tsctp-000022
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000023 b/fuzzer/CORPUS_CONNECT/tsctp-000023
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000024 b/fuzzer/CORPUS_CONNECT/tsctp-000024
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000025 b/fuzzer/CORPUS_CONNECT/tsctp-000025
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000026 b/fuzzer/CORPUS_CONNECT/tsctp-000026
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000027 b/fuzzer/CORPUS_CONNECT/tsctp-000027
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_CONNECT/tsctp-000028 b/fuzzer/CORPUS_CONNECT/tsctp-000028
old mode 100644
new mode 100755
diff --git a/fuzzer/CORPUS_LISTEN/init-1.bin b/fuzzer/CORPUS_LISTEN/init-1.bin
old mode 100644
new mode 100755
diff --git a/fuzzer/fuzzer_connect.c b/fuzzer/fuzzer_connect.c
old mode 100644
new mode 100755
index 87b6ebb..9a4fada
--- a/fuzzer/fuzzer_connect.c
+++ b/fuzzer/fuzzer_connect.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#define FIXREVERTER_SIZE 920
+short FIXREVERTER[FIXREVERTER_SIZE];
+#endif
 /*
  * Copyright (C) 2017-2019 Felix Weinrank
  *
@@ -148,9 +152,43 @@ initialize_fuzzer(void) {
 }
 
 
+
+#ifdef FRCOV
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
 int
 LLVMFuzzerTestOneInput(const uint8_t* data, size_t data_size)
 {
+	
+	#ifdef FRCOV
+	char *fixReverterEnv = getenv("FIXREVERTER");
+	char *fixReverterToken = strtok(fixReverterEnv, " ");
+	if (fixReverterToken == NULL) {
+	  for (int i = 0; i < FIXREVERTER_SIZE; i++)
+	    FIXREVERTER[i] = 1;
+	} else if (!strcmp("on", fixReverterToken)) {
+	  for (int i = 0; i < FIXREVERTER_SIZE; i++)
+	    FIXREVERTER[i] = 0;
+	  fixReverterToken = strtok(NULL, " ");
+	  while (fixReverterToken != NULL) {
+	    FIXREVERTER[atoi(fixReverterToken)] = 1;
+	    fixReverterToken = strtok(NULL, " ");
+	  }
+	} else if (!strcmp("off", fixReverterToken)) {
+	  for (int i = 0; i < FIXREVERTER_SIZE; i++)
+	    FIXREVERTER[i] = 1;
+	  fixReverterToken = strtok(NULL, " ");
+	  while (fixReverterToken != NULL) {
+	    FIXREVERTER[atoi(fixReverterToken)] = 0;
+	    fixReverterToken = strtok(NULL, " ");
+	  }
+	} else {
+	  fprintf(stderr, "[FIXREVERTER] - first token must be on or off\n");
+	  exit(0);
+	}
+	#endif
 	static int initialized;
 	char *fuzzed_packet_buffer;
 	struct sockaddr_in bind4;
diff --git a/fuzzer/fuzzer_listen.c b/fuzzer/fuzzer_listen.c
old mode 100644
new mode 100755
diff --git a/gen-def.py b/gen-def.py
old mode 100644
new mode 100755
diff --git a/meson.build b/meson.build
old mode 100644
new mode 100755
diff --git a/meson_options.txt b/meson_options.txt
old mode 100644
new mode 100755
diff --git a/programs/CMakeLists.txt b/programs/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/programs/Makefile.am b/programs/Makefile.am
old mode 100644
new mode 100755
diff --git a/programs/Makefile.nmake b/programs/Makefile.nmake
old mode 100644
new mode 100755
diff --git a/programs/chargen_server_upcall.c b/programs/chargen_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/client.c b/programs/client.c
old mode 100644
new mode 100755
diff --git a/programs/client_upcall.c b/programs/client_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/daytime_server.c b/programs/daytime_server.c
old mode 100644
new mode 100755
diff --git a/programs/daytime_server_upcall.c b/programs/daytime_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/discard_server.c b/programs/discard_server.c
old mode 100644
new mode 100755
diff --git a/programs/discard_server_upcall.c b/programs/discard_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/echo_server.c b/programs/echo_server.c
old mode 100644
new mode 100755
diff --git a/programs/echo_server_upcall.c b/programs/echo_server_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_client.c b/programs/ekr_client.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_loop.c b/programs/ekr_loop.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_loop_offload.c b/programs/ekr_loop_offload.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_loop_upcall.c b/programs/ekr_loop_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_peer.c b/programs/ekr_peer.c
old mode 100644
new mode 100755
diff --git a/programs/ekr_server.c b/programs/ekr_server.c
old mode 100644
new mode 100755
diff --git a/programs/http_client.c b/programs/http_client.c
old mode 100644
new mode 100755
diff --git a/programs/http_client_upcall.c b/programs/http_client_upcall.c
old mode 100644
new mode 100755
diff --git a/programs/meson.build b/programs/meson.build
old mode 100644
new mode 100755
diff --git a/programs/programs_helper.c b/programs/programs_helper.c
old mode 100644
new mode 100755
diff --git a/programs/programs_helper.h b/programs/programs_helper.h
old mode 100644
new mode 100755
diff --git a/programs/rtcweb.c b/programs/rtcweb.c
old mode 100644
new mode 100755
diff --git a/programs/st_client.c b/programs/st_client.c
old mode 100644
new mode 100755
diff --git a/programs/test_libmgmt.c b/programs/test_libmgmt.c
old mode 100644
new mode 100755
diff --git a/programs/test_timer.c b/programs/test_timer.c
old mode 100644
new mode 100755
diff --git a/programs/tsctp.c b/programs/tsctp.c
old mode 100644
new mode 100755
diff --git a/programs/tsctp_upcall.c b/programs/tsctp_upcall.c
old mode 100644
new mode 100755
diff --git a/usrsctp.pc.in b/usrsctp.pc.in
old mode 100644
new mode 100755
diff --git a/usrsctplib/CMakeLists.txt b/usrsctplib/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/usrsctplib/Makefile.am b/usrsctplib/Makefile.am
old mode 100644
new mode 100755
diff --git a/usrsctplib/Makefile.nmake b/usrsctplib/Makefile.nmake
old mode 100644
new mode 100755
diff --git a/usrsctplib/meson.build b/usrsctplib/meson.build
old mode 100644
new mode 100755
diff --git a/usrsctplib/netinet/meson.build b/usrsctplib/netinet/meson.build
old mode 100644
new mode 100755
diff --git a/usrsctplib/netinet/sctp_asconf.c b/usrsctplib/netinet/sctp_asconf.c
index ededbed..0d1ab30 100755
--- a/usrsctplib/netinet/sctp_asconf.c
+++ b/usrsctplib/netinet/sctp_asconf.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -88,11 +92,26 @@ sctp_asconf_success_response(uint32_t id)
 
 	m_reply = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_paramhdr),
 					0, M_NOWAIT, 1, MT_DATA);
-	if (m_reply == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[49]) {
+	  if ((m_reply == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 49\n");
+	  else
+	    fprintf(stderr, "reached bug index 49\n");
+	}
+	if ((!FIXREVERTER[49] && (m_reply == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"asconf_success_response: couldn't get mbuf!\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aph = mtod(m_reply, struct sctp_asconf_paramhdr *);
 	aph->correlation_id = id;
 	aph->ph.param_type = htons(SCTP_SUCCESS_REPORT);
@@ -131,11 +150,26 @@ sctp_asconf_error_response(uint32_t id, uint16_t cause, uint8_t *error_tlv,
 		return (NULL);
 	}
 	m_reply = sctp_get_mbuf_for_msg(buf_len, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_reply == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[50]) {
+	  if ((m_reply == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 50\n");
+	  else
+	    fprintf(stderr, "reached bug index 50\n");
+	}
+	if ((!FIXREVERTER[50] && (m_reply == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"asconf_error_response: couldn't get mbuf!\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aph = mtod(m_reply, struct sctp_asconf_paramhdr *);
 	aph->ph.param_type = htons(SCTP_ERROR_CAUSE_IND);
 	aph->ph.param_length = htons(param_length);
@@ -296,10 +330,25 @@ sctp_asconf_del_remote_addrs_except(struct sctp_tcb *stcb, struct sockaddr *src)
 
 	/* make sure the source address exists as a destination net */
 	src_net = sctp_findnet(stcb, src);
-	if (src_net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[52]) {
+	  if ((src_net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 52\n");
+	  else
+	    fprintf(stderr, "reached bug index 52\n");
+	}
+	if ((!FIXREVERTER[52] && (src_net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* not found */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* delete all destination addresses except the source */
 	TAILQ_FOREACH_SAFE(net, &stcb->asoc.nets, sctp_next, nnet) {
@@ -657,11 +706,26 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 			"handle_asconf: got duplicate serial number = %xh\n",
 			serial_num);
 		return;
-	} else if (serial_num != (asoc->asconf_seq_in + 1)) {
+	} else 
+	#ifdef FRCOV
+	{if (FIXREVERTER[54]) {
+	  if ((serial_num != asoc -> asconf_seq_in + 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 54\n");
+	  else
+	    fprintf(stderr, "reached bug index 54\n");
+	}
+	if ((!FIXREVERTER[54] && (serial_num != asoc -> asconf_seq_in + 1 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: incorrect serial number = %xh (expected next = %xh)\n",
 			serial_num, asoc->asconf_seq_in + 1);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* it's the expected "next" sequence number, so process it */
 	asoc->asconf_seq_in = serial_num;	/* update sequence */
@@ -676,8 +740,23 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 		SCTPDBG(SCTP_DEBUG_ASCONF1,"handle_asconf: Now processing first ASCONF. Try to delete old cache\n");
 
 		TAILQ_FOREACH_SAFE(ack, &asoc->asconf_ack_sent, next, ack_next) {
-			if (ack->serial_number == serial_num)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[55]) {
+			  if ((ack -> serial_number == serial_num ) && !(0))
+			    fprintf(stderr, "triggered bug index 55\n");
+			  else
+			    fprintf(stderr, "reached bug index 55\n");
+			}
+			if ((!FIXREVERTER[55] && (ack -> serial_number == serial_num ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			SCTPDBG(SCTP_DEBUG_ASCONF1,"handle_asconf: delete old(%u) < first(%u)\n",
 			    ack->serial_number, serial_num);
 			TAILQ_REMOVE(&asoc->asconf_ack_sent, ack, next);
@@ -690,11 +769,26 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 
 	m_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_ack_chunk), 0,
 				      M_NOWAIT, 1, MT_DATA);
-	if (m_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[56]) {
+	  if ((m_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 56\n");
+	  else
+	    fprintf(stderr, "reached bug index 56\n");
+	}
+	if ((!FIXREVERTER[56] && (m_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"handle_asconf: couldn't get mbuf!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	m_tail = m_ack;		/* current reply chain's tail */
 
 	/* fill in ASCONF-ACK header */
@@ -709,21 +803,51 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 	/* skip the lookup address parameter */
 	offset += sizeof(struct sctp_asconf_chunk);
 	p_addr = (struct sctp_ipv6addr_param *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr), (uint8_t *)&aparam_buf);
-	if (p_addr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[57]) {
+	  if ((p_addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 57\n");
+	  else
+	    fprintf(stderr, "reached bug index 57\n");
+	}
+	if ((!FIXREVERTER[57] && (p_addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"handle_asconf: couldn't get lookup addr!\n");
 		/* respond with a missing/invalid mandatory parameter error */
 		sctp_m_freem(m_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* skip lookup addr */
 	offset += SCTP_SIZE32(ntohs(p_addr->ph.param_length));
 	/* get pointer to first asconf param in ASCONF */
 	aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_asconf_paramhdr), (uint8_t *)&aparam_buf);
-	if (aph == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[58]) {
+	  if ((aph == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 58\n");
+	  else
+	    fprintf(stderr, "reached bug index 58\n");
+	}
+	if ((!FIXREVERTER[58] && (aph == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "Empty ASCONF received?\n");
 		goto send_reply;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* process through all parameters */
 	cnt = 0;
 	while (aph != NULL) {
@@ -731,18 +855,48 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 
 		param_type = ntohs(aph->ph.param_type);
 		param_length = ntohs(aph->ph.param_length);
-		if (offset + param_length > asconf_limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[59]) {
+		  if ((offset + param_length > asconf_limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 59\n");
+		  else
+		    fprintf(stderr, "reached bug index 59\n");
+		}
+		if ((!FIXREVERTER[59] && (offset + param_length > asconf_limit ))
+		#else
+		if (0
+		#endif
+		) {
 			/* parameter goes beyond end of chunk! */
 			sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		m_result = NULL;
 
-		if (param_length > sizeof(aparam_buf)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[60]) {
+		  if ((param_length > sizeof ( aparam_buf ) ) && !(0))
+		    fprintf(stderr, "triggered bug index 60\n");
+		  else
+		    fprintf(stderr, "reached bug index 60\n");
+		}
+		if ((!FIXREVERTER[60] && (param_length > sizeof ( aparam_buf ) ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: param length (%u) larger than buffer size!\n", param_length);
 			sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (param_length <= sizeof(struct sctp_paramhdr)) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: param length (%u) too short\n", param_length);
 			sctp_m_freem(m_ack);
@@ -750,11 +904,26 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 		}
 		/* get the entire parameter */
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, param_length, aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[61]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 61\n");
+		  else
+		    fprintf(stderr, "reached bug index 61\n");
+		}
+		if ((!FIXREVERTER[61] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf: couldn't get entire param\n");
 			sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		switch (param_type) {
 		case SCTP_ADD_IP_ADDRESS:
 			m_result = sctp_process_asconf_add_ip(src, aph, stcb,
@@ -808,10 +977,25 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 		}
 		offset += SCTP_SIZE32(param_length);
 		/* update remaining ASCONF message length to process */
-		if (offset >= asconf_limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[62]) {
+		  if ((offset >= asconf_limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 62\n");
+		  else
+		    fprintf(stderr, "reached bug index 62\n");
+		}
+		if ((!FIXREVERTER[62] && (offset >= asconf_limit ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no more data in the mbuf chain */
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* get pointer to next asconf param */
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset,
 		    sizeof(struct sctp_asconf_paramhdr),
@@ -828,10 +1012,25 @@ sctp_handle_asconf(struct mbuf *m, unsigned int offset,
 	/* save the ASCONF-ACK reply */
 	ack = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asconf_ack),
 	    struct sctp_asconf_ack);
-	if (ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[63]) {
+	  if ((ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 63\n");
+	  else
+	    fprintf(stderr, "reached bug index 63\n");
+	}
+	if ((!FIXREVERTER[63] && (ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(m_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	ack->serial_number = serial_num;
 	ack->last_sent_to = NULL;
 	ack->data = m_ack;
@@ -1283,11 +1482,26 @@ sctp_asconf_queue_mgmt(struct sctp_tcb *stcb, struct sctp_ifa *ifa,
 	/* adding new request to the queue */
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 		    SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[66]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 66\n");
+	  else
+	    fprintf(stderr, "reached bug index 66\n");
+	}
+	if ((!FIXREVERTER[66] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "asconf_queue_mgmt: failed to get memory!\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aa->special_del = 0;
 	/* fill in asconf address parameter fields */
 	/* top level elements are "networked" during send */
@@ -1462,9 +1676,24 @@ sctp_asconf_queue_sa_delete(struct sctp_tcb *stcb, struct sockaddr *sa)
 	struct sctp_ifa *ifa;
 	struct sctp_asconf_addr *aa, *aa_next;
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[67]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 67\n");
+	  else
+	    fprintf(stderr, "reached bug index 67\n");
+	}
+	if ((!FIXREVERTER[67] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* see if peer supports ASCONF */
 	if (stcb->asoc.asconf_supported == 0) {
 		return (-1);
@@ -1497,12 +1726,27 @@ sctp_asconf_queue_sa_delete(struct sctp_tcb *stcb, struct sockaddr *sa)
 	/* adding new request to the queue */
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 		    SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[68]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 68\n");
+	  else
+	    fprintf(stderr, "reached bug index 68\n");
+	}
+	if ((!FIXREVERTER[68] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"sctp_asconf_queue_sa_delete: failed to get memory!\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aa->special_del = 0;
 	/* fill in asconf address parameter fields */
 	/* top level elements are "networked" during send */
@@ -1730,12 +1974,27 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 		*abort_no_unlock = 1;
 		return;
 	}
-	if (serial_num != asoc->asconf_seq_out_acked + 1) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[71]) {
+	  if ((serial_num != asoc -> asconf_seq_out_acked + 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 71\n");
+	  else
+	    fprintf(stderr, "reached bug index 71\n");
+	}
+	if ((!FIXREVERTER[71] && (serial_num != asoc -> asconf_seq_out_acked + 1 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* got a duplicate/unexpected ASCONF-ACK */
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "handle_asconf_ack: got duplicate/unexpected serial number = %xh (expected = %xh)\n",
 			serial_num, asoc->asconf_seq_out_acked + 1);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (serial_num == asoc->asconf_seq_out - 1) {
 		/* stop our timer */
@@ -1754,33 +2013,93 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 		/* get pointer to next asconf parameter */
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset,
 		    sizeof(struct sctp_asconf_paramhdr), aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[72]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 72\n");
+		  else
+		    fprintf(stderr, "reached bug index 72\n");
+		}
+		if ((!FIXREVERTER[72] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* can't get an asconf paramhdr */
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		param_type = ntohs(aph->ph.param_type);
 		param_length = ntohs(aph->ph.param_length);
-		if (param_length > ack_length) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[73]) {
+		  if ((param_length > ack_length ) && !(0))
+		    fprintf(stderr, "triggered bug index 73\n");
+		  else
+		    fprintf(stderr, "reached bug index 73\n");
+		}
+		if ((!FIXREVERTER[73] && (param_length > ack_length ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (param_length < sizeof(struct sctp_paramhdr)) {
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
 		/* get the complete parameter... */
-		if (param_length > sizeof(aparam_buf)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[74]) {
+		  if ((param_length > sizeof ( aparam_buf ) ) && !(0))
+		    fprintf(stderr, "triggered bug index 74\n");
+		  else
+		    fprintf(stderr, "reached bug index 74\n");
+		}
+		if ((!FIXREVERTER[74] && (param_length > sizeof ( aparam_buf ) ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1,
 				"param length (%u) larger than buffer size!\n", param_length);
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(m, offset, param_length, aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[75]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 75\n");
+		  else
+		    fprintf(stderr, "reached bug index 75\n");
+		}
+		if ((!FIXREVERTER[75] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_asconf_ack_clear(stcb);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* correlation_id is transparent to peer, no ntohl needed */
 		id = aph->correlation_id;
 
@@ -1789,10 +2108,25 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 			last_error_id = id;
 			/* find the corresponding asconf param in our queue */
 			ap = sctp_asconf_find_param(stcb, id);
-			if (ap == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[76]) {
+			  if ((ap == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 76\n");
+			  else
+			    fprintf(stderr, "reached bug index 76\n");
+			}
+			if ((!FIXREVERTER[76] && (ap == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* hmm... can't find this in our queue! */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* process the parameter, failed flag */
 			sctp_asconf_process_param_ack(stcb, ap, 0);
 			/* process the error response */
@@ -1801,10 +2135,25 @@ sctp_handle_asconf_ack(struct mbuf *m, int offset,
 		case SCTP_SUCCESS_REPORT:
 			/* find the corresponding asconf param in our queue */
 			ap = sctp_asconf_find_param(stcb, id);
-			if (ap == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[77]) {
+			  if ((ap == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 77\n");
+			  else
+			    fprintf(stderr, "reached bug index 77\n");
+			}
+			if ((!FIXREVERTER[77] && (ap == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* hmm... can't find this in our queue! */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* process the parameter, success flag */
 			sctp_asconf_process_param_ack(stcb, ap, 1);
 			break;
@@ -1876,10 +2225,25 @@ sctp_is_scopeid_in_nets(struct sctp_tcb *stcb, struct sockaddr *sa)
 	struct sockaddr_in6 *sin6, *net6;
 	struct sctp_nets *net;
 
-	if (sa->sa_family != AF_INET6) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[79]) {
+	  if ((sa -> sa_family != 10 ) && !(0))
+	    fprintf(stderr, "triggered bug index 79\n");
+	  else
+	    fprintf(stderr, "reached bug index 79\n");
+	}
+	if ((!FIXREVERTER[79] && (sa -> sa_family != 10 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* wrong family */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sin6 = (struct sockaddr_in6 *)sa;
 	if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) == 0) {
 		/* not link local address */
@@ -2332,10 +2696,25 @@ sctp_set_primary_ip_address_sa(struct sctp_tcb *stcb, struct sockaddr *sa)
 	/* find the ifa for the desired set primary */
 	vrf_id = stcb->asoc.vrf_id;
 	ifa = sctp_find_ifa_by_addr(sa, vrf_id, SCTP_ADDR_NOT_LOCKED);
-	if (ifa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[83]) {
+	  if ((ifa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 83\n");
+	  else
+	    fprintf(stderr, "reached bug index 83\n");
+	}
+	if ((!FIXREVERTER[83] && (ifa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Invalid address */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* queue an ASCONF:SET_PRIM_ADDR to be sent */
 	if (!sctp_asconf_queue_add(stcb, ifa, SCTP_SET_PRIM_ADDR)) {
@@ -2378,49 +2757,139 @@ sctp_is_addr_pending(struct sctp_tcb *stcb, struct sctp_ifa *sctp_ifa)
 	add_cnt = del_cnt = 0;
 	last_param_type = 0;
 	TAILQ_FOREACH_SAFE(chk, &stcb->asoc.asconf_send_queue, sctp_next, nchk) {
-		if (chk->data == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[85]) {
+		  if ((chk -> data == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 85\n");
+		  else
+		    fprintf(stderr, "reached bug index 85\n");
+		}
+		if ((!FIXREVERTER[85] && (chk -> data == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: No mbuf data?\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		offset = 0;
 		acp = mtod(chk->data, struct sctp_asconf_chunk *);
 		offset += sizeof(struct sctp_asconf_chunk);
 		asconf_limit = ntohs(acp->ch.chunk_length);
 		ph = (struct sctp_paramhdr *)sctp_m_getptr(chk->data, offset, sizeof(struct sctp_paramhdr), aparam_buf);
-		if (ph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[86]) {
+		  if ((ph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 86\n");
+		  else
+		    fprintf(stderr, "reached bug index 86\n");
+		}
+		if ((!FIXREVERTER[86] && (ph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: couldn't get lookup addr!\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		offset += ntohs(ph->param_length);
 
 		aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(chk->data, offset, sizeof(struct sctp_asconf_paramhdr), aparam_buf);
-		if (aph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[87]) {
+		  if ((aph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 87\n");
+		  else
+		    fprintf(stderr, "reached bug index 87\n");
+		}
+		if ((!FIXREVERTER[87] && (aph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: Empty ASCONF will be sent?\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		while (aph != NULL) {
 			unsigned int param_length, param_type;
 
 			param_type = ntohs(aph->ph.param_type);
 			param_length = ntohs(aph->ph.param_length);
-			if (offset + param_length > asconf_limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[88]) {
+			  if ((offset + param_length > asconf_limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 88\n");
+			  else
+			    fprintf(stderr, "reached bug index 88\n");
+			}
+			if ((!FIXREVERTER[88] && (offset + param_length > asconf_limit ))
+			#else
+			if (0
+			#endif
+			) {
 				/* parameter goes beyond end of chunk! */
 				break;
 			}
-			if (param_length > sizeof(aparam_buf)) {
+			#ifdef FRCOV
+			}
+			#endif
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[89]) {
+			  if ((param_length > sizeof ( aparam_buf ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 89\n");
+			  else
+			    fprintf(stderr, "reached bug index 89\n");
+			}
+			if ((!FIXREVERTER[89] && (param_length > sizeof ( aparam_buf ) ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: param length (%u) larger than buffer size!\n", param_length);
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (param_length <= sizeof(struct sctp_paramhdr)) {
 				SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: param length(%u) too short\n", param_length);
 				break;
 			}
 
 			aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(chk->data, offset, param_length, aparam_buf);
-			if (aph == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[90]) {
+			  if ((aph == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 90\n");
+			  else
+			    fprintf(stderr, "reached bug index 90\n");
+			}
+			if ((!FIXREVERTER[90] && (aph == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_ASCONF1, "is_addr_pending: couldn't get entire param\n");
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 
 			ph = (struct sctp_paramhdr *)(aph + 1);
 			if (sctp_addr_match(ph, &sctp_ifa->address.sa) != 0) {
@@ -2438,10 +2907,25 @@ sctp_is_addr_pending(struct sctp_tcb *stcb, struct sctp_ifa *sctp_ifa)
 			}
 
 			offset += SCTP_SIZE32(param_length);
-			if (offset >= asconf_limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[91]) {
+			  if ((offset >= asconf_limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 91\n");
+			  else
+			    fprintf(stderr, "reached bug index 91\n");
+			}
+			if ((!FIXREVERTER[91] && (offset >= asconf_limit ))
+			#else
+			if (0
+			#endif
+			) {
 				/* no more data in the mbuf chain */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* get pointer to next asconf param */
 			aph = (struct sctp_asconf_paramhdr *)sctp_m_getptr(chk->data, offset, sizeof(struct sctp_asconf_paramhdr), aparam_buf);
 		}
@@ -2465,11 +2949,26 @@ sctp_find_valid_localaddr(struct sctp_tcb *stcb, int addr_locked)
 	if (addr_locked == SCTP_ADDR_NOT_LOCKED)
 		SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(stcb->asoc.vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[92]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 92\n");
+	  else
+	    fprintf(stderr, "reached bug index 92\n");
+	}
+	if ((!FIXREVERTER[92] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (addr_locked == SCTP_ADDR_NOT_LOCKED)
 			SCTP_IPI_ADDR_RUNLOCK();
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
 		if (stcb->asoc.scope.loopback_scope == 0 &&
 		    SCTP_IFN_IS_IFT_LOOP(sctp_ifn)) {
@@ -2562,9 +3061,24 @@ sctp_find_valid_localaddr_ep(struct sctp_tcb *stcb)
 	struct sctp_laddr *laddr;
 
 	LIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[93]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 93\n");
+		  else
+		    fprintf(stderr, "reached bug index 93\n");
+		}
+		if ((!FIXREVERTER[93] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* is the address restricted ? */
 		if (sctp_is_addr_restricted(stcb, laddr->ifa) &&
 		    (!sctp_is_addr_pending(stcb, laddr->ifa)))
@@ -2599,8 +3113,23 @@ sctp_compose_asconf(struct sctp_tcb *stcb, int *retlen, int addr_locked)
 		if (aa->sent == 0)
 			break;
 	}
-	if (aa == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[94]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 94\n");
+	  else
+	    fprintf(stderr, "reached bug index 94\n");
+	}
+	if ((!FIXREVERTER[94] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/*
 	 * get a chunk header mbuf and a cluster for the asconf params since
@@ -2608,20 +3137,50 @@ sctp_compose_asconf(struct sctp_tcb *stcb, int *retlen, int addr_locked)
 	 * the fly
 	 */
 	m_asconf_chk = sctp_get_mbuf_for_msg(sizeof(struct sctp_asconf_chunk), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_asconf_chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[95]) {
+	  if ((m_asconf_chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 95\n");
+	  else
+	    fprintf(stderr, "reached bug index 95\n");
+	}
+	if ((!FIXREVERTER[95] && (m_asconf_chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"compose_asconf: couldn't get chunk mbuf!\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	m_asconf = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_asconf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[96]) {
+	  if ((m_asconf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 96\n");
+	  else
+	    fprintf(stderr, "reached bug index 96\n");
+	}
+	if ((!FIXREVERTER[96] && (m_asconf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 			"compose_asconf: couldn't get mbuf!\n");
 		sctp_m_freem(m_asconf_chk);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(m_asconf_chk) = sizeof(struct sctp_asconf_chunk);
 	SCTP_BUF_LEN(m_asconf) = 0;
 	acp = mtod(m_asconf_chk, struct sctp_asconf_chunk *);
@@ -2794,8 +3353,23 @@ sctp_process_initack_addresses(struct sctp_tcb *stcb, struct mbuf *m,
 #endif
 
 	SCTPDBG(SCTP_DEBUG_ASCONF2, "processing init-ack addresses\n");
-	if (stcb == NULL) /* Un-needed check for SA */
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[98]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 98\n");
+	  else
+	    fprintf(stderr, "reached bug index 98\n");
+	}
+	if ((!FIXREVERTER[98] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) /* Un-needed check for SA */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* convert to upper bound */
 	length += offset;
@@ -2977,9 +3551,24 @@ sctp_addr_in_initack(struct mbuf *m, uint32_t offset, uint32_t length, struct so
 				      sctp_m_getptr(m, offset,
 				                    sizeof(struct sctp_ipv6addr_param),
 				                    (uint8_t *)&addr6_store);
-				if (a6p == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[99]) {
+				  if ((a6p == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 99\n");
+				  else
+				    fprintf(stderr, "reached bug index 99\n");
+				}
+				if ((!FIXREVERTER[99] && (a6p == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					return (0);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sin6 = (struct sockaddr_in6 *)sa;
 #ifdef SCTP_EMBEDDED_V6_SCOPE
 				if (IN6_IS_SCOPE_LINKLOCAL(&sin6->sin6_addr)) {
@@ -3009,9 +3598,24 @@ sctp_addr_in_initack(struct mbuf *m, uint32_t offset, uint32_t length, struct so
 				      sctp_m_getptr(m, offset,
 				                    sizeof(struct sctp_ipv4addr_param),
 				                    (uint8_t *)&addr4_store);
-				if (a4p == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[100]) {
+				  if ((a4p == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 100\n");
+				  else
+				    fprintf(stderr, "reached bug index 100\n");
+				}
+				if ((!FIXREVERTER[100] && (a4p == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					return (0);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sin = (struct sockaddr_in *)sa;
 				if (sin->sin_addr.s_addr == a4p->addr) {
 					/* found it */
@@ -3050,15 +3654,45 @@ sctp_check_address_list_ep(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 	/* go through the endpoint list */
 	LIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {
 		/* be paranoid and validate the laddr */
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[101]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 101\n");
+		  else
+		    fprintf(stderr, "reached bug index 101\n");
+		}
+		if ((!FIXREVERTER[101] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1,
 				"check_addr_list_ep: laddr->ifa is NULL");
 			continue;
 		}
-		if (laddr->ifa == NULL) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[102]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 102\n");
+		  else
+		    fprintf(stderr, "reached bug index 102\n");
+		}
+		if ((!FIXREVERTER[102] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_ASCONF1, "check_addr_list_ep: laddr->ifa->ifa_addr is NULL");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* do i have it implicitly? */
 		if (sctp_cmpaddr(&laddr->ifa->address.sa, init_addr)) {
 			continue;
@@ -3100,10 +3734,25 @@ sctp_check_address_list_all(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 	}
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[103]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 103\n");
+	  else
+	    fprintf(stderr, "reached bug index 103\n");
+	}
+	if ((!FIXREVERTER[103] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_IPI_ADDR_RUNLOCK();
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* go through all our known interfaces */
 	LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
 		if (loopback_scope == 0 && SCTP_IFN_IS_IFT_LOOP(sctp_ifn)) {
@@ -3231,11 +3880,26 @@ sctp_addr_mgmt_ep_sa(struct sctp_inpcb *inp, struct sockaddr *sa,
 		if (type == SCTP_ADD_IP_ADDRESS) {
 			sctp_add_local_addr_ep(inp, ifa, type);
 		} else if (type == SCTP_DEL_IP_ADDRESS) {
-			if (inp->laddr_count < 2) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[104]) {
+			  if ((inp -> laddr_count < 2 ) && !(0))
+			    fprintf(stderr, "triggered bug index 104\n");
+			  else
+			    fprintf(stderr, "reached bug index 104\n");
+			}
+			if ((!FIXREVERTER[104] && (inp -> laddr_count < 2 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* can't delete the last local address */
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_ASCONF, EINVAL);
 				return (EINVAL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			LIST_FOREACH(laddr, &inp->sctp_addr_list,
 				     sctp_nxt_addr) {
 				if (ifa == laddr->ifa) {
@@ -3264,16 +3928,46 @@ sctp_addr_mgmt_ep_sa(struct sctp_inpcb *inp, struct sockaddr *sa,
 			SCTP_MALLOC(asc, struct sctp_asconf_iterator *,
 			            sizeof(struct sctp_asconf_iterator),
 			            SCTP_M_ASC_IT);
-			if (asc == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[105]) {
+			  if ((asc == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 105\n");
+			  else
+			    fprintf(stderr, "reached bug index 105\n");
+			}
+			if ((!FIXREVERTER[105] && (asc == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_ASCONF, ENOMEM);
 				return (ENOMEM);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-			if (wi == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[106]) {
+			  if ((wi == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 106\n");
+			  else
+			    fprintf(stderr, "reached bug index 106\n");
+			}
+			if ((!FIXREVERTER[106] && (wi == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_FREE(asc, SCTP_M_ASC_IT);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_ASCONF, ENOMEM);
 				return (ENOMEM);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			LIST_INIT(&asc->list_of_work);
 			asc->cnt = 1;
 			SCTP_INCR_LADDR_COUNT();
@@ -3317,14 +4011,44 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 #ifdef INET6
 	struct sockaddr_in6 *to6;
 #endif
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[107]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 107\n");
+	  else
+	    fprintf(stderr, "reached bug index 107\n");
+	}
+	if ((!FIXREVERTER[107] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "sctp_asconf_send_nat_state_update: Missing net\n");
 		return;
 	}
-	if (stcb == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[108]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 108\n");
+	  else
+	    fprintf(stderr, "reached bug index 108\n");
+	}
+	if ((!FIXREVERTER[108] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_ASCONF1, "sctp_asconf_send_nat_state_update: Missing stcb\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
   /* Need to have in the asconf:
    * - vtagparam(my_vtag/peer_vtag)
    * - add(0.0.0.0)
@@ -3333,12 +4057,27 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
    */
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 	            SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[109]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 109\n");
+	  else
+	    fprintf(stderr, "reached bug index 109\n");
+	}
+	if ((!FIXREVERTER[109] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 		        "sctp_asconf_send_nat_state_update: failed to get memory!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	aa->special_del = 0;
 	/* fill in asconf address parameter fields */
 	/* top level elements are "networked" during send */
@@ -3353,12 +4092,27 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 	            SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[110]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 110\n");
+	  else
+	    fprintf(stderr, "reached bug index 110\n");
+	}
+	if ((!FIXREVERTER[110] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 		        "sctp_asconf_send_nat_state_update: failed to get memory!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(aa, 0, sizeof(struct sctp_asconf_addr));
 	/* fill in asconf address parameter fields */
 	/* ADD(0.0.0.0) */
@@ -3391,12 +4145,27 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 	}
 	SCTP_MALLOC(aa, struct sctp_asconf_addr *, sizeof(*aa),
 	            SCTP_M_ASC_ADDR);
-	if (aa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[111]) {
+	  if ((aa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 111\n");
+	  else
+	    fprintf(stderr, "reached bug index 111\n");
+	}
+	if ((!FIXREVERTER[111] && (aa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* didn't get memory */
 		SCTPDBG(SCTP_DEBUG_ASCONF1,
 		        "sctp_asconf_send_nat_state_update: failed to get memory!\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(aa, 0, sizeof(struct sctp_asconf_addr));
 	/* fill in asconf address parameter fields */
 	/* ADD(0.0.0.0) */
@@ -3435,9 +4204,24 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 
 		vrf_id = stcb->sctp_ep->def_vrf_id;
 		vrf = sctp_find_vrf(vrf_id);
-		if (vrf == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[112]) {
+		  if ((vrf == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 112\n");
+		  else
+		    fprintf(stderr, "reached bug index 112\n");
+		}
+		if ((!FIXREVERTER[112] && (vrf == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			goto skip_rest;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		SCTP_IPI_ADDR_RLOCK();
 		LIST_FOREACH(sctp_ifnp, &vrf->ifnlist, next_ifn) {
@@ -3488,20 +4272,50 @@ sctp_asconf_send_nat_state_update(struct sctp_tcb *stcb,
 		struct sctp_laddr *laddr;
 
 		LIST_FOREACH(laddr, &stcb->sctp_ep->sctp_addr_list, sctp_nxt_addr) {
-			if (laddr->ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[113]) {
+			  if ((laddr -> ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 113\n");
+			  else
+			    fprintf(stderr, "reached bug index 113\n");
+			}
+			if ((!FIXREVERTER[113] && (laddr -> ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED)
 				/* Address being deleted by the system, dont
 				 * list.
 				 */
 				continue;
-			if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[114]) {
+			  if ((laddr -> action == 49154 ) && !(0))
+			    fprintf(stderr, "triggered bug index 114\n");
+			  else
+			    fprintf(stderr, "reached bug index 114\n");
+			}
+			if ((!FIXREVERTER[114] && (laddr -> action == 49154 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Address being deleted on this ep
 				 * don't list.
 				 */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			sctp_ifap = laddr->ifa;
 			switch (sctp_ifap->address.sa.sa_family) {
 #ifdef INET
diff --git a/usrsctplib/netinet/sctp_auth.c b/usrsctplib/netinet/sctp_auth.c
index 604e6c7..0fa1dfe 100755
--- a/usrsctplib/netinet/sctp_auth.c
+++ b/usrsctplib/netinet/sctp_auth.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -88,13 +92,43 @@ sctp_copy_chunklist(sctp_auth_chklist_t *list)
 {
 	sctp_auth_chklist_t *new_list;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[634]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 634\n");
+	  else
+	    fprintf(stderr, "reached bug index 634\n");
+	}
+	if ((!FIXREVERTER[634] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* get a new list */
 	new_list = sctp_alloc_chunklist();
-	if (new_list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[635]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 635\n");
+	  else
+	    fprintf(stderr, "reached bug index 635\n");
+	}
+	if ((!FIXREVERTER[635] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	/* copy it */
 	memcpy(new_list, list, sizeof(*new_list));
 
@@ -108,8 +142,23 @@ sctp_copy_chunklist(sctp_auth_chklist_t *list)
 int
 sctp_auth_add_chunk(uint8_t chunk, sctp_auth_chklist_t *list)
 {
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[636]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 636\n");
+	  else
+	    fprintf(stderr, "reached bug index 636\n");
+	}
+	if ((!FIXREVERTER[636] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is chunk restricted? */
 	if ((chunk == SCTP_INITIATION) ||
@@ -134,8 +183,23 @@ sctp_auth_add_chunk(uint8_t chunk, sctp_auth_chklist_t *list)
 int
 sctp_auth_delete_chunk(uint8_t chunk, sctp_auth_chklist_t *list)
 {
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[637]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 637\n");
+	  else
+	    fprintf(stderr, "reached bug index 637\n");
+	}
+	if ((!FIXREVERTER[637] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (list->chunks[chunk] == 1) {
 		list->chunks[chunk] = 0;
@@ -165,8 +229,23 @@ sctp_serialize_auth_chunks(const sctp_auth_chklist_t *list, uint8_t *ptr)
 {
 	int i, count = 0;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[638]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 638\n");
+	  else
+	    fprintf(stderr, "reached bug index 638\n");
+	}
+	if ((!FIXREVERTER[638] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < 256; i++) {
 		if (list->chunks[i] != 0) {
@@ -252,10 +331,25 @@ sctp_alloc_key(uint32_t keylen)
 
 	SCTP_MALLOC(new_key, sctp_key_t *, sizeof(*new_key) + keylen,
 		    SCTP_M_AUTH_KY);
-	if (new_key == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[641]) {
+	  if ((new_key == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 641\n");
+	  else
+	    fprintf(stderr, "reached bug index 641\n");
+	}
+	if ((!FIXREVERTER[641] && (new_key == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	new_key->keylen = keylen;
 	return (new_key);
 }
@@ -338,10 +432,25 @@ sctp_set_key(uint8_t *key, uint32_t keylen)
 	sctp_key_t *new_key;
 
 	new_key = sctp_alloc_key(keylen);
-	if (new_key == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[645]) {
+	  if ((new_key == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 645\n");
+	  else
+	    fprintf(stderr, "reached bug index 645\n");
+	}
+	if ((!FIXREVERTER[645] && (new_key == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memcpy(new_key->key, key, keylen);
 	return (new_key);
 }
@@ -416,10 +525,25 @@ sctp_compute_hashkey(sctp_key_t *key1, sctp_key_t *key2, sctp_key_t *shared)
 	if (keylen > 0) {
 		/* get space for the new key */
 		new_key = sctp_alloc_key(keylen);
-		if (new_key == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[648]) {
+		  if ((new_key == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 648\n");
+		  else
+		    fprintf(stderr, "reached bug index 648\n");
+		}
+		if ((!FIXREVERTER[648] && (new_key == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* out of memory */
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		new_key->keylen = keylen;
 		key_ptr = new_key->key;
 	} else {
@@ -466,10 +590,25 @@ sctp_alloc_sharedkey(void)
 
 	SCTP_MALLOC(new_key, sctp_sharedkey_t *, sizeof(*new_key),
 		    SCTP_M_AUTH_KY);
-	if (new_key == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[655]) {
+	  if ((new_key == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 655\n");
+	  else
+	    fprintf(stderr, "reached bug index 655\n");
+	}
+	if ((!FIXREVERTER[655] && (new_key == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	new_key->keyid = 0;
 	new_key->key = NULL;
 	new_key->refcount = 1;
@@ -480,8 +619,23 @@ sctp_alloc_sharedkey(void)
 void
 sctp_free_sharedkey(sctp_sharedkey_t *skey)
 {
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[656]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 656\n");
+	  else
+	    fprintf(stderr, "reached bug index 656\n");
+	}
+	if ((!FIXREVERTER[656] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (SCTP_DECREMENT_AND_CHECK_REFCOUNT(&skey->refcount)) {
 		if (skey->key != NULL)
@@ -496,8 +650,23 @@ sctp_find_sharedkey(struct sctp_keyhead *shared_keys, uint16_t key_id)
 	sctp_sharedkey_t *skey;
 
 	LIST_FOREACH(skey, shared_keys, next) {
-		if (skey->keyid == key_id)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[657]) {
+		  if ((skey -> keyid == key_id ) && !(0))
+		    fprintf(stderr, "triggered bug index 657\n");
+		  else
+		    fprintf(stderr, "reached bug index 657\n");
+		}
+		if ((!FIXREVERTER[657] && (skey -> keyid == key_id ))
+		#else
+		if (0
+		#endif
+		)
 			return (skey);
+			#ifdef FRCOV
+			}
+			#endif
 	}
 	return (NULL);
 }
@@ -508,8 +677,23 @@ sctp_insert_sharedkey(struct sctp_keyhead *shared_keys,
 {
 	sctp_sharedkey_t *skey;
 
-	if ((shared_keys == NULL) || (new_skey == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[658]) {
+	  if ((shared_keys == (void *) 0 || new_skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 658\n");
+	  else
+	    fprintf(stderr, "reached bug index 658\n");
+	}
+	if ((!FIXREVERTER[658] && (shared_keys == (void *) 0 || new_skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (EINVAL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* insert into an empty list? */
 	if (LIST_EMPTY(shared_keys)) {
@@ -602,11 +786,41 @@ sctp_copy_sharedkey(const sctp_sharedkey_t *skey)
 {
 	sctp_sharedkey_t *new_skey;
 
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[660]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 660\n");
+	  else
+	    fprintf(stderr, "reached bug index 660\n");
+	}
+	if ((!FIXREVERTER[660] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	new_skey = sctp_alloc_sharedkey();
-	if (new_skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[661]) {
+	  if ((new_skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 661\n");
+	  else
+	    fprintf(stderr, "reached bug index 661\n");
+	}
+	if ((!FIXREVERTER[661] && (new_skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	if (skey->key != NULL)
 		new_skey->key = sctp_set_key(skey->key->key, skey->key->keylen);
 	else
@@ -621,8 +835,23 @@ sctp_copy_skeylist(const struct sctp_keyhead *src, struct sctp_keyhead *dest)
 	sctp_sharedkey_t *skey, *new_skey;
 	int count = 0;
 
-	if ((src == NULL) || (dest == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[662]) {
+	  if ((src == (void *) 0 || dest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 662\n");
+	  else
+	    fprintf(stderr, "reached bug index 662\n");
+	}
+	if ((!FIXREVERTER[662] && (src == (void *) 0 || dest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 	LIST_FOREACH(skey, src, next) {
 		new_skey = sctp_copy_sharedkey(skey);
 		if (new_skey != NULL) {
@@ -646,10 +875,25 @@ sctp_alloc_hmaclist(uint16_t num_hmacs)
 	alloc_size = sizeof(*new_list) + num_hmacs * sizeof(new_list->hmac[0]);
 	SCTP_MALLOC(new_list, sctp_hmaclist_t *, alloc_size,
 		    SCTP_M_AUTH_HL);
-	if (new_list == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[663]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 663\n");
+	  else
+	    fprintf(stderr, "reached bug index 663\n");
+	}
+	if ((!FIXREVERTER[663] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	new_list->max_algo = num_hmacs;
 	new_list->num_algo = 0;
 	return (new_list);
@@ -668,21 +912,66 @@ int
 sctp_auth_add_hmacid(sctp_hmaclist_t *list, uint16_t hmac_id)
 {
 	int i;
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[664]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 664\n");
+	  else
+	    fprintf(stderr, "reached bug index 664\n");
+	}
+	if ((!FIXREVERTER[664] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
-	if (list->num_algo == list->max_algo) {
+		#ifdef FRCOV
+		}
+		#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[665]) {
+	  if ((list -> num_algo == list -> max_algo ) && !(0))
+	    fprintf(stderr, "triggered bug index 665\n");
+	  else
+	    fprintf(stderr, "reached bug index 665\n");
+	}
+	if ((!FIXREVERTER[665] && (list -> num_algo == list -> max_algo ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_AUTH1,
 			"SCTP: HMAC id list full, ignoring add %u\n", hmac_id);
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(SCTP_SUPPORT_HMAC_SHA256)
 	if ((hmac_id != SCTP_AUTH_HMAC_ID_SHA1) &&
 	    (hmac_id != SCTP_AUTH_HMAC_ID_SHA256)) {
 #else
-	if (hmac_id != SCTP_AUTH_HMAC_ID_SHA1) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[666]) {
+	  if ((hmac_id != 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 666\n");
+	  else
+	    fprintf(stderr, "reached bug index 666\n");
+	}
+	if ((!FIXREVERTER[666] && (hmac_id != 1 ))
+	#else
+	if (0
+	#endif
+	) {
 #endif
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now is it already in the list */
 	for (i = 0; i < list->num_algo; i++) {
 		if (list->hmac[i] == hmac_id) {
@@ -701,12 +990,42 @@ sctp_copy_hmaclist(sctp_hmaclist_t *list)
 	sctp_hmaclist_t *new_list;
 	int i;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[667]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 667\n");
+	  else
+	    fprintf(stderr, "reached bug index 667\n");
+	}
+	if ((!FIXREVERTER[667] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	/* get a new list */
 	new_list = sctp_alloc_hmaclist(list->max_algo);
-	if (new_list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[668]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 668\n");
+	  else
+	    fprintf(stderr, "reached bug index 668\n");
+	}
+	if ((!FIXREVERTER[668] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	/* copy it */
 	new_list->max_algo = list->max_algo;
 	new_list->num_algo = list->num_algo;
@@ -725,8 +1044,23 @@ sctp_default_supported_hmaclist(void)
 #else
 	new_list = sctp_alloc_hmaclist(1);
 #endif
-	if (new_list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[669]) {
+	  if ((new_list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 669\n");
+	  else
+	    fprintf(stderr, "reached bug index 669\n");
+	}
+	if ((!FIXREVERTER[669] && (new_list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 #if defined(SCTP_SUPPORT_HMAC_SHA256)
 	/* We prefer SHA256, so list it first */
 	(void)sctp_auth_add_hmacid(new_list, SCTP_AUTH_HMAC_ID_SHA256);
@@ -744,8 +1078,23 @@ sctp_negotiate_hmacid(sctp_hmaclist_t *peer, sctp_hmaclist_t *local)
 {
 	int i, j;
 
-	if ((local == NULL) || (peer == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[670]) {
+	  if ((local == (void *) 0 || peer == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 670\n");
+	  else
+	    fprintf(stderr, "reached bug index 670\n");
+	}
+	if ((!FIXREVERTER[670] && (local == (void *) 0 || peer == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (SCTP_AUTH_HMAC_ID_RSVD);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < peer->num_algo; i++) {
 		for (j = 0; j < local->num_algo; j++) {
@@ -772,8 +1121,23 @@ sctp_serialize_hmaclist(sctp_hmaclist_t *list, uint8_t *ptr)
 	int i;
 	uint16_t hmac_id;
 
-	if (list == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[671]) {
+	  if ((list == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 671\n");
+	  else
+	    fprintf(stderr, "reached bug index 671\n");
+	}
+	if ((!FIXREVERTER[671] && (list == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < list->num_algo; i++) {
 		hmac_id = htons(list->hmac[i]);
@@ -815,8 +1179,23 @@ sctp_alloc_authinfo(void)
 void
 sctp_free_authinfo(sctp_authinfo_t *authinfo)
 {
-	if (authinfo == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[673]) {
+	  if ((authinfo == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 673\n");
+	  else
+	    fprintf(stderr, "reached bug index 673\n");
+	}
+	if ((!FIXREVERTER[673] && (authinfo == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (authinfo->random != NULL)
 		sctp_free_key(authinfo->random);
@@ -958,15 +1337,44 @@ sctp_hmac(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,
 	uint32_t i;
 
 	/* sanity check the material and length */
-	if ((key == NULL) || (keylen == 0) || (text == NULL) ||
-	    (textlen == 0) || (digest == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[676]) {
+	  if ((key == (void *) 0 || keylen == 0 || text == (void *) 0 || textlen == 0 || digest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 676\n");
+	  else
+	    fprintf(stderr, "reached bug index 676\n");
+	}
+	if ((!FIXREVERTER[676] && (key == (void *) 0 || keylen == 0 || text == (void *) 0 || textlen == 0 || digest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* can't do HMAC with empty key or text or digest store */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* validate the hmac algo and get the digest length */
 	digestlen = sctp_get_hmac_digest_len(hmac_algo);
-	if (digestlen == 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[677]) {
+	  if ((digestlen == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 677\n");
+	  else
+	    fprintf(stderr, "reached bug index 677\n");
+	}
+	if ((!FIXREVERTER[677] && (digestlen == 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* hash the key if it is longer than the hash block size */
 	blocklen = sctp_get_hmac_block_len(hmac_algo);
@@ -1019,14 +1427,44 @@ sctp_hmac_m(uint16_t hmac_algo, uint8_t *key, uint32_t keylen,
 	struct mbuf *m_tmp;
 
 	/* sanity check the material and length */
-	if ((key == NULL) || (keylen == 0) || (m == NULL) || (digest == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[682]) {
+	  if ((key == (void *) 0 || keylen == 0 || m == (void *) 0 || digest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 682\n");
+	  else
+	    fprintf(stderr, "reached bug index 682\n");
+	}
+	if ((!FIXREVERTER[682] && (key == (void *) 0 || keylen == 0 || m == (void *) 0 || digest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* can't do HMAC with empty key or text or digest store */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* validate the hmac algo and get the digest length */
 	digestlen = sctp_get_hmac_digest_len(hmac_algo);
-	if (digestlen == 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[683]) {
+	  if ((digestlen == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 683\n");
+	  else
+	    fprintf(stderr, "reached bug index 683\n");
+	}
+	if ((!FIXREVERTER[683] && (digestlen == 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* hash the key if it is longer than the hash block size */
 	blocklen = sctp_get_hmac_block_len(hmac_algo);
@@ -1133,14 +1571,44 @@ sctp_compute_hmac_m(uint16_t hmac_algo, sctp_key_t *key, struct mbuf *m,
 	uint8_t temp[SCTP_AUTH_DIGEST_LEN_MAX];
 
 	/* sanity check */
-	if ((key == NULL) || (m == NULL) || (digest == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[691]) {
+	  if ((key == (void *) 0 || m == (void *) 0 || digest == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 691\n");
+	  else
+	    fprintf(stderr, "reached bug index 691\n");
+	}
+	if ((!FIXREVERTER[691] && (key == (void *) 0 || m == (void *) 0 || digest == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* can't do HMAC with empty key or text or digest store */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* validate the hmac algo and get the digest length */
 	digestlen = sctp_get_hmac_digest_len(hmac_algo);
-	if (digestlen == 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[692]) {
+	  if ((digestlen == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 692\n");
+	  else
+	    fprintf(stderr, "reached bug index 692\n");
+	}
+	if ((!FIXREVERTER[692] && (digestlen == 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* hash the key if it is longer than the hash block size */
 	blocklen = sctp_get_hmac_block_len(hmac_algo);
@@ -1160,8 +1628,23 @@ sctp_auth_is_supported_hmac(sctp_hmaclist_t *list, uint16_t id)
 {
 	int i;
 
-	if ((list == NULL) || (id == SCTP_AUTH_HMAC_ID_RSVD))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[694]) {
+	  if ((list == (void *) 0 ) && !(id == 0 ))
+	    fprintf(stderr, "triggered bug index 694\n");
+	  else
+	    fprintf(stderr, "reached bug index 694\n");
+	}
+	if ((FIXREVERTER[694] && (id == 0 )) || (!FIXREVERTER[694] && (list == (void *) 0 || id == 0 ))
+	#else
+	if (id == 0 
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < list->num_algo; i++)
 		if (list->hmac[i] == id)
@@ -1180,8 +1663,23 @@ sctp_auth_is_supported_hmac(sctp_hmaclist_t *list, uint16_t id)
 void
 sctp_clear_cachedkeys(struct sctp_tcb *stcb, uint16_t keyid)
 {
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[695]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 695\n");
+	  else
+	    fprintf(stderr, "reached bug index 695\n");
+	}
+	if ((!FIXREVERTER[695] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (keyid == stcb->asoc.authinfo.assoc_keyid) {
 		sctp_free_key(stcb->asoc.authinfo.assoc_key);
@@ -1203,8 +1701,23 @@ sctp_clear_cachedkeys_ep(struct sctp_inpcb *inp, uint16_t keyid)
 {
 	struct sctp_tcb *stcb;
 
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[696]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 696\n");
+	  else
+	    fprintf(stderr, "reached bug index 696\n");
+	}
+	if ((!FIXREVERTER[696] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* clear the cached keys on all assocs on this instance */
 	LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
@@ -1223,8 +1736,23 @@ sctp_delete_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[697]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 697\n");
+	  else
+	    fprintf(stderr, "reached bug index 697\n");
+	}
+	if ((!FIXREVERTER[697] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the assoc active sending key */
 	if (keyid == stcb->asoc.authinfo.active_keyid)
@@ -1232,12 +1760,42 @@ sctp_delete_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[698]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 698\n");
+	  else
+	    fprintf(stderr, "reached bug index 698\n");
+	}
+	if ((!FIXREVERTER[698] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* are there other refcount holders on the key? */
-	if (skey->refcount > 1)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[699]) {
+	  if ((skey -> refcount > 1 ) && !(0))
+	    fprintf(stderr, "triggered bug index 699\n");
+	  else
+	    fprintf(stderr, "reached bug index 699\n");
+	}
+	if ((!FIXREVERTER[699] && (skey -> refcount > 1 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* remove it */
 	LIST_REMOVE(skey, next);
@@ -1257,8 +1815,23 @@ sctp_delete_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[700]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 700\n");
+	  else
+	    fprintf(stderr, "reached bug index 700\n");
+	}
+	if ((!FIXREVERTER[700] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the active sending key on the endpoint */
 	if (keyid == inp->sctp_ep.default_keyid)
@@ -1266,8 +1839,23 @@ sctp_delete_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[701]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 701\n");
+	  else
+	    fprintf(stderr, "reached bug index 701\n");
+	}
+	if ((!FIXREVERTER[701] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* endpoint keys are not refcounted */
 
@@ -1291,10 +1879,25 @@ sctp_auth_setactivekey(struct sctp_tcb *stcb, uint16_t keyid)
 
 	/* find the key on the assoc */
 	skey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);
-	if (skey == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[702]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 702\n");
+	  else
+	    fprintf(stderr, "reached bug index 702\n");
+	}
+	if ((!FIXREVERTER[702] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* that key doesn't exist */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((skey->deactivated) && (skey->refcount > 1)) {
 		/* can't reactivate a deactivated key with other refcounts */
 		return (-1);
@@ -1319,10 +1922,25 @@ sctp_auth_setactivekey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 
 	/* find the key */
 	skey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);
-	if (skey == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[703]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 703\n");
+	  else
+	    fprintf(stderr, "reached bug index 703\n");
+	}
+	if ((!FIXREVERTER[703] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* that key doesn't exist */
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	inp->sctp_ep.default_keyid = keyid;
 	return (0);
 }
@@ -1336,8 +1954,23 @@ sctp_deact_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[704]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 704\n");
+	  else
+	    fprintf(stderr, "reached bug index 704\n");
+	}
+	if ((!FIXREVERTER[704] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the assoc active sending key */
 	if (keyid == stcb->asoc.authinfo.active_keyid)
@@ -1345,8 +1978,23 @@ sctp_deact_sharedkey(struct sctp_tcb *stcb, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&stcb->asoc.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[705]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 705\n");
+	  else
+	    fprintf(stderr, "reached bug index 705\n");
+	}
+	if ((!FIXREVERTER[705] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* are there other refcount holders on the key? */
 	if (skey->refcount == 1) {
@@ -1370,8 +2018,23 @@ sctp_deact_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 {
 	sctp_sharedkey_t *skey;
 
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[706]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 706\n");
+	  else
+	    fprintf(stderr, "reached bug index 706\n");
+	}
+	if ((!FIXREVERTER[706] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* is the keyid the active sending key on the endpoint */
 	if (keyid == inp->sctp_ep.default_keyid)
@@ -1379,8 +2042,23 @@ sctp_deact_sharedkey_ep(struct sctp_inpcb *inp, uint16_t keyid)
 
 	/* does the key exist? */
 	skey = sctp_find_sharedkey(&inp->sctp_ep.shared_keys, keyid);
-	if (skey == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[707]) {
+	  if ((skey == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 707\n");
+	  else
+	    fprintf(stderr, "reached bug index 707\n");
+	}
+	if ((!FIXREVERTER[707] && (skey == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (-1);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* endpoint keys are not refcounted */
 
@@ -1421,16 +2099,61 @@ sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,
 		ptype = ntohs(phdr->param_type);
 		plen = ntohs(phdr->param_length);
 
-		if ((plen == 0) || (offset + plen > length))
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[711]) {
+		  if ((plen == 0 || offset + plen > length ) && !(0))
+		    fprintf(stderr, "triggered bug index 711\n");
+		  else
+		    fprintf(stderr, "reached bug index 711\n");
+		}
+		if ((!FIXREVERTER[711] && (plen == 0 || offset + plen > length ))
+		#else
+		if (0
+		#endif
+		)
 			break;
+			#ifdef FRCOV
+			}
+			#endif
 
 		if (ptype == SCTP_RANDOM) {
-			if (plen > sizeof(random_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[712]) {
+			  if ((plen > sizeof ( random_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 712\n");
+			  else
+			    fprintf(stderr, "reached bug index 712\n");
+			}
+			if ((!FIXREVERTER[712] && (plen > sizeof ( random_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)random_store, plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[713]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 713\n");
+			  else
+			    fprintf(stderr, "reached bug index 713\n");
+			}
+			if ((!FIXREVERTER[713] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return;
+				#ifdef FRCOV
+				}
+				#endif
 			/* save the random and length for the key */
 			p_random = (struct sctp_auth_random *)phdr;
 			random_len = plen - sizeof(*p_random);
@@ -1438,12 +2161,42 @@ sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,
 			uint16_t num_hmacs;
 			uint16_t i;
 
-			if (plen > sizeof(hmacs_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[714]) {
+			  if ((plen > sizeof ( hmacs_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 714\n");
+			  else
+			    fprintf(stderr, "reached bug index 714\n");
+			}
+			if ((!FIXREVERTER[714] && (plen > sizeof ( hmacs_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)hmacs_store, plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[715]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 715\n");
+			  else
+			    fprintf(stderr, "reached bug index 715\n");
+			}
+			if ((!FIXREVERTER[715] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return;
+				#ifdef FRCOV
+				}
+				#endif
 			/* save the hmacs list and num for the key */
 			hmacs = (struct sctp_auth_hmac_algo *)phdr;
 			hmacs_len = plen - sizeof(*hmacs);
@@ -1460,12 +2213,42 @@ sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m,
 		} else if (ptype == SCTP_CHUNK_LIST) {
 			int i;
 
-			if (plen > sizeof(chunks_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[716]) {
+			  if ((plen > sizeof ( chunks_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 716\n");
+			  else
+			    fprintf(stderr, "reached bug index 716\n");
+			}
+			if ((!FIXREVERTER[716] && (plen > sizeof ( chunks_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)chunks_store, plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[717]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 717\n");
+			  else
+			    fprintf(stderr, "reached bug index 717\n");
+			}
+			if ((!FIXREVERTER[717] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return;
+				#ifdef FRCOV
+				}
+				#endif
 			chunks = (struct sctp_auth_chunk_list *)phdr;
 			num_chunks = plen - sizeof(*chunks);
 			/* save chunks list and num for the key */
@@ -1541,8 +2324,23 @@ sctp_fill_hmac_digest_m(struct mbuf *m, uint32_t auth_offset,
 	sctp_sharedkey_t *skey;
 	sctp_key_t *key;
 
-	if ((stcb == NULL) || (auth == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[719]) {
+	  if ((stcb == (void *) 0 || auth == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 719\n");
+	  else
+	    fprintf(stderr, "reached bug index 719\n");
+	}
+	if ((!FIXREVERTER[719] && (stcb == (void *) 0 || auth == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* zero the digest + chunk padding */
 	digestlen = sctp_get_hmac_digest_len(stcb->asoc.peer_hmac_id);
@@ -1591,8 +2389,23 @@ sctp_zero_m(struct mbuf *m, uint32_t m_offset, uint32_t size)
 	uint8_t *data;
 
 	/* sanity check */
-	if (m == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[720]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 720\n");
+	  else
+	    fprintf(stderr, "reached bug index 720\n");
+	}
+	if ((!FIXREVERTER[720] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* find the correct starting mbuf and offset (get start position) */
 	m_tmp = m;
@@ -1685,13 +2498,28 @@ sctp_handle_auth(struct sctp_tcb *stcb, struct sctp_auth_chunk *auth,
 		skey = sctp_find_sharedkey(&stcb->asoc.shared_keys,
 					   shared_key_id);
 		/* if the shared key isn't found, discard the chunk */
-		if (skey == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[723]) {
+		  if ((skey == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 723\n");
+		  else
+		    fprintf(stderr, "reached bug index 723\n");
+		}
+		if ((!FIXREVERTER[723] && (skey == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_STAT_INCR(sctps_recvivalkeyid);
 			SCTPDBG(SCTP_DEBUG_AUTH1,
 				"SCTP Auth: unknown key id %u\n",
 				shared_key_id);
 			return (-1);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* generate a notification if this is a new key id */
 		if (stcb->asoc.authinfo.recv_keyid != shared_key_id)
 			/*
@@ -1774,9 +2602,24 @@ sctp_notify_authentication(struct sctp_tcb *stcb, uint32_t indication,
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_authkey_event),
 					  0, M_NOWAIT, 1, MT_HEADER);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[725]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 725\n");
+	  else
+	    fprintf(stderr, "reached bug index 725\n");
+	}
+	if ((!FIXREVERTER[725] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	SCTP_BUF_LEN(m_notify) = 0;
 	auth = mtod(m_notify, struct sctp_authkey_event *);
@@ -1795,11 +2638,26 @@ sctp_notify_authentication(struct sctp_tcb *stcb, uint32_t indication,
 	/* append to socket */
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	    0, 0, stcb->asoc.context, 0, 0, 0, m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[726]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 726\n");
+	  else
+	    fprintf(stderr, "reached bug index 726\n");
+	}
+	if ((!FIXREVERTER[726] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -1831,9 +2689,24 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 		ptype = ntohs(phdr->param_type);
 		plen = ntohs(phdr->param_length);
 
-		if (offset + plen > limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[727]) {
+		  if ((offset + plen > limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 727\n");
+		  else
+		    fprintf(stderr, "reached bug index 727\n");
+		}
+		if ((!FIXREVERTER[727] && (offset + plen > limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (plen < sizeof(struct sctp_paramhdr)) {
 			break;
 		}
@@ -1843,15 +2716,45 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 			uint8_t local_store[SCTP_SMALL_CHUNK_STORE];
 			int num_ent, i;
 
-			if (plen > sizeof(local_store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[729]) {
+			  if ((plen > sizeof ( local_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 729\n");
+			  else
+			    fprintf(stderr, "reached bug index 729\n");
+			}
+			if ((!FIXREVERTER[729] && (plen > sizeof ( local_store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 			                           (struct sctp_paramhdr *)&local_store,
 			                           plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[730]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 730\n");
+			  else
+			    fprintf(stderr, "reached bug index 730\n");
+			}
+			if ((!FIXREVERTER[730] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			pr_supported = (struct sctp_supported_chunk_types_param *)phdr;
 			num_ent = plen - sizeof(struct sctp_paramhdr);
 			for (i = 0; i < num_ent; i++) {
@@ -1879,15 +2782,45 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 			uint8_t store[SCTP_PARAM_BUFFER_SIZE];
 			int num_hmacs;
 
-			if (plen > sizeof(store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[732]) {
+			  if ((plen > sizeof ( store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 732\n");
+			  else
+			    fprintf(stderr, "reached bug index 732\n");
+			}
+			if ((!FIXREVERTER[732] && (plen > sizeof ( store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 			                           (struct sctp_paramhdr *)store,
 			                           plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[733]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 733\n");
+			  else
+			    fprintf(stderr, "reached bug index 733\n");
+			}
+			if ((!FIXREVERTER[733] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			hmacs = (struct sctp_auth_hmac_algo *)phdr;
 			num_hmacs = (plen - sizeof(*hmacs)) / sizeof(hmacs->hmac_ids[0]);
 			/* validate the hmac list */
@@ -1902,15 +2835,45 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 			uint8_t chunks_store[SCTP_SMALL_CHUNK_STORE];
 			int i, num_chunks;
 
-			if (plen > sizeof(chunks_store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[735]) {
+			  if ((plen > sizeof ( chunks_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 735\n");
+			  else
+			    fprintf(stderr, "reached bug index 735\n");
+			}
+			if ((!FIXREVERTER[735] && (plen > sizeof ( chunks_store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)chunks_store,
 						   plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[736]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 736\n");
+			  else
+			    fprintf(stderr, "reached bug index 736\n");
+			}
+			if ((!FIXREVERTER[736] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/*-
 			 * Flip through the list and mark that the
 			 * peer supports asconf/asconf_ack.
@@ -1930,9 +2893,24 @@ sctp_validate_init_auth_params(struct mbuf *m, int offset, int limit)
 		}
 
 		offset += SCTP_SIZE32(plen);
-		if (offset >= limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[737]) {
+		  if ((offset >= limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 737\n");
+		  else
+		    fprintf(stderr, "reached bug index 737\n");
+		}
+		if ((!FIXREVERTER[737] && (offset >= limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		phdr = sctp_get_next_param(m, offset, &param_buf,
 		    sizeof(param_buf));
 	}
diff --git a/usrsctplib/netinet/sctp_bsd_addr.c b/usrsctplib/netinet/sctp_bsd_addr.c
index e053c4d..a396051 100755
--- a/usrsctplib/netinet/sctp_bsd_addr.c
+++ b/usrsctplib/netinet/sctp_bsd_addr.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -647,9 +651,24 @@ sctp_init_ifns_for_vrf(int vrfid)
 void
 sctp_init_vrf_list(int vrfid)
 {
-	if (vrfid > SCTP_MAX_VRF_ID)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[314]) {
+	  if ((vrfid > 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 314\n");
+	  else
+	    fprintf(stderr, "reached bug index 314\n");
+	}
+	if ((!FIXREVERTER[314] && (vrfid > 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* can't do that */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* Don't care about return here */
 	(void)sctp_allocate_vrf(vrfid);
@@ -799,10 +818,25 @@ sctp_get_mbuf_for_msg(unsigned int space_needed, int want_header,
 #else
 	m =  m_getm2(NULL, space_needed, how, type, want_header ? M_PKTHDR : 0);
 #endif
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[315]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 315\n");
+	  else
+	    fprintf(stderr, "reached bug index 315\n");
+	}
+	if ((!FIXREVERTER[315] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* bad, no memory */
 		return (m);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if !defined(__Userspace__)
 	if (allonebuf) {
 		if (SCTP_BUF_SIZE(m) < space_needed) {
diff --git a/usrsctplib/netinet/sctp_callout.c b/usrsctplib/netinet/sctp_callout.c
index 4ca094f..f7bc52e 100755
--- a/usrsctplib/netinet/sctp_callout.c
+++ b/usrsctplib/netinet/sctp_callout.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -110,8 +114,23 @@ sctp_os_timer_start(sctp_os_timer_t *c, int to_ticks, void (*ftn) (void *),
                     void *arg)
 {
 	/* paranoia */
-	if ((c == NULL) || (ftn == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[613]) {
+	  if ((c == (void *) 0 || ftn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 613\n");
+	  else
+	    fprintf(stderr, "reached bug index 613\n");
+	}
+	if ((!FIXREVERTER[613] && (c == (void *) 0 || ftn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 	    return;
+	    #ifdef FRCOV
+	    }
+	    #endif
 
 	SCTP_TIMERQ_LOCK();
 	/* check to see if we're rescheduling a timer */
@@ -147,8 +166,23 @@ sctp_os_timer_start(sctp_os_timer_t *c, int to_ticks, void (*ftn) (void *),
 	 * We could unlock/splx here and lock/spl at the TAILQ_INSERT_TAIL,
 	 * but there's no point since doing this setup doesn't take much time.
 	 */
-	if (to_ticks <= 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[614]) {
+	  if ((to_ticks <= 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 614\n");
+	  else
+	    fprintf(stderr, "reached bug index 614\n");
+	}
+	if ((!FIXREVERTER[614] && (to_ticks <= 0 ))
+	#else
+	if (0
+	#endif
+	)
 		to_ticks = 1;
+		#ifdef FRCOV
+		}
+		#endif
 
 	c->c_arg = arg;
 	c->c_flags = (SCTP_CALLOUT_ACTIVE | SCTP_CALLOUT_PENDING);
diff --git a/usrsctplib/netinet/sctp_indata.c b/usrsctplib/netinet/sctp_indata.c
index 8b33235..ff61ff8 100755
--- a/usrsctplib/netinet/sctp_indata.c
+++ b/usrsctplib/netinet/sctp_indata.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -93,9 +97,24 @@ sctp_calc_rwnd(struct sctp_tcb *stcb, struct sctp_association *asoc)
 	 * sctp_soreceive then we will fix this so that ONLY this
 	 * associations data is taken into account.
 	 */
-	if (stcb->sctp_socket == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[115]) {
+	  if ((stcb -> sctp_socket == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 115\n");
+	  else
+	    fprintf(stderr, "reached bug index 115\n");
+	}
+	if ((!FIXREVERTER[115] && (stcb -> sctp_socket == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (calc);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	KASSERT(asoc->cnt_on_reasm_queue > 0 || asoc->size_on_reasm_queue == 0,
 	        ("size_on_reasm_queue is %u", asoc->size_on_reasm_queue));
@@ -118,10 +137,25 @@ sctp_calc_rwnd(struct sctp_tcb *stcb, struct sctp_association *asoc)
 	                                         asoc->cnt_on_reasm_queue * MSIZE));
 	calc = sctp_sbspace_sub(calc, (uint32_t)(asoc->size_on_all_streams +
 	                                         asoc->cnt_on_all_streams * MSIZE));
-	if (calc == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[116]) {
+	  if ((calc == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 116\n");
+	  else
+	    fprintf(stderr, "reached bug index 116\n");
+	}
+	if ((!FIXREVERTER[116] && (calc == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of space */
 		return (calc);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* what is the overhead of all these rwnd's */
 	calc = sctp_sbspace_sub(calc, stcb->asoc.my_rwnd_control_len);
@@ -150,9 +184,24 @@ sctp_build_readq_entry(struct sctp_tcb *stcb,
 	struct sctp_queued_to_read *read_queue_e = NULL;
 
 	sctp_alloc_a_readq(stcb, read_queue_e);
-	if (read_queue_e == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[117]) {
+	  if ((read_queue_e == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 117\n");
+	  else
+	    fprintf(stderr, "reached bug index 117\n");
+	}
+	if ((!FIXREVERTER[117] && (read_queue_e == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		goto failed_build;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(read_queue_e, 0, sizeof(struct sctp_queued_to_read));
 	read_queue_e->sinfo_stream = sid;
 	read_queue_e->sinfo_flags = (flags << 8);
@@ -842,9 +891,24 @@ restart:
 		if (chk->rec.data.fsn == fsn) {
 			/* Ok lets add it */
 			sctp_alloc_a_readq(stcb, nc);
-			if (nc == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[122]) {
+			  if ((nc == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 122\n");
+			  else
+			    fprintf(stderr, "reached bug index 122\n");
+			}
+			if ((!FIXREVERTER[122] && (nc == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			memset(nc, 0, sizeof(struct sctp_queued_to_read));
 			TAILQ_REMOVE(&control->reasm, chk, sctp_next);
 			sctp_add_chk_to_control(control, strm, stcb, asoc, chk, SCTP_READ_LOCK_NOT_HELD);
@@ -1167,9 +1231,24 @@ done_un:
 		/* Can't add more */
 		return (0);
 	}
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[123]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 123\n");
+	  else
+	    fprintf(stderr, "reached bug index 123\n");
+	}
+	if ((!FIXREVERTER[123] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (ret);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (SCTP_MID_EQ(asoc->idata_supported, strm->last_mid_delivered, control->mid)) {
 		/* Ok the guy at the top was being partially delivered
 		 * completed, so we remove it. Note
@@ -1757,9 +1836,24 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MAP_LOGGING_ENABLE) {
 		sctp_log_map(tsn, asoc->cumulative_tsn, asoc->highest_tsn_inside_map, SCTP_MAP_TSN_ENTERS);
 	}
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[125]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 125\n");
+	  else
+	    fprintf(stderr, "reached bug index 125\n");
+	}
+	if ((!FIXREVERTER[125] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_LTRACE_CHK(stcb->sctp_ep, stcb, chk_type, tsn);
 	if (SCTP_TSN_GE(asoc->cumulative_tsn, tsn)) {
 		/* It is a duplicate */
@@ -1974,9 +2068,24 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 				return (0);
 			}
 		} else {
-			if (control == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[126]) {
+			  if ((control == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 126\n");
+			  else
+			    fprintf(stderr, "reached bug index 126\n");
+			}
+			if ((!FIXREVERTER[126] && (control == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				goto dump_packet;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (SCTP_TSN_GT(fsn, control->top_fsn)) {
 				goto dump_packet;
 			}
@@ -2080,10 +2189,25 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			m_adj(dmbuf, -(l_len - the_len));
 		}
 	}
-	if (dmbuf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[127]) {
+	  if ((dmbuf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 127\n");
+	  else
+	    fprintf(stderr, "reached bug index 127\n");
+	}
+	if ((!FIXREVERTER[127] && (dmbuf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_STAT_INCR(sctps_nomem);
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * Now no matter what, we need a control, get one
 	 * if we don't have one (we may have gotten it
@@ -2096,10 +2220,25 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 					   sid,
 					   chk_flags,
 					   NULL, fsn, mid);
-		if (control == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[128]) {
+		  if ((control == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 128\n");
+		  else
+		    fprintf(stderr, "reached bug index 128\n");
+		}
+		if ((!FIXREVERTER[128] && (control == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_STAT_INCR(sctps_nomem);
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((chk_flags & SCTP_DATA_NOT_FRAG) == SCTP_DATA_NOT_FRAG) {
 			struct mbuf *mm;
 
@@ -2161,7 +2300,19 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 	/* Now will we need a chunk too? */
 	if ((chk_flags & SCTP_DATA_NOT_FRAG) != SCTP_DATA_NOT_FRAG) {
 		sctp_alloc_a_chunk(stcb, chk);
-		if (chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[129]) {
+		  if ((chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 129\n");
+		  else
+		    fprintf(stderr, "reached bug index 129\n");
+		}
+		if ((!FIXREVERTER[129] && (chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* No memory so we drop the chunk */
 			SCTP_STAT_INCR(sctps_nomem);
 			if (last_chunk == 0) {
@@ -2170,6 +2321,9 @@ sctp_process_a_data_chunk(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			}
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chk->rec.data.tsn = tsn;
 		chk->no_fr_allowed = 0;
 		chk->rec.data.fsn = fsn;
@@ -2729,9 +2883,24 @@ sctp_process_data(struct mbuf **mm, int iphlen, int *offset, int length,
 	ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 	                                           sizeof(struct sctp_chunkhdr),
 	                                           (uint8_t *)&chunk_buf);
-	if (ch == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[131]) {
+	  if ((ch == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 131\n");
+	  else
+	    fprintf(stderr, "reached bug index 131\n");
+	}
+	if ((!FIXREVERTER[131] && (ch == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * process all DATA chunks...
 	 */
@@ -2917,11 +3086,26 @@ sctp_process_data(struct mbuf **mm, int iphlen, int *offset, int length,
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 		                                           sizeof(struct sctp_chunkhdr),
 		                                           (uint8_t *)&chunk_buf);
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[137]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 137\n");
+		  else
+		    fprintf(stderr, "reached bug index 137\n");
+		}
+		if ((!FIXREVERTER[137] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			*offset = length;
 			stop_proc = 1;
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	if (break_flag) {
 		/*
@@ -3136,10 +3320,27 @@ sctp_process_segment_range(struct sctp_tcb *stcb, struct sctp_tmit_chunk **p_tp1
 					 * All chunks NOT UNSENT fall through here and are marked
 					 * (leave PR-SCTP ones that are to skip alone though)
 					 */
-					if ((tp1->sent != SCTP_FORWARD_TSN_SKIP) &&
-					    (tp1->sent != SCTP_DATAGRAM_NR_ACKED)) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[138]) {
+					  fprintf(stderr, "reached bug index 138\n");
+					}
+					if ((FIXREVERTER[138] && (tp1 -> sent != 30010 )) || (!FIXREVERTER[138] && (tp1 -> sent != 30010 && tp1 -> sent != 40010 ))
+					#else
+					if (tp1 -> sent != 30010 
+					#endif
+					) {
+					      
+					    #ifdef FRCOV
+					      if (!(tp1 -> sent != 40010 ))
+					        fprintf(stderr, "triggered bug index 138\n");
+					      #endif
+					    
 						tp1->sent = SCTP_DATAGRAM_MARKED;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if (tp1->rec.data.chunk_was_revoked) {
 						/* deflate the cwnd */
 						tp1->whoTo->cwnd -= tp1->book_size;
@@ -3176,10 +3377,28 @@ sctp_process_segment_range(struct sctp_tcb *stcb, struct sctp_tmit_chunk **p_tp1
 				break;
 			}
 			tp1 = TAILQ_NEXT(tp1, sctp_next);
-			if ((tp1 == NULL) && (circled == 0)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[139]) {
+			  fprintf(stderr, "reached bug index 139\n");
+			}
+			if ((FIXREVERTER[139] && (circled == 0 )) || (!FIXREVERTER[139] && (tp1 == (void *) 0 && circled == 0 ))
+			#else
+			if (circled == 0 
+			#endif
+			) {
+			  
+			#ifdef FRCOV
+			  if (!(tp1 == (void *) 0 ))
+			    fprintf(stderr, "triggered bug index 139\n");
+			  #endif
+			
 				circled++;
 				tp1 = TAILQ_FIRST(&stcb->asoc.sent_queue);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}	/* end while (tp1) */
 		if (tp1 == NULL) {
 			circled = 0;
@@ -3218,16 +3437,46 @@ sctp_handle_segments(struct mbuf *m, int *offset, struct sctp_tcb *stcb, struct
 		frag = (struct sctp_gap_ack_block *)sctp_m_getptr(m, *offset,
 		                                                  sizeof(struct sctp_gap_ack_block), (uint8_t *) &block);
 		*offset += sizeof(block);
-		if (frag == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[140]) {
+		  if ((frag == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 140\n");
+		  else
+		    fprintf(stderr, "reached bug index 140\n");
+		}
+		if ((!FIXREVERTER[140] && (frag == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (chunk_freed);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		frag_strt = ntohs(frag->start);
 		frag_end = ntohs(frag->end);
 
-		if (frag_strt > frag_end) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[141]) {
+		  if ((frag_strt > frag_end ) && !(0))
+		    fprintf(stderr, "triggered bug index 141\n");
+		  else
+		    fprintf(stderr, "reached bug index 141\n");
+		}
+		if ((!FIXREVERTER[141] && (frag_strt > frag_end ))
+		#else
+		if (0
+		#endif
+		) {
 			/* This gap report is malformed, skip it. */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (frag_strt <= prev_frag_end) {
 			/* This gap report is not in order, so restart. */
 			 tp1 = TAILQ_FIRST(&asoc->sent_queue);
@@ -3307,8 +3556,23 @@ sctp_check_for_revoked(struct sctp_tcb *stcb,
 				tp1->sent = SCTP_DATAGRAM_ACKED;
 			}
 		}
-		if (tp1->sent == SCTP_DATAGRAM_UNSENT)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[142]) {
+		  if ((tp1 -> sent == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 142\n");
+		  else
+		    fprintf(stderr, "reached bug index 142\n");
+		}
+		if ((!FIXREVERTER[142] && (tp1 -> sent == 0 ))
+		#else
+		if (0
+		#endif
+		)
 			break;
+			#ifdef FRCOV
+			}
+			#endif
 	}
 }
 
@@ -3388,7 +3652,19 @@ sctp_strike_gap_ack_chunks(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			/* we are beyond the tsn in the sack  */
 			break;
 		}
-		if (tp1->sent >= SCTP_DATAGRAM_RESEND) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[143]) {
+		  if ((tp1 -> sent >= 4 ) && !(0))
+		    fprintf(stderr, "triggered bug index 143\n");
+		  else
+		    fprintf(stderr, "reached bug index 143\n");
+		}
+		if ((!FIXREVERTER[143] && (tp1 -> sent >= 4 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* either a RESEND, ACKED, or MARKED */
 			/* skip */
 			if (tp1->sent == SCTP_FORWARD_TSN_SKIP) {
@@ -3397,6 +3673,9 @@ sctp_strike_gap_ack_chunks(struct sctp_tcb *stcb, struct sctp_association *asoc,
 			}
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/*
 		 * CMT : SFR algo (covers part of DAC and HTNA as well)
 		 */
@@ -3855,8 +4134,23 @@ sctp_fs_audit(struct sctp_association *asoc)
 	entry_flight = asoc->total_flight;
 	entry_cnt = asoc->total_flight_count;
 #endif
-	if (asoc->pr_sctp_cnt >= asoc->sent_queue_cnt)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[144]) {
+	  if ((asoc -> pr_sctp_cnt >= asoc -> sent_queue_cnt ) && !(0))
+	    fprintf(stderr, "triggered bug index 144\n");
+	  else
+	    fprintf(stderr, "reached bug index 144\n");
+	}
+	if ((!FIXREVERTER[144] && (asoc -> pr_sctp_cnt >= asoc -> sent_queue_cnt ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	TAILQ_FOREACH(chk, &asoc->sent_queue, sctp_next) {
 		if (chk->sent < SCTP_DATAGRAM_RESEND) {
@@ -3898,7 +4192,19 @@ sctp_window_probe_recovery(struct sctp_tcb *stcb,
 			   struct sctp_tmit_chunk *tp1)
 {
 	tp1->window_probe = 0;
-	if ((tp1->sent >= SCTP_DATAGRAM_ACKED) || (tp1->data == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[145]) {
+	  if ((tp1 -> sent >= 10010 || tp1 -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 145\n");
+	  else
+	    fprintf(stderr, "reached bug index 145\n");
+	}
+	if ((!FIXREVERTER[145] && (tp1 -> sent >= 10010 || tp1 -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* TSN's skipped we do NOT move back. */
 		sctp_misc_ints(SCTP_FLIGHT_LOG_DWN_WP_FWD,
 			       tp1->whoTo ? tp1->whoTo->flight_size : 0,
@@ -3907,6 +4213,9 @@ sctp_window_probe_recovery(struct sctp_tcb *stcb,
 			       tp1->rec.data.tsn);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* First setup this by shrinking flight */
 	if (stcb->asoc.cc_functions.sctp_cwnd_update_tsn_acknowledged) {
 		(*stcb->asoc.cc_functions.sctp_cwnd_update_tsn_acknowledged)(tp1->whoTo,
@@ -3966,9 +4275,24 @@ sctp_express_handle_sack(struct sctp_tcb *stcb, uint32_t cumack,
 			/* SWS sender side engages */
 			asoc->peers_rwnd = 0;
 		}
-		if (asoc->peers_rwnd > old_rwnd) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[146]) {
+		  if ((asoc -> peers_rwnd > old_rwnd ) && !(0))
+		    fprintf(stderr, "triggered bug index 146\n");
+		  else
+		    fprintf(stderr, "reached bug index 146\n");
+		}
+		if ((!FIXREVERTER[146] && (asoc -> peers_rwnd > old_rwnd ))
+		#else
+		if (0
+		#endif
+		) {
 			goto again;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		return;
 	}
 
@@ -4202,7 +4526,22 @@ sctp_express_handle_sack(struct sctp_tcb *stcb, uint32_t cumack,
 	}
 
 	/* JRS - Use the congestion control given in the CC module */
-	if ((asoc->last_acked_seq != cumack) && (ecne_seen == 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[148]) {
+	  fprintf(stderr, "reached bug index 148\n");
+	}
+	if ((FIXREVERTER[148] && (ecne_seen == 0 )) || (!FIXREVERTER[148] && (asoc -> last_acked_seq != cumack && ecne_seen == 0 ))
+	#else
+	if (ecne_seen == 0 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(asoc -> last_acked_seq != cumack ))
+	    fprintf(stderr, "triggered bug index 148\n");
+	  #endif
+	
 		TAILQ_FOREACH(net, &asoc->nets, sctp_next) {
 			if (net->net_ack2 > 0) {
 				/*
@@ -4245,6 +4584,9 @@ sctp_express_handle_sack(struct sctp_tcb *stcb, uint32_t cumack,
 		}
 		asoc->cc_functions.sctp_cwnd_update_after_sack(stcb, asoc, 1, 0, 0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc->last_acked_seq = cumack;
 
 	if (TAILQ_EMPTY(&asoc->sent_queue)) {
@@ -4528,9 +4870,24 @@ sctp_handle_sack(struct mbuf *m, int offset_seg, int offset_dup,
 		for (i = 0; i < num_dup; i++) {
 			dupdata = (uint32_t *)sctp_m_getptr(m, offset_dup + i * sizeof(uint32_t),
 			                                    sizeof(uint32_t), (uint8_t *)&dblock);
-			if (dupdata == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[149]) {
+			  if ((dupdata == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 149\n");
+			  else
+			    fprintf(stderr, "reached bug index 149\n");
+			}
+			if ((!FIXREVERTER[149] && (dupdata == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			sctp_log_fr(*dupdata, 0, 0, SCTP_FR_DUPED);
 		}
 	}
@@ -5473,10 +5830,25 @@ sctp_flush_reassm_for_str_seq(struct sctp_tcb *stcb,
 	 */
 	strm = &asoc->strmin[stream];
 	control = sctp_find_reasm_entry(strm, mid, ordered, asoc->idata_supported);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[152]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 152\n");
+	  else
+	    fprintf(stderr, "reached bug index 152\n");
+	}
+	if ((!FIXREVERTER[152] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Not found */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (!asoc->idata_supported && !ordered && SCTP_TSN_GT(control->fsn_included, cumtsn)) {
 		return;
 	}
@@ -5684,9 +6056,24 @@ sctp_handle_forward_tsn(struct sctp_tcb *stcb,
 									    sizeof(struct sctp_strseq_mid),
 									    (uint8_t *)&strseqbuf_m);
 				offset += sizeof(struct sctp_strseq_mid);
-				if (stseq_m == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[154]) {
+				  if ((stseq_m == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 154\n");
+				  else
+				    fprintf(stderr, "reached bug index 154\n");
+				}
+				if ((!FIXREVERTER[154] && (stseq_m == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sid = ntohs(stseq_m->sid);
 				mid = ntohl(stseq_m->mid);
 				flags = ntohs(stseq_m->flags);
@@ -5700,9 +6087,24 @@ sctp_handle_forward_tsn(struct sctp_tcb *stcb,
 									    sizeof(struct sctp_strseq),
 									    (uint8_t *)&strseqbuf);
 				offset += sizeof(struct sctp_strseq);
-				if (stseq == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[155]) {
+				  if ((stseq == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 155\n");
+				  else
+				    fprintf(stderr, "reached bug index 155\n");
+				}
+				if ((!FIXREVERTER[155] && (stseq == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				sid = ntohs(stseq->sid);
 				mid = (uint32_t)ntohs(stseq->ssn);
 				ordered = 1;
@@ -5716,18 +6118,50 @@ sctp_handle_forward_tsn(struct sctp_tcb *stcb,
 			 * where its not all delivered. If we find it we transmute the
 			 * read entry into a PDI_ABORTED.
 			 */
-			if (sid >= asoc->streamincnt) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[156]) {
+			  if ((sid >= asoc -> streamincnt ) && !(0))
+			    fprintf(stderr, "triggered bug index 156\n");
+			  else
+			    fprintf(stderr, "reached bug index 156\n");
+			}
+			if ((!FIXREVERTER[156] && (sid >= asoc -> streamincnt ))
+			#else
+			if (0
+			#endif
+			) {
 				/* screwed up streams, stop!  */
 				break;
 			}
-			if ((asoc->str_of_pdapi == sid) &&
-			    (asoc->ssn_of_pdapi == mid)) {
+			#ifdef FRCOV
+			}
+			#endif
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[157]) {
+			  fprintf(stderr, "reached bug index 157\n");
+			}
+			if ((FIXREVERTER[157] && (asoc -> str_of_pdapi == sid )) || (!FIXREVERTER[157] && (asoc -> str_of_pdapi == sid && asoc -> ssn_of_pdapi == mid ))
+			#else
+			if (asoc -> str_of_pdapi == sid 
+			#endif
+			) {
+			      
+			    #ifdef FRCOV
+			      if (!(asoc -> ssn_of_pdapi == mid ))
+			        fprintf(stderr, "triggered bug index 157\n");
+			      #endif
+			    
 				/* If this is the one we were partially delivering
 				 * now then we no longer are. Note this will change
 				 * with the reassembly re-write.
 				 */
 				asoc->fragmented_delivery_inprogress = 0;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			strm = &asoc->strmin[sid];
 			for (cur_mid = strm->last_mid_delivered; SCTP_MID_GE(asoc->idata_supported, mid, cur_mid); cur_mid++) {
 				sctp_flush_reassm_for_str_seq(stcb, asoc, sid, cur_mid, ordered, new_cum_tsn);
diff --git a/usrsctplib/netinet/sctp_input.c b/usrsctplib/netinet/sctp_input.c
index f958dc4..06b3792 100755
--- a/usrsctplib/netinet/sctp_input.c
+++ b/usrsctplib/netinet/sctp_input.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -263,9 +267,24 @@ sctp_is_there_unsent_data(struct sctp_tcb *stcb, int so_locked
 		for (i = 0; i < stcb->asoc.streamoutcnt; i++) {
 			/*sa_ignore FREED_MEMORY*/
 			sp = TAILQ_FIRST(&stcb->asoc.strmout[i].outqueue);
-			if (sp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[180]) {
+			  if ((sp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 180\n");
+			  else
+			    fprintf(stderr, "reached bug index 180\n");
+			}
+			if ((!FIXREVERTER[180] && (sp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if ((sp->msg_is_complete) &&
 			    (sp->length == 0)  &&
 			    (sp->sender_all_done)) {
@@ -430,11 +449,26 @@ sctp_process_init(struct sctp_init_chunk *cp, struct sctp_tcb *stcb)
 	}
 	SCTP_MALLOC(asoc->strmin, struct sctp_stream_in *, asoc->streamincnt *
 		    sizeof(struct sctp_stream_in), SCTP_M_STRMI);
-	if (asoc->strmin == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[182]) {
+	  if ((asoc -> strmin == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 182\n");
+	  else
+	    fprintf(stderr, "reached bug index 182\n");
+	}
+	if ((!FIXREVERTER[182] && (asoc -> strmin == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* we didn't get memory for the streams! */
 		SCTPDBG(SCTP_DEBUG_INPUT2, "process_init: couldn't get memory for the streams!\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	for (i = 0; i < asoc->streamincnt; i++) {
 		asoc->strmin[i].sid = i;
 		asoc->strmin[i].last_mid_delivered = 0xffffffff;
@@ -678,10 +712,25 @@ sctp_handle_heartbeat_ack(struct sctp_heartbeat_chunk *cp,
 		return;
 	}
 	r_net = sctp_findnet(stcb, &store.sa);
-	if (r_net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[184]) {
+	  if ((r_net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 184\n");
+	  else
+	    fprintf(stderr, "reached bug index 184\n");
+	}
+	if ((!FIXREVERTER[184] && (r_net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_INPUT1, "Huh? I can't find the address I sent it to, discard\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((r_net && (r_net->dest_state & SCTP_ADDR_UNCONFIRMED)) &&
 	    (r_net->heartbeat_random1 == cp->heartbeat.hb_info.random_value1) &&
 	    (r_net->heartbeat_random2 == cp->heartbeat.hb_info.random_value2)) {
@@ -857,8 +906,23 @@ sctp_handle_abort(struct sctp_abort_chunk *abort,
 	uint16_t error;
 
 	SCTPDBG(SCTP_DEBUG_INPUT2, "sctp_handle_abort: handling ABORT\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[185]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 185\n");
+	  else
+	    fprintf(stderr, "reached bug index 185\n");
+	}
+	if ((!FIXREVERTER[185] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	len = ntohs(abort->ch.chunk_length);
 	if (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_error_cause)) {
@@ -962,8 +1026,23 @@ sctp_handle_shutdown(struct sctp_shutdown_chunk *cp,
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_shutdown: handling SHUTDOWN\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[186]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 186\n");
+	  else
+	    fprintf(stderr, "reached bug index 186\n");
+	}
+	if ((!FIXREVERTER[186] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	asoc = &stcb->asoc;
 	if ((SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_WAIT) ||
 	    (SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_ECHOED)) {
@@ -1089,8 +1168,23 @@ sctp_handle_shutdown_ack(struct sctp_shutdown_ack_chunk *cp SCTP_UNUSED,
 #endif
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_shutdown_ack: handling SHUTDOWN ACK\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[187]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 187\n");
+	  else
+	    fprintf(stderr, "reached bug index 187\n");
+	}
+	if ((!FIXREVERTER[187] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	asoc = &stcb->asoc;
 	/* process according to association state */
@@ -1260,12 +1354,27 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 		/* Process an Error Cause */
 		cause_code = ntohs(cause->code);
 		cause_length = ntohs(cause->length);
-		if ((cause_length > remaining_length) || (cause_length == 0)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[188]) {
+		  if ((cause_length > remaining_length || cause_length == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 188\n");
+		  else
+		    fprintf(stderr, "reached bug index 188\n");
+		}
+		if ((!FIXREVERTER[188] && (cause_length > remaining_length || cause_length == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Invalid cause length, possibly due to truncation. */
 			SCTPDBG(SCTP_DEBUG_INPUT1, "Bogus length in cause - bytes left: %u cause length: %u\n",
 				remaining_length, cause_length);
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (code == 0) {
 			/* report the first error cause */
 			code = cause_code;
@@ -1310,8 +1419,19 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 					asoc->cookie_preserve_req = UINT32_MAX;
 				}
 				asoc->stale_cookie_count++;
-				if (asoc->stale_cookie_count >
-				    asoc->max_init_times) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[189]) {
+				  if ((asoc -> stale_cookie_count > asoc -> max_init_times ) && !(0))
+				    fprintf(stderr, "triggered bug index 189\n");
+				  else
+				    fprintf(stderr, "reached bug index 189\n");
+				}
+				if ((!FIXREVERTER[189] && (asoc -> stale_cookie_count > asoc -> max_init_times ))
+				#else
+				if (0
+				#endif
+				) {
 					sctp_abort_notification(stcb, 0, 0, NULL, SCTP_SO_NOT_LOCKED);
 					/* now free the asoc */
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
@@ -1329,6 +1449,9 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 #endif
 					return (-1);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				/* blast back to INIT state */
 				sctp_toss_old_cookies(stcb, &stcb->asoc);
 				SCTP_SET_STATE(stcb, SCTP_STATE_COOKIE_WAIT);
@@ -1426,11 +1549,26 @@ sctp_handle_init_ack(struct mbuf *m, int iphlen, int offset,
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_init_ack: handling INIT-ACK\n");
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[190]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 190\n");
+	  else
+	    fprintf(stderr, "reached bug index 190\n");
+	}
+	if ((!FIXREVERTER[190] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_INPUT2,
 			"sctp_handle_init_ack: TCB is null\n");
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (ntohs(cp->ch.chunk_length) < sizeof(struct sctp_init_ack_chunk)) {
 		/* Invalid length */
 		op_err = sctp_generate_cause(SCTP_CAUSE_INVALID_PARAM, "");
@@ -1643,10 +1781,25 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 	init_cp = (struct sctp_init_chunk *)
 		sctp_m_getptr(m, init_offset, sizeof(struct sctp_init_chunk),
 			      (uint8_t *) & init_buf);
-	if (init_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[191]) {
+	  if ((init_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 191\n");
+	  else
+	    fprintf(stderr, "reached bug index 191\n");
+	}
+	if ((!FIXREVERTER[191] && (init_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull a INIT chunk in cookie */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (init_cp->ch.chunk_type != SCTP_INITIATION) {
 		return (NULL);
 	}
@@ -1658,10 +1811,25 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 	initack_cp = (struct sctp_init_ack_chunk *)
 		sctp_m_getptr(m, initack_offset, sizeof(struct sctp_init_ack_chunk),
 			      (uint8_t *) & initack_buf);
-	if (initack_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[192]) {
+	  if ((initack_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 192\n");
+	  else
+	    fprintf(stderr, "reached bug index 192\n");
+	}
+	if ((!FIXREVERTER[192] && (initack_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull INIT-ACK chunk in cookie */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (initack_cp->ch.chunk_type != SCTP_INITIATION_ACK) {
 		return (NULL);
 	}
@@ -2192,12 +2360,27 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 	init_cp = (struct sctp_init_chunk *)
 	    sctp_m_getptr(m, init_offset, sizeof(struct sctp_init_chunk),
 	    (uint8_t *) & init_buf);
-	if (init_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[197]) {
+	  if ((init_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 197\n");
+	  else
+	    fprintf(stderr, "reached bug index 197\n");
+	}
+	if ((!FIXREVERTER[197] && (init_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull a INIT chunk in cookie */
 		SCTPDBG(SCTP_DEBUG_INPUT1,
 			"process_cookie_new: could not pull INIT chunk hdr\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (init_cp->ch.chunk_type != SCTP_INITIATION) {
 		SCTPDBG(SCTP_DEBUG_INPUT1, "HUH? process_cookie_new: could not find INIT chunk!\n");
 		return (NULL);
@@ -2210,11 +2393,26 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 	initack_cp = (struct sctp_init_ack_chunk *)
 	    sctp_m_getptr(m, initack_offset, sizeof(struct sctp_init_ack_chunk),
 	    (uint8_t *) & initack_buf);
-	if (initack_cp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[198]) {
+	  if ((initack_cp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 198\n");
+	  else
+	    fprintf(stderr, "reached bug index 198\n");
+	}
+	if ((!FIXREVERTER[198] && (initack_cp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* could not pull INIT-ACK chunk in cookie */
 		SCTPDBG(SCTP_DEBUG_INPUT1, "process_cookie_new: could not pull INIT-ACK chunk hdr\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (initack_cp->ch.chunk_type != SCTP_INITIATION_ACK) {
 		return (NULL);
 	}
@@ -2600,9 +2798,24 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_cookie: handling COOKIE-ECHO\n");
 
-	if (inp_p == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[201]) {
+	  if ((inp_p == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 201\n");
+	  else
+	    fprintf(stderr, "reached bug index 201\n");
+	}
+	if ((!FIXREVERTER[201] && (inp_p == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	cookie = &cp->cookie;
 	cookie_offset = offset + sizeof(struct sctp_chunkhdr);
 	cookie_len = ntohs(cp->ch.chunk_length);
@@ -2613,9 +2826,19 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 		/* cookie too small */
 		return (NULL);
 	}
-	if ((cookie->peerport != sh->src_port) ||
-	    (cookie->myport != sh->dest_port) ||
-	    (cookie->my_vtag != sh->v_tag)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[202]) {
+	  if ((cookie -> peerport != sh -> src_port || cookie -> myport != sh -> dest_port || cookie -> my_vtag != sh -> v_tag ) && !(0))
+	    fprintf(stderr, "triggered bug index 202\n");
+	  else
+	    fprintf(stderr, "reached bug index 202\n");
+	}
+	if ((!FIXREVERTER[202] && (cookie -> peerport != sh -> src_port || cookie -> myport != sh -> dest_port || cookie -> my_vtag != sh -> v_tag ))
+	#else
+	if (0
+	#endif
+	) {
 		/*
 		 * invalid ports or bad tag.  Note that we always leave the
 		 * v_tag in the header in network order and when we stored
@@ -2625,16 +2848,34 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 		 */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * split off the signature into its own mbuf (since it should not be
 	 * calculated in the sctp_hmac_m() call).
 	 */
 	sig_offset = offset + cookie_len - SCTP_SIGNATURE_SIZE;
 	m_sig = m_split(m, sig_offset, M_NOWAIT);
-	if (m_sig == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[203]) {
+	  if ((m_sig == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 203\n");
+	  else
+	    fprintf(stderr, "reached bug index 203\n");
+	}
+	if ((!FIXREVERTER[203] && (m_sig == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory or ?? */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(m_sig, SCTP_MBUF_SPLIT);
@@ -2669,11 +2910,26 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 	/* get the signature */
 	SCTP_INP_RUNLOCK(l_inp);
 	sig = (uint8_t *) sctp_m_getptr(m_sig, 0, SCTP_SIGNATURE_SIZE, (uint8_t *) & tmp_sig);
-	if (sig == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[204]) {
+	  if ((sig == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 204\n");
+	  else
+	    fprintf(stderr, "reached bug index 204\n");
+	}
+	if ((!FIXREVERTER[204] && (sig == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* couldn't find signature */
 		sctp_m_freem(m_sig);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* compare the received digest with the computed digest */
 	if (timingsafe_bcmp(calc_sig, sig, SCTP_SIGNATURE_SIZE) != 0) {
 		/* try the old cookie? */
@@ -2734,10 +2990,25 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 
 		op_err = sctp_get_mbuf_for_msg(sizeof(struct sctp_error_stale_cookie),
 		                               0, M_NOWAIT, 1, MT_DATA);
-		if (op_err == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[205]) {
+		  if ((op_err == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 205\n");
+		  else
+		    fprintf(stderr, "reached bug index 205\n");
+		}
+		if ((!FIXREVERTER[205] && (op_err == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* FOOBAR */
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* Set the len */
 		SCTP_BUF_LEN(op_err) = sizeof(struct sctp_error_stale_cookie);
 		cause = mtod(op_err, struct sctp_error_stale_cookie *);
@@ -2928,7 +3199,19 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 			struct socket *so, *oso;
 			struct sctp_inpcb *inp;
 
-			if (notification == SCTP_NOTIFY_ASSOC_RESTART) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[206]) {
+			  if ((notification == 10 ) && !(0))
+			    fprintf(stderr, "triggered bug index 206\n");
+			  else
+			    fprintf(stderr, "reached bug index 206\n");
+			}
+			if ((!FIXREVERTER[206] && (notification == 10 ))
+			#else
+			if (0
+			#endif
+			) {
 				/*
 				 * For a restart we will keep the same
 				 * socket, no need to do anything. I THINK!!
@@ -2940,6 +3223,9 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 				}
 				return (m);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			oso = (*inp_p)->sctp_socket;
 #if (defined(__FreeBSD__) && __FreeBSD_version < 700000)
 			/*
@@ -3136,9 +3422,24 @@ sctp_handle_cookie_ack(struct sctp_cookie_ack_chunk *cp SCTP_UNUSED,
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_cookie_ack: handling COOKIE-ACK\n");
-	if ((stcb == NULL) || (net == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[207]) {
+	  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 207\n");
+	  else
+	    fprintf(stderr, "reached bug index 207\n");
+	}
+	if ((!FIXREVERTER[207] && (stcb == (void *) 0 || net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	asoc = &stcb->asoc;
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_THRESHOLD_LOGGING) {
@@ -3296,10 +3597,25 @@ sctp_handle_ecn_echo(struct sctp_ecne_chunk *cp,
 		 * may have it marked on the actual net.
 		 */
 		TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
-			if (tsn == net->last_cwr_tsn) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[208]) {
+			  if ((tsn == net -> last_cwr_tsn ) && !(0))
+			    fprintf(stderr, "triggered bug index 208\n");
+			  else
+			    fprintf(stderr, "reached bug index 208\n");
+			}
+			if ((!FIXREVERTER[208] && (tsn == net -> last_cwr_tsn ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Found him, send it off */
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 		if (net == NULL) {
 			/*
@@ -3308,10 +3624,25 @@ sctp_handle_ecn_echo(struct sctp_ecne_chunk *cp,
 			 * ago and you lost the response.
 			 */
 			net = TAILQ_FIRST(&stcb->asoc.nets);
-			if (net == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[209]) {
+			  if ((net == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 209\n");
+			  else
+			    fprintf(stderr, "reached bug index 209\n");
+			}
+			if ((!FIXREVERTER[209] && (net == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* TSNH */
 				return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			override_bit = SCTP_CWR_REDUCE_OVERRIDE;
 		} else {
 			override_bit = 0;
@@ -3413,8 +3744,23 @@ sctp_handle_shutdown_complete(struct sctp_shutdown_complete_chunk *cp SCTP_UNUSE
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_shutdown_complete: handling SHUTDOWN-COMPLETE\n");
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[211]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 211\n");
+	  else
+	    fprintf(stderr, "reached bug index 211\n");
+	}
+	if ((!FIXREVERTER[211] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* process according to association state */
 	if (SCTP_GET_STATE(stcb) != SCTP_STATE_SHUTDOWN_ACK_SENT) {
@@ -3791,9 +4137,24 @@ sctp_find_stream_reset(struct sctp_tcb *stcb, uint32_t seq, struct sctp_tmit_chu
 		return (NULL);
 	}
 	chk = stcb->asoc.str_reset;
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[212]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 212\n");
+	  else
+	    fprintf(stderr, "reached bug index 212\n");
+	}
+	if ((!FIXREVERTER[212] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (bchk) {
 		/* he wants a copy of the chk pointer */
 		*bchk = chk;
@@ -3825,9 +4186,24 @@ sctp_clean_up_stream_reset(struct sctp_tcb *stcb)
 
 	asoc = &stcb->asoc;
 	chk = asoc->str_reset;
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[213]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 213\n");
+	  else
+	    fprintf(stderr, "reached bug index 213\n");
+	}
+	if ((!FIXREVERTER[213] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc->str_reset = NULL;
 	sctp_timer_stop(SCTP_TIMER_TYPE_STRRESET, stcb->sctp_ep, stcb,
 	                chk->whoTo, SCTP_FROM_SCTP_INPUT + SCTP_LOC_28);
@@ -3948,10 +4324,25 @@ sctp_handle_stream_reset_response(struct sctp_tcb *stcb,
 				struct sctp_stream_reset_response_tsn *resp;
 				struct sctp_forward_tsn_chunk fwdtsn;
 				int abort_flag = 0;
-				if (respin == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[214]) {
+				  if ((respin == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 214\n");
+				  else
+				    fprintf(stderr, "reached bug index 214\n");
+				}
+				if ((!FIXREVERTER[214] && (respin == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* huh ? */
 					return (0);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (ntohs(respin->ph.param_length) < sizeof(struct sctp_stream_reset_response_tsn)) {
 					return (0);
 				}
@@ -4179,12 +4570,27 @@ sctp_handle_str_reset_request_out(struct sctp_tcb *stcb,
 			siz = sizeof(struct sctp_stream_reset_list) + (number_entries * sizeof(uint16_t));
 			SCTP_MALLOC(liste, struct sctp_stream_reset_list *,
 				    siz, SCTP_M_STRESET);
-			if (liste == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[215]) {
+			  if ((liste == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 215\n");
+			  else
+			    fprintf(stderr, "reached bug index 215\n");
+			}
+			if ((!FIXREVERTER[215] && (liste == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* gak out of memory */
 				asoc->last_reset_action[0] = SCTP_STREAM_RESET_RESULT_DENIED;
 				sctp_add_stream_reset_result(chk, seq, asoc->last_reset_action[0]);
 				return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			liste->seq = seq;
 			liste->tsn = tsn;
 			liste->number_entries = number_entries;
@@ -4388,9 +4794,24 @@ sctp_handle_stream_reset(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 
 	/* setup for adding the response */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[217]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 217\n");
+	  else
+	    fprintf(stderr, "reached bug index 217\n");
+	}
+	if ((!FIXREVERTER[217] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (ret_code);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -4424,10 +4845,25 @@ sctp_handle_stream_reset(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 	offset += sizeof(struct sctp_chunkhdr);
 	while (remaining_length >= sizeof(struct sctp_paramhdr)) {
 		ph = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, sizeof(pstore), (uint8_t *)&pstore);
-		if (ph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[218]) {
+		  if ((ph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 218\n");
+		  else
+		    fprintf(stderr, "reached bug index 218\n");
+		}
+		if ((!FIXREVERTER[218] && (ph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* TSNH */
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		param_len = ntohs(ph->param_length);
 		if ((param_len > remaining_length) ||
 		    (param_len < (sizeof(struct sctp_paramhdr) + sizeof(uint32_t)))) {
@@ -4436,10 +4872,25 @@ sctp_handle_stream_reset(struct sctp_tcb *stcb, struct mbuf *m, int offset,
 		}
 		ph = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, min(param_len, sizeof(cstore)),
 							   (uint8_t *)&cstore);
-		if (ph == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[219]) {
+		  if ((ph == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 219\n");
+		  else
+		    fprintf(stderr, "reached bug index 219\n");
+		}
+		if ((!FIXREVERTER[219] && (ph == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* TSNH */
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		ptype = ntohs(ph->param_type);
 		num_param++;
 		if (param_len > sizeof(cstore)) {
@@ -4585,11 +5036,26 @@ sctp_handle_packet_dropped(struct sctp_pktdrop_chunk *cp,
 		}
 		if (trunc_len == 0) {
 			/* we are supposed to have all of it */
-			if (at > chlen) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[222]) {
+			  if ((at > chlen ) && !(0))
+			    fprintf(stderr, "triggered bug index 222\n");
+			  else
+			    fprintf(stderr, "reached bug index 222\n");
+			}
+			if ((!FIXREVERTER[222] && (at > chlen ))
+			#else
+			if (0
+			#endif
+			) {
 				/* corrupt skip it */
 				SCTP_STAT_INCR(sctps_pdrpcrupt);
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		} else {
 			/* is there enough of it left ? */
 			if (desc.chunk_type == SCTP_DATA) {
@@ -4794,11 +5260,26 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 								   sizeof(struct sctp_chunkhdr), chunk_buf);
 		}
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[226]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 226\n");
+		  else
+		    fprintf(stderr, "reached bug index 226\n");
+		}
+		if ((!FIXREVERTER[226] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Help */
 			*offset = length;
 			return (stcb);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (ch->chunk_type == SCTP_COOKIE_ECHO) {
 			goto process_control_chunks;
 		}
@@ -4972,13 +5453,28 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 		                                           contiguous,
 		                                           chunk_buf);
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[227]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 227\n");
+		  else
+		    fprintf(stderr, "reached bug index 227\n");
+		}
+		if ((!FIXREVERTER[227] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			*offset = length;
 			if (stcb != NULL) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		num_chunks++;
 		/* Save off the last place we got a control from */
@@ -5115,11 +5611,26 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s\n",
 				ch->chunk_type == SCTP_SELECTIVE_ACK ? "SCTP_SACK" : "SCTP_NR_SACK");
 			SCTP_STAT_INCR(sctps_recvsacks);
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[228]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 228\n");
+			  else
+			    fprintf(stderr, "reached bug index 228\n");
+			}
+			if ((!FIXREVERTER[228] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_INDATA1, "No stcb when processing %s chunk\n",
 				        (ch->chunk_type == SCTP_SELECTIVE_ACK) ? "SCTP_SACK" : "SCTP_NR_SACK");
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (ch->chunk_type == SCTP_SELECTIVE_ACK) {
 				if (chk_length < sizeof(struct sctp_sack_chunk)) {
 					SCTPDBG(SCTP_DEBUG_INDATA1, "Bad size on SACK chunk, too small\n");
@@ -5607,7 +6118,19 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			break;
 		case SCTP_AUTHENTICATION:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_AUTHENTICATION\n");
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[229]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 229\n");
+			  else
+			    fprintf(stderr, "reached bug index 229\n");
+			}
+			if ((!FIXREVERTER[229] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* save the first AUTH for later processing */
 				if (auth_skipped == 0) {
 					auth_offset = *offset;
@@ -5617,6 +6140,9 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 				/* skip this chunk (temporarily) */
 				goto next_chunk;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->asoc.auth_supported == 0) {
 				goto unknown_chunk;
 			}
@@ -5689,10 +6215,25 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 		}
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 							   sizeof(struct sctp_chunkhdr), chunk_buf);
-		if (ch == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[231]) {
+		  if ((ch == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 231\n");
+		  else
+		    fprintf(stderr, "reached bug index 231\n");
+		}
+		if ((!FIXREVERTER[231] && (ch == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			*offset = length;
 			return (stcb);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}			/* while */
 
 	if ((asconf_cnt > 0) && (stcb != NULL)) {
@@ -5782,10 +6323,25 @@ sctp_common_input_processing(struct mbuf **mm, int iphlen, int offset, int lengt
 		}
 	}
 	/* Destination port of 0 is illegal, based on RFC4960. */
-	if (sh->dest_port == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[233]) {
+	  if ((sh -> dest_port == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 233\n");
+	  else
+	    fprintf(stderr, "reached bug index 233\n");
+	}
+	if ((!FIXREVERTER[233] && (sh -> dest_port == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_STAT_INCR(sctps_hdrops);
 		goto out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	stcb = sctp_findassociation_addr(m, offset, src, dst,
 	                                 sh, ch, &inp, &net, vrf_id);
 #if defined(INET) || defined(INET6)
@@ -5978,7 +6534,19 @@ sctp_common_input_processing(struct mbuf **mm, int iphlen, int offset, int lengt
 #if defined(__FreeBSD__)
 	SCTP_PROBE5(receive, NULL, stcb, m, stcb, sh);
 #endif
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[234]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 234\n");
+	  else
+	    fprintf(stderr, "reached bug index 234\n");
+	}
+	if ((!FIXREVERTER[234] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/*
 		 * no valid TCB for this packet, or we found it's a bad
 		 * packet while processing control, or we're done with this
@@ -5986,6 +6554,9 @@ sctp_common_input_processing(struct mbuf **mm, int iphlen, int offset, int lengt
 		 */
 		goto out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__Userspace__)
 	if ((upcall_socket == NULL) &&
 	    !(stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) &&
diff --git a/usrsctplib/netinet/sctp_output.c b/usrsctplib/netinet/sctp_output.c
index 7a12385..9497246 100755
--- a/usrsctplib/netinet/sctp_output.c
+++ b/usrsctplib/netinet/sctp_output.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -2077,20 +2081,50 @@ sctp_add_addresses_to_i_ia(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	vrf_id = inp->def_vrf_id;
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[739]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 739\n");
+	  else
+	    fprintf(stderr, "reached bug index 739\n");
+	}
+	if ((!FIXREVERTER[739] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_IPI_ADDR_RUNLOCK();
 		return (m_at);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		struct sctp_ifa *sctp_ifap;
 		struct sctp_ifn *sctp_ifnp;
 
 		cnt = cnt_inits_to;
-		if (vrf->total_ifa_count > SCTP_COUNT_LIMIT) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[740]) {
+		  if ((vrf -> total_ifa_count > 40 ) && !(0))
+		    fprintf(stderr, "triggered bug index 740\n");
+		  else
+		    fprintf(stderr, "reached bug index 740\n");
+		}
+		if ((!FIXREVERTER[740] && (vrf -> total_ifa_count > 40 ))
+		#else
+		if (0
+		#endif
+		) {
 			limit_out = 1;
 			cnt = SCTP_ADDRESS_LIMIT;
 			goto skip_count;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		LIST_FOREACH(sctp_ifnp, &vrf->ifnlist, next_ifn) {
 			if ((scope->loopback_scope == 0) &&
 			    SCTP_IFN_IS_IFT_LOOP(sctp_ifnp)) {
@@ -2209,20 +2243,50 @@ sctp_add_addresses_to_i_ia(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		cnt = cnt_inits_to;
 		/* First, how many ? */
 		LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-			if (laddr->ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[745]) {
+			  if ((laddr -> ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 745\n");
+			  else
+			    fprintf(stderr, "reached bug index 745\n");
+			}
+			if ((!FIXREVERTER[745] && (laddr -> ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED)
 				/* Address being deleted by the system, dont
 				 * list.
 				 */
 				continue;
-			if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[746]) {
+			  if ((laddr -> action == 49154 ) && !(0))
+			    fprintf(stderr, "triggered bug index 746\n");
+			  else
+			    fprintf(stderr, "reached bug index 746\n");
+			}
+			if ((!FIXREVERTER[746] && (laddr -> action == 49154 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Address being deleted on this ep
 				 * don't list.
 				 */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 #if defined(__Userspace__)
 			if (laddr->ifa->address.sa.sa_family == AF_CONN) {
 				continue;
@@ -2242,9 +2306,24 @@ sctp_add_addresses_to_i_ia(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		if (cnt > 1) {
 			cnt = cnt_inits_to;
 			LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-				if (laddr->ifa == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[747]) {
+				  if ((laddr -> ifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 747\n");
+				  else
+				    fprintf(stderr, "reached bug index 747\n");
+				}
+				if ((!FIXREVERTER[747] && (laddr -> ifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
 					continue;
 				}
@@ -2466,16 +2545,46 @@ sctp_is_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)
 {
 	struct sctp_laddr *laddr;
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[749]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 749\n");
+	  else
+	    fprintf(stderr, "reached bug index 749\n");
+	}
+	if ((!FIXREVERTER[749] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* There are no restrictions, no TCB :-) */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(laddr, &stcb->asoc.sctp_restricted_addrs, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[750]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 750\n");
+		  else
+		    fprintf(stderr, "reached bug index 750\n");
+		}
+		if ((!FIXREVERTER[750] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 				__func__);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (laddr->ifa == ifa) {
 			/* Yes it is on the list */
 			return (1);
@@ -2490,14 +2599,44 @@ sctp_is_addr_in_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa)
 {
 	struct sctp_laddr *laddr;
 
-	if (ifa == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[751]) {
+	  if ((ifa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 751\n");
+	  else
+	    fprintf(stderr, "reached bug index 751\n");
+	}
+	if ((!FIXREVERTER[751] && (ifa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 	LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[752]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 752\n");
+		  else
+		    fprintf(stderr, "reached bug index 752\n");
+		}
+		if ((!FIXREVERTER[752] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 				__func__);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((laddr->ifa == ifa) && laddr->action == 0)
 			/* same pointer */
 			return (1);
@@ -2525,8 +2664,23 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 	uint32_t ifn_index;
 
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[753]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 753\n");
+	  else
+	    fprintf(stderr, "reached bug index 753\n");
+	}
+	if ((!FIXREVERTER[753] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	ifn = SCTP_GET_IFN_VOID_FROM_ROUTE(ro);
 	ifn_index = SCTP_GET_IF_INDEX_FROM_ROUTE(ro);
@@ -2561,8 +2715,23 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 			sifa = sctp_is_ifa_addr_preferred(sctp_ifa,
 							  dest_is_loop,
 							  dest_is_priv, fam);
-			if (sifa == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[754]) {
+			  if ((sifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 754\n");
+			  else
+			    fprintf(stderr, "reached bug index 754\n");
+			}
+			if ((!FIXREVERTER[754] && (sifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				continue;
+				#ifdef FRCOV
+				}
+				#endif
 			if (sctp_is_addr_in_ep(inp, sifa)) {
 				atomic_add_int(&sifa->refcount, 1);
 				return (sifa);
@@ -2583,18 +2752,63 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 	}
 	for (laddr = inp->next_addr_touse; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[755]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 755\n");
+		  else
+		    fprintf(stderr, "reached bug index 755\n");
+		}
+		if ((!FIXREVERTER[755] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[756]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 756\n");
+		  else
+		    fprintf(stderr, "reached bug index 756\n");
+		}
+		if ((!FIXREVERTER[756] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_preferred(laddr->ifa, dest_is_loop,
 						  dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[757]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 757\n");
+		  else
+		    fprintf(stderr, "reached bug index 757\n");
+		}
+		if ((!FIXREVERTER[757] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		atomic_add_int(&sifa->refcount, 1);
 		return (sifa);
 	}
@@ -2614,18 +2828,63 @@ sctp_choose_boundspecific_inp(struct sctp_inpcb *inp,
 	/* ok, what about an acceptable address in the inp */
 	for (laddr = inp->next_addr_touse; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[759]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 759\n");
+		  else
+		    fprintf(stderr, "reached bug index 759\n");
+		}
+		if ((!FIXREVERTER[759] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[760]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 760\n");
+		  else
+		    fprintf(stderr, "reached bug index 760\n");
+		}
+		if ((!FIXREVERTER[760] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_acceptable(laddr->ifa, dest_is_loop,
 						   dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[761]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 761\n");
+		  else
+		    fprintf(stderr, "reached bug index 761\n");
+		}
+		if ((!FIXREVERTER[761] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		atomic_add_int(&sifa->refcount, 1);
 		return (sifa);
 	}
@@ -2666,8 +2925,23 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 	 * want that one.
 	 */
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[763]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 763\n");
+	  else
+	    fprintf(stderr, "reached bug index 763\n");
+	}
+	if ((!FIXREVERTER[763] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	ifn = SCTP_GET_IFN_VOID_FROM_ROUTE(ro);
 	ifn_index = SCTP_GET_IF_INDEX_FROM_ROUTE(ro);
@@ -2701,8 +2975,23 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 				continue;
 			if (sctp_is_addr_in_ep(inp, sctp_ifa)) {
 				sifa = sctp_is_ifa_addr_preferred(sctp_ifa, dest_is_loop, dest_is_priv, fam);
-				if (sifa == NULL)
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[764]) {
+				  if ((sifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 764\n");
+				  else
+				    fprintf(stderr, "reached bug index 764\n");
+				}
+				if ((!FIXREVERTER[764] && (sifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				)
 					continue;
+					#ifdef FRCOV
+					}
+					#endif
 				if (((non_asoc_addr_ok == 0) &&
 				     (sctp_is_addr_restricted(stcb, sifa))) ||
 				    (non_asoc_addr_ok &&
@@ -2737,8 +3026,23 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 				continue;
 			if (sctp_is_addr_in_ep(inp, sctp_ifa)) {
 				sifa= sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop, dest_is_priv,fam);
-				if (sifa == NULL)
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[765]) {
+				  if ((sifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 765\n");
+				  else
+				    fprintf(stderr, "reached bug index 765\n");
+				}
+				if ((!FIXREVERTER[765] && (sifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				)
 					continue;
+					#ifdef FRCOV
+					}
+					#endif
 				if (((non_asoc_addr_ok == 0) &&
 				     (sctp_is_addr_restricted(stcb, sifa))) ||
 				    (non_asoc_addr_ok &&
@@ -2767,17 +3071,62 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 	/* search beginning with the last used address */
 	for (laddr = stcb->asoc.last_used_address; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[766]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 766\n");
+		  else
+		    fprintf(stderr, "reached bug index 766\n");
+		}
+		if ((!FIXREVERTER[766] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[767]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 767\n");
+		  else
+		    fprintf(stderr, "reached bug index 767\n");
+		}
+		if ((!FIXREVERTER[767] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_preferred(laddr->ifa, dest_is_loop, dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[768]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 768\n");
+		  else
+		    fprintf(stderr, "reached bug index 768\n");
+		}
+		if ((!FIXREVERTER[768] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (((non_asoc_addr_ok == 0) &&
 		     (sctp_is_addr_restricted(stcb, sifa))) ||
 		    (non_asoc_addr_ok &&
@@ -2805,18 +3154,63 @@ sctp_choose_boundspecific_stcb(struct sctp_inpcb *inp,
 	/* search beginning with the last used address */
 	for (laddr = stcb->asoc.last_used_address; laddr;
 	     laddr = LIST_NEXT(laddr, sctp_nxt_addr)) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[769]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 769\n");
+		  else
+		    fprintf(stderr, "reached bug index 769\n");
+		}
+		if ((!FIXREVERTER[769] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address has been removed */
 			continue;
 		}
-		if (laddr->action == SCTP_DEL_IP_ADDRESS) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[770]) {
+		  if ((laddr -> action == 49154 ) && !(0))
+		    fprintf(stderr, "triggered bug index 770\n");
+		  else
+		    fprintf(stderr, "reached bug index 770\n");
+		}
+		if ((!FIXREVERTER[770] && (laddr -> action == 49154 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* address is being deleted */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sifa = sctp_is_ifa_addr_acceptable(laddr->ifa, dest_is_loop,
 						   dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[771]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 771\n");
+		  else
+		    fprintf(stderr, "reached bug index 771\n");
+		}
+		if ((!FIXREVERTER[771] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (((non_asoc_addr_ok == 0) &&
 		     (sctp_is_addr_restricted(stcb, sifa))) ||
 		    (non_asoc_addr_ok &&
@@ -2890,8 +3284,23 @@ sctp_select_nth_preferred_addr_from_ifn_boundall(struct sctp_ifn *ifn,
 			continue;
 		sifa = sctp_is_ifa_addr_preferred(ifa, dest_is_loop,
 						  dest_is_priv, fam);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[772]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 772\n");
+		  else
+		    fprintf(stderr, "reached bug index 772\n");
+		}
+		if ((!FIXREVERTER[772] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 #ifdef INET6
 		if (fam == AF_INET6 &&
 		    dest_is_loop &&
@@ -3010,9 +3419,24 @@ sctp_count_num_preferred_boundall(struct sctp_ifn *ifn,
 		}
 		sifa = sctp_is_ifa_addr_preferred(ifa, dest_is_loop,
 						  dest_is_priv, fam);
-		if (sifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[774]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 774\n");
+		  else
+		    fprintf(stderr, "reached bug index 774\n");
+		}
+		if ((!FIXREVERTER[774] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb) {
 			if (sctp_is_address_in_scope(ifa, &stcb->asoc.scope, 0) == 0) {
 				continue;
@@ -3070,18 +3494,48 @@ sctp_choose_boundall(struct sctp_inpcb *inp,
 	 * abort :-<.
 	 */
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[775]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 775\n");
+	  else
+	    fprintf(stderr, "reached bug index 775\n");
+	}
+	if ((!FIXREVERTER[775] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	ifn = SCTP_GET_IFN_VOID_FROM_ROUTE(ro);
 	ifn_index = SCTP_GET_IF_INDEX_FROM_ROUTE(ro);
 	SCTPDBG(SCTP_DEBUG_OUTPUT2,"ifn from route:%p ifn_index:%d\n", ifn, ifn_index);
 	emit_ifn = looked_at = sctp_ifn = sctp_find_ifn(ifn, ifn_index);
-	if (sctp_ifn == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[776]) {
+	  if ((sctp_ifn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 776\n");
+	  else
+	    fprintf(stderr, "reached bug index 776\n");
+	}
+	if ((!FIXREVERTER[776] && (sctp_ifn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* ?? We don't have this guy ?? */
 		SCTPDBG(SCTP_DEBUG_OUTPUT2,"No ifn emit interface?\n");
 		goto bound_all_plan_b;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTPDBG(SCTP_DEBUG_OUTPUT2,"ifn_index:%d name:%s is emit interface\n",
 		ifn_index, sctp_ifn->ifn_name);
 
@@ -3171,8 +3625,23 @@ sctp_choose_boundall(struct sctp_inpcb *inp,
 		}
 		sifa = sctp_select_nth_preferred_addr_from_ifn_boundall(sctp_ifn, inp, stcb, non_asoc_addr_ok, dest_is_loop,
                                                                         dest_is_priv, cur_addr_num, fam, ro);
-		if (sifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[779]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 779\n");
+		  else
+		    fprintf(stderr, "reached bug index 779\n");
+		}
+		if ((!FIXREVERTER[779] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (net) {
 			net->indx_of_eligible_next_to_use = cur_addr_num + 1;
 			SCTPDBG(SCTP_DEBUG_OUTPUT2, "we selected %d\n",
@@ -3191,10 +3660,25 @@ again_with_private_addresses_allowed:
 	/* plan_c: do we have an acceptable address on the emit interface */
 	sifa = NULL;
 	SCTPDBG(SCTP_DEBUG_OUTPUT2,"Trying Plan C: find acceptable on interface\n");
-	if (emit_ifn == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[780]) {
+	  if ((emit_ifn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 780\n");
+	  else
+	    fprintf(stderr, "reached bug index 780\n");
+	}
+	if ((!FIXREVERTER[780] && (emit_ifn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT2,"Jump to Plan D - no emit_ifn\n");
 		goto plan_d;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(sctp_ifa, &emit_ifn->ifalist, next_ifa) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT2, "ifa:%p\n", (void *)sctp_ifa);
 #if defined(__FreeBSD__)
@@ -3222,10 +3706,25 @@ again_with_private_addresses_allowed:
 		}
 		sifa = sctp_is_ifa_addr_acceptable(sctp_ifa, dest_is_loop,
 						   dest_is_priv, fam);
-		if (sifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[781]) {
+		  if ((sifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 781\n");
+		  else
+		    fprintf(stderr, "reached bug index 781\n");
+		}
+		if ((!FIXREVERTER[781] && (sifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_OUTPUT2, "IFA not acceptable\n");
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb) {
 			if (sctp_is_address_in_scope(sifa, &stcb->asoc.scope, 0) == 0) {
 				SCTPDBG(SCTP_DEBUG_OUTPUT2, "NOT in scope\n");
@@ -3285,8 +3784,23 @@ again_with_private_addresses_allowed:
 			sifa = sctp_is_ifa_addr_acceptable(sctp_ifa,
 							   dest_is_loop,
 							   dest_is_priv, fam);
-			if (sifa == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[782]) {
+			  if ((sifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 782\n");
+			  else
+			    fprintf(stderr, "reached bug index 782\n");
+			}
+			if ((!FIXREVERTER[782] && (sifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				continue;
+				#ifdef FRCOV
+				}
+				#endif
 			if (stcb) {
 				if (sctp_is_address_in_scope(sifa, &stcb->asoc.scope, 0) == 0) {
 					sifa = NULL;
@@ -3353,9 +3867,24 @@ out:
 					tmp_sifa = sctp_is_ifa_addr_acceptable(sctp_ifa,
 					                                       dest_is_loop,
 					                                       dest_is_priv, fam);
-					if (tmp_sifa == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[783]) {
+					  if ((tmp_sifa == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 783\n");
+					  else
+					    fprintf(stderr, "reached bug index 783\n");
+					}
+					if ((!FIXREVERTER[783] && (tmp_sifa == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						continue;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if (tmp_sifa == sifa) {
 						continue;
 					}
@@ -3478,9 +4007,24 @@ sctp_source_address_selection(struct sctp_inpcb *inp,
 		 */
 		SCTP_RTALLOC(ro, vrf_id, inp->fibnum);
 	}
-	if (ro->ro_rt == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[784]) {
+	  if ((ro -> ro_rt == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 784\n");
+	  else
+	    fprintf(stderr, "reached bug index 784\n");
+	}
+	if ((!FIXREVERTER[784] && (ro -> ro_rt == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__Userspace_os_Windows)
 	/* On Windows the sa_family is U_SHORT or ADDRESS_FAMILY */
 	fam = (sa_family_t)ro->ro_dst.sa_family;
@@ -3953,14 +4497,44 @@ sctp_add_cookie(struct mbuf *init, int init_offset,
 	mret = sctp_get_mbuf_for_msg((sizeof(struct sctp_state_cookie) +
 				      sizeof(struct sctp_paramhdr)), 0,
 				     M_NOWAIT, 1, MT_DATA);
-	if (mret == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[786]) {
+	  if ((mret == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 786\n");
+	  else
+	    fprintf(stderr, "reached bug index 786\n");
+	}
+	if ((!FIXREVERTER[786] && (mret == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	copy_init = SCTP_M_COPYM(init, init_offset, M_COPYALL, M_NOWAIT);
-	if (copy_init == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[787]) {
+	  if ((copy_init == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 787\n");
+	  else
+	    fprintf(stderr, "reached bug index 787\n");
+	}
+	if ((!FIXREVERTER[787] && (copy_init == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(mret);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(copy_init, SCTP_MBUF_ICOPY);
@@ -3968,11 +4542,26 @@ sctp_add_cookie(struct mbuf *init, int init_offset,
 #endif
 	copy_initack = SCTP_M_COPYM(initack, initack_offset, M_COPYALL,
 	    M_NOWAIT);
-	if (copy_initack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[788]) {
+	  if ((copy_initack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 788\n");
+	  else
+	    fprintf(stderr, "reached bug index 788\n");
+	}
+	if ((!FIXREVERTER[788] && (copy_initack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(mret);
 		sctp_m_freem(copy_init);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(copy_initack, SCTP_MBUF_ICOPY);
@@ -4012,11 +4601,26 @@ sctp_add_cookie(struct mbuf *init, int init_offset,
 		}
 	}
 	sig = sctp_get_mbuf_for_msg(SCTP_SECRET_SIZE, 0, M_NOWAIT, 1, MT_DATA);
-	if (sig == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[789]) {
+	  if ((sig == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 789\n");
+	  else
+	    fprintf(stderr, "reached bug index 789\n");
+	}
+	if ((!FIXREVERTER[789] && (sig == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no space, so free the entire chain */
 		sctp_m_freem(mret);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(sig) = 0;
 	SCTP_BUF_NEXT(m_at) = sig;
 	sig_offset = 0;
@@ -4195,11 +4799,26 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 			len += sizeof(struct udphdr);
 		}
 		newm = sctp_get_mbuf_for_msg(len, 1, M_NOWAIT, 1, MT_DATA);
-		if (newm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[790]) {
+		  if ((newm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 790\n");
+		  else
+		    fprintf(stderr, "reached bug index 790\n");
+		}
+		if ((!FIXREVERTER[790] && (newm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_m_freem(m);
 			SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_ALIGN_TO_END(newm, len);
 		SCTP_BUF_LEN(newm) = len;
 		SCTP_BUF_NEXT(newm) = m;
@@ -4558,11 +5177,26 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 			len += sizeof(struct udphdr);
 		}
 		newm = sctp_get_mbuf_for_msg(len, 1, M_NOWAIT, 1, MT_DATA);
-		if (newm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[791]) {
+		  if ((newm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 791\n");
+		  else
+		    fprintf(stderr, "reached bug index 791\n");
+		}
+		if ((!FIXREVERTER[791] && (newm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_m_freem(m);
 			SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_ALIGN_TO_END(newm, len);
 		SCTP_BUF_LEN(newm) = len;
 		SCTP_BUF_NEXT(newm) = m;
@@ -5007,11 +5641,26 @@ sctp_lowlevel_chunk_output(struct sctp_inpcb *inp,
 		sconn = (struct sockaddr_conn *)to;
 		len = sizeof(struct sctphdr);
 		newm = sctp_get_mbuf_for_msg(len, 1, M_NOWAIT, 1, MT_DATA);
-		if (newm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[792]) {
+		  if ((newm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 792\n");
+		  else
+		    fprintf(stderr, "reached bug index 792\n");
+		}
+		if ((!FIXREVERTER[792] && (newm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			sctp_m_freem(m);
 			SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_ALIGN_TO_END(newm, len);
 		SCTP_BUF_LEN(newm) = len;
 		SCTP_BUF_NEXT(newm) = m;
@@ -5086,10 +5735,25 @@ sctp_send_initiate(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int so_locked
 	net = stcb->asoc.primary_destination;
 	if (net == NULL) {
 		net = TAILQ_FIRST(&stcb->asoc.nets);
-		if (net == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[793]) {
+		  if ((net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 793\n");
+		  else
+		    fprintf(stderr, "reached bug index 793\n");
+		}
+		if ((!FIXREVERTER[793] && (net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* TSNH */
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* we confirm any address we send an INIT to */
 		net->dest_state &= ~SCTP_ADDR_UNCONFIRMED;
 		(void)sctp_set_primary_addr(stcb, NULL, net);
@@ -5117,11 +5781,26 @@ sctp_send_initiate(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int so_locked
 	sctp_timer_start(SCTP_TIMER_TYPE_INIT, inp, stcb, net);
 
 	m = sctp_get_mbuf_for_msg(MCLBYTES, 1, M_NOWAIT, 1, MT_DATA);
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[794]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 794\n");
+	  else
+	    fprintf(stderr, "reached bug index 794\n");
+	}
+	if ((!FIXREVERTER[794] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory, INIT timer will re-attempt. */
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Sending INIT - mbuf?\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chunk_len = (uint16_t)sizeof(struct sctp_init_chunk);
 	padding_len = 0;
 	/* Now lets put the chunk header in place */
@@ -5436,10 +6115,25 @@ sctp_arethere_unrecognized_parameters(struct mbuf *in_initpkt,
 			at += padded_size;
 			break;
 		case SCTP_SUPPORTED_ADDRTYPE:
-			if (padded_size > SCTP_MAX_ADDR_PARAMS_SIZE) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[795]) {
+			  if ((padded_size > 12 ) && !(0))
+			    fprintf(stderr, "triggered bug index 795\n");
+			  else
+			    fprintf(stderr, "reached bug index 795\n");
+			}
+			if ((!FIXREVERTER[795] && (padded_size > 12 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_OUTPUT1, "Invalid size - error supaddrtype %d\n", plen);
 				goto invalid_size;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			at += padded_size;
 			break;
 		case SCTP_RANDOM:
@@ -5826,9 +6520,24 @@ sctp_are_there_new_addresses(struct sctp_association *asoc,
 			}
 			phdr = sctp_get_next_param(in_initpkt, offset,
 			    (struct sctp_paramhdr *)&p4_buf, sizeof(p4_buf));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[796]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 796\n");
+			  else
+			    fprintf(stderr, "reached bug index 796\n");
+			}
+			if ((!FIXREVERTER[796] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (asoc->scope.ipv4_addr_legal) {
 				p4 = (struct sctp_ipv4addr_param *)phdr;
 				sin4.sin_addr.s_addr = p4->addr;
@@ -5847,9 +6556,24 @@ sctp_are_there_new_addresses(struct sctp_association *asoc,
 			}
 			phdr = sctp_get_next_param(in_initpkt, offset,
 			    (struct sctp_paramhdr *)&p6_buf, sizeof(p6_buf));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[797]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 797\n");
+			  else
+			    fprintf(stderr, "reached bug index 797\n");
+			}
+			if ((!FIXREVERTER[797] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (1);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (asoc->scope.ipv6_addr_legal) {
 				p6 = (struct sctp_ipv6addr_param *)phdr;
 				memcpy((caddr_t)&sin6.sin6_addr, p6->addr,
@@ -5868,9 +6592,24 @@ sctp_are_there_new_addresses(struct sctp_association *asoc,
 			fnd = 0;
 			TAILQ_FOREACH(net, &asoc->nets, sctp_next) {
 				sa = (struct sockaddr *)&net->ro._l_addr;
-				if (sa->sa_family != sa_touse->sa_family) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[798]) {
+				  if ((sa -> sa_family != sa_touse -> sa_family ) && !(0))
+				    fprintf(stderr, "triggered bug index 798\n");
+				  else
+				    fprintf(stderr, "reached bug index 798\n");
+				}
+				if ((!FIXREVERTER[798] && (sa -> sa_family != sa_touse -> sa_family ))
+				#else
+				if (0
+				#endif
+				) {
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 #ifdef INET
 				if (sa->sa_family == AF_INET) {
 					sa4 = (struct sockaddr_in *)sa;
@@ -6023,11 +6762,26 @@ sctp_send_initiate_ack(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		return;
 	}
 	m = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[800]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 800\n");
+	  else
+	    fprintf(stderr, "reached bug index 800\n");
+	}
+	if ((!FIXREVERTER[800] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory, INIT timer will re-attempt. */
 		sctp_m_freem(op_err);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chunk_len = (uint16_t)sizeof(struct sctp_init_ack_chunk);
 	padding_len = 0;
 
@@ -6585,21 +7339,51 @@ sctp_send_initiate_ack(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	}
 	if (padding_len > 0) {
 		m_last = sctp_add_pad_tombuf(m_last, padding_len);
-		if (m_last == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[801]) {
+		  if ((m_last == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 801\n");
+		  else
+		    fprintf(stderr, "reached bug index 801\n");
+		}
+		if ((!FIXREVERTER[801] && (m_last == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Houston we have a problem, no space */
 			sctp_m_freem(m);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chunk_len += padding_len;
 		padding_len = 0;
 	}
 	/* Now we must build a cookie */
 	m_cookie = sctp_add_cookie(init_pkt, offset, m, 0, &stc, &signature);
-	if (m_cookie == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[802]) {
+	  if ((m_cookie == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 802\n");
+	  else
+	    fprintf(stderr, "reached bug index 802\n");
+	}
+	if ((!FIXREVERTER[802] && (m_cookie == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* memory problem */
 		sctp_m_freem(m);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now append the cookie to the end and update the space/size */
 	SCTP_BUF_NEXT(m_last) = m_cookie;
 	parameter_len = 0;
@@ -6888,11 +7672,26 @@ sctp_msg_append(struct sctp_tcb *stcb,
 		goto out_now;
 	}
 	sctp_alloc_a_strmoq(stcb, sp);
-	if (sp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[805]) {
+	  if ((sp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 805\n");
+	  else
+	    fprintf(stderr, "reached bug index 805\n");
+	}
+	if ((!FIXREVERTER[805] && (sp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		error = ENOMEM;
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sp->sinfo_flags = srcv->sinfo_flags;
 	sp->timetolive = srcv->sinfo_timetolive;
 	sp->ppid = srcv->sinfo_ppid;
@@ -6963,13 +7762,28 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 	caddr_t cp;
 	int len;
 
-	if (endofchain == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[806]) {
+	  if ((endofchain == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 806\n");
+	  else
+	    fprintf(stderr, "reached bug index 806\n");
+	}
+	if ((!FIXREVERTER[806] && (endofchain == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* error */
 	error_out:
 		if (outchain)
 			sctp_m_freem(outchain);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (can_take_mbuf) {
 		appendchain = clonechain;
 	} else {
@@ -6987,9 +7801,24 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 					/* This is the general case */
 				new_mbuf:
 					outchain = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_HEADER);
-					if (outchain == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[807]) {
+					  if ((outchain == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 807\n");
+					  else
+					    fprintf(stderr, "reached bug index 807\n");
+					}
+					if ((!FIXREVERTER[807] && (outchain == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						goto error_out;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					SCTP_BUF_LEN(outchain) = 0;
 					*endofchain = outchain;
 					/* get the prepend space */
@@ -7035,10 +7864,25 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 					sizeofcpy -= len;
 				}
 				m = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_HEADER);
-				if (m == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[808]) {
+				  if ((m == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 808\n");
+				  else
+				    fprintf(stderr, "reached bug index 808\n");
+				}
+				if ((!FIXREVERTER[808] && (m == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* We failed */
 					goto error_out;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_BUF_NEXT((*endofchain)) = m;
 				*endofchain = m;
 				cp = mtod((*endofchain), caddr_t);
@@ -7056,12 +7900,27 @@ sctp_copy_mbufchain(struct mbuf *clonechain,
 #endif
 		}
 	}
-	if (appendchain == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[809]) {
+	  if ((appendchain == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 809\n");
+	  else
+	    fprintf(stderr, "reached bug index 809\n");
+	}
+	if ((!FIXREVERTER[809] && (appendchain == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* error */
 		if (outchain)
 			sctp_m_freem(outchain);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (outchain) {
 		/* tack on to the end */
 		if (*endofchain != NULL) {
@@ -7324,10 +8183,25 @@ sctp_copy_out_all(struct uio *uio, ssize_t len)
 	ssize_t left, willcpy, cancpy, error;
 
 	ret = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_WAITOK, 1, MT_DATA);
-	if (ret == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[813]) {
+	  if ((ret == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 813\n");
+	  else
+	    fprintf(stderr, "reached bug index 813\n");
+	}
+	if ((!FIXREVERTER[813] && (ret == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* TSNH */
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	left = len;
 	SCTP_BUF_LEN(ret) = 0;
 	/* save space for the data chunk header */
@@ -7377,18 +8251,48 @@ sctp_sendall(struct sctp_inpcb *inp, struct uio *uio, struct mbuf *m,
 	if (uio_resid(uio) > SCTP_MAX_SENDALL_LIMIT) {
 #endif
 #else
-	if (uio->uio_resid > SCTP_MAX_SENDALL_LIMIT) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[814]) {
+	  if ((uio -> uio_resid > 1024 ) && !(0))
+	    fprintf(stderr, "triggered bug index 814\n");
+	  else
+	    fprintf(stderr, "reached bug index 814\n");
+	}
+	if ((!FIXREVERTER[814] && (uio -> uio_resid > 1024 ))
+	#else
+	if (0
+	#endif
+	) {
 #endif
 		/* You must be less than the max! */
 		return (EMSGSIZE);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_MALLOC(ca, struct sctp_copy_all *, sizeof(struct sctp_copy_all),
 		    SCTP_M_COPYAL);
-	if (ca == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[815]) {
+	  if ((ca == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 815\n");
+	  else
+	    fprintf(stderr, "reached bug index 815\n");
+	}
+	if ((!FIXREVERTER[815] && (ca == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(m);
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(ca, 0, sizeof(struct sctp_copy_all));
 
 	ca->inp = inp;
@@ -7418,11 +8322,26 @@ sctp_sendall(struct sctp_inpcb *inp, struct uio *uio, struct mbuf *m,
 #if defined(__APPLE__)
 		SCTP_SOCKET_LOCK(SCTP_INP_SO(inp), 0);
 #endif
-		if (ca->m == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[816]) {
+		  if ((ca -> m == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 816\n");
+		  else
+		    fprintf(stderr, "reached bug index 816\n");
+		}
+		if ((!FIXREVERTER[816] && (ca -> m == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_FREE(ca, SCTP_M_COPYAL);
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			return (ENOMEM);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	} else {
 		/* Gather the length of the send */
 		struct mbuf *mat;
@@ -7534,10 +8453,25 @@ sctp_clean_up_datalist(struct sctp_tcb *stcb,
 			/* need to move back */
 		back_up_more:
 			tpp = TAILQ_PREV(tp1, sctpchunk_listhead, sctp_next);
-			if (tpp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[817]) {
+			  if ((tpp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 817\n");
+			  else
+			    fprintf(stderr, "reached bug index 817\n");
+			}
+			if ((!FIXREVERTER[817] && (tpp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				TAILQ_INSERT_BEFORE(tp1, data_list[i], sctp_next);
 				goto all_done;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			tp1 = tpp;
 			if (SCTP_TSN_GT(tp1->rec.data.tsn, data_list[i]->rec.data.tsn)) {
 				goto back_up_more;
@@ -8319,9 +9253,24 @@ sctp_move_chunks_from_net(struct sctp_tcb *stcb, struct sctp_nets *net)
 	struct sctp_stream_queue_pending *sp;
 	unsigned int i;
 
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[822]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 822\n");
+	  else
+	    fprintf(stderr, "reached bug index 822\n");
+	}
+	if ((!FIXREVERTER[822] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	for (i = 0; i < stcb->asoc.streamoutcnt; i++) {
 		TAILQ_FOREACH(sp, &stcb->asoc.strmout[i].outqueue, next) {
@@ -8461,7 +9410,19 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 	if (no_data_chunks == 0) {
 		/* How many non-directed chunks are there? */
 		TAILQ_FOREACH(chk, &asoc->send_queue, sctp_next) {
-			if (chk->whoTo == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[823]) {
+			  if ((chk -> whoTo == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 823\n");
+			  else
+			    fprintf(stderr, "reached bug index 823\n");
+			}
+			if ((!FIXREVERTER[823] && (chk -> whoTo == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* We already have non-directed
 				 * chunks on the queue, no need
 				 * to do a fill-up.
@@ -8469,6 +9430,9 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 				skip_fill_up = 1;
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 
 	}
@@ -8502,7 +9466,19 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 			    (net->flight_size == 0)) {
 				(*stcb->asoc.cc_functions.sctp_cwnd_new_transmission_begins)(stcb, net);
 			}
-			if (net->flight_size >= net->cwnd) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[824]) {
+			  if ((net -> flight_size >= net -> cwnd ) && !(0))
+			    fprintf(stderr, "triggered bug index 824\n");
+			  else
+			    fprintf(stderr, "reached bug index 824\n");
+			}
+			if ((!FIXREVERTER[824] && (net -> flight_size >= net -> cwnd ))
+			#else
+			if (0
+			#endif
+			) {
 				/* skip this network, no room - can't fill */
 				if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_LOGGING_ENABLE) {
 					sctp_log_cwnd(stcb, net, 3,
@@ -8510,6 +9486,9 @@ sctp_med_chunk_output(struct sctp_inpcb *inp,
 				}
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_LOGGING_ENABLE) {
 				sctp_log_cwnd(stcb, net, 4, SCTP_CWND_LOG_FILL_OUTQ_CALLED);
 			}
@@ -8642,9 +9621,24 @@ again_one_more_time:
 					break;
 				}
 			}
-			if (chk->data == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[825]) {
+			  if ((chk -> data == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 825\n");
+			  else
+			    fprintf(stderr, "reached bug index 825\n");
+			}
+			if ((!FIXREVERTER[825] && (chk -> data == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (chk->sent != SCTP_DATAGRAM_UNSENT &&
 			    chk->sent != SCTP_DATAGRAM_RESEND) {
 				break;
@@ -8694,11 +9688,26 @@ again_one_more_time:
 				outchain = sctp_copy_mbufchain(chk->data, outchain, &endoutchain,
 							       (int)chk->rec.chunk_id.can_take_data,
 							       chk->send_size, chk->copy_by_ref);
-				if (outchain == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[826]) {
+				  if ((outchain == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 826\n");
+				  else
+				    fprintf(stderr, "reached bug index 826\n");
+				}
+				if ((!FIXREVERTER[826] && (outchain == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					*reason_code = 8;
 					SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 					return (ENOMEM);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 				/* update our MTU size */
 				if (mtu > (chk->send_size + omtu))
@@ -8862,10 +9871,37 @@ again_one_more_time:
 				}
 			}
 		skip_net_check:
-			if (chk->data == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[828]) {
+			  if ((chk -> data == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 828\n");
+			  else
+			    fprintf(stderr, "reached bug index 828\n");
+			}
+			if ((!FIXREVERTER[828] && (chk -> data == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
-			if (chk->sent != SCTP_DATAGRAM_UNSENT) {
+			#ifdef FRCOV
+			}
+			#endif
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[829]) {
+			  if ((chk -> sent != 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 829\n");
+			  else
+			    fprintf(stderr, "reached bug index 829\n");
+			}
+			if ((!FIXREVERTER[829] && (chk -> sent != 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/*
 				 * It must be unsent. Cookies and ASCONF's
 				 * hang around but there timers will force
@@ -8873,6 +9909,9 @@ again_one_more_time:
 				 */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/*
 			 * if no AUTH is yet included and this chunk
 			 * requires it, make sure to account for it.  We
@@ -8918,11 +9957,26 @@ again_one_more_time:
 				outchain = sctp_copy_mbufchain(chk->data, outchain, &endoutchain,
 							       (int)chk->rec.chunk_id.can_take_data,
 							       chk->send_size, chk->copy_by_ref);
-				if (outchain == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[830]) {
+				  if ((outchain == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 830\n");
+				  else
+				    fprintf(stderr, "reached bug index 830\n");
+				}
+				if ((!FIXREVERTER[830] && (outchain == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					*reason_code = 8;
 					SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 					return (ENOMEM);
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 				/* update our MTU size */
 				if (mtu > (chk->send_size + omtu))
@@ -9102,9 +10156,24 @@ again_one_more_time:
 		    (net->dest_state & SCTP_ADDR_PF)) {
 			goto no_data_fill;
 		}
-		if (net->flight_size >= net->cwnd) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[832]) {
+		  if ((net -> flight_size >= net -> cwnd ) && !(0))
+		    fprintf(stderr, "triggered bug index 832\n");
+		  else
+		    fprintf(stderr, "reached bug index 832\n");
+		}
+		if ((!FIXREVERTER[832] && (net -> flight_size >= net -> cwnd ))
+		#else
+		if (0
+		#endif
+		) {
 			goto no_data_fill;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((asoc->sctp_cmt_on_off > 0) &&
 		    (SCTP_BASE_SYSCTL(sctp_buffer_splitting) & SCTP_RECV_BUFFER_SPLITTING) &&
 		    (net->flight_size > max_rwnd_per_dest)) {
@@ -9178,11 +10247,26 @@ again_one_more_time:
 					*reason_code = 1;
 					break;
 				}
-				if (net->flight_size >= net->cwnd) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[833]) {
+				  if ((net -> flight_size >= net -> cwnd ) && !(0))
+				    fprintf(stderr, "triggered bug index 833\n");
+				  else
+				    fprintf(stderr, "reached bug index 833\n");
+				}
+				if ((!FIXREVERTER[833] && (net -> flight_size >= net -> cwnd ))
+				#else
+				if (0
+				#endif
+				) {
 					/* skip this net, no room for data */
 					*reason_code = 2;
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if ((chk->whoTo != NULL) &&
 				    (chk->whoTo != net)) {
 					/* Don't send the chunk on this net */
@@ -9248,10 +10332,25 @@ again_one_more_time:
 							/* use this data's keyid */
 							auth_keyid = chk->auth_keyid;
 							override_ok = 0;
-						} else if (auth_keyid != chk->auth_keyid) {
+						} else 
+						#ifdef FRCOV
+						{if (FIXREVERTER[834]) {
+						  if ((auth_keyid != chk -> auth_keyid ) && !(0))
+						    fprintf(stderr, "triggered bug index 834\n");
+						  else
+						    fprintf(stderr, "reached bug index 834\n");
+						}
+						if ((!FIXREVERTER[834] && (auth_keyid != chk -> auth_keyid ))
+						#else
+						if (0
+						#endif
+						) {
 							/* different keyid, so done bundling */
 							break;
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					outchain = sctp_copy_mbufchain(chk->data, outchain, &endoutchain, 0,
 								       chk->send_size, chk->copy_by_ref);
@@ -9291,9 +10390,24 @@ again_one_more_time:
 					}
 					chk->window_probe = 0;
 					data_list[bundle_at++] = chk;
-					if (bundle_at >= SCTP_MAX_DATA_BUNDLING) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[835]) {
+					  if ((bundle_at >= 256 ) && !(0))
+					    fprintf(stderr, "triggered bug index 835\n");
+					  else
+					    fprintf(stderr, "reached bug index 835\n");
+					}
+					if ((!FIXREVERTER[835] && (bundle_at >= 256 ))
+					#else
+					if (0
+					#endif
+					) {
 						break;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if (chk->sent == SCTP_DATAGRAM_UNSENT) {
 						if ((chk->rec.data.rcv_flags & SCTP_DATA_UNORDERED) == 0) {
 							SCTP_STAT_INCR_COUNTER64(sctps_outorderchunks);
@@ -9473,9 +10587,24 @@ sctp_queue_op_err(struct sctp_tcb *stcb, struct mbuf *op_err)
 
 	SCTP_TCB_LOCK_ASSERT(stcb);
 	SCTP_BUF_PREPEND(op_err, sizeof(struct sctp_chunkhdr), M_NOWAIT);
-	if (op_err == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[836]) {
+	  if ((op_err == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 836\n");
+	  else
+	    fprintf(stderr, "reached bug index 836\n");
+	}
+	if ((!FIXREVERTER[836] && (op_err == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	last_mbuf = NULL;
 	chunk_length = 0;
 	for (mat = op_err; mat != NULL; mat = SCTP_BUF_NEXT(mat)) {
@@ -9484,10 +10613,25 @@ sctp_queue_op_err(struct sctp_tcb *stcb, struct mbuf *op_err)
 			last_mbuf = mat;
 		}
 	}
-	if (chunk_length > SCTP_MAX_CHUNK_LENGTH) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[837]) {
+	  if ((chunk_length > 65535 ) && !(0))
+	    fprintf(stderr, "triggered bug index 837\n");
+	  else
+	    fprintf(stderr, "reached bug index 837\n");
+	}
+	if ((!FIXREVERTER[837] && (chunk_length > 65535 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(op_err);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	padding_length = chunk_length % 4;
 	if (padding_length != 0) {
 		padding_length = 4 - padding_length;
@@ -9499,11 +10643,26 @@ sctp_queue_op_err(struct sctp_tcb *stcb, struct mbuf *op_err)
 		}
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[838]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 838\n");
+	  else
+	    fprintf(stderr, "reached bug index 838\n");
+	}
+	if ((!FIXREVERTER[838] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(op_err);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_OPERATION_ERROR;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -9545,9 +10704,24 @@ sctp_send_cookie_echo(struct mbuf *m,
 	at = offset + sizeof(struct sctp_init_chunk);
 	for (;;) {
 		phdr = sctp_get_next_param(m, at, &param, sizeof(param));
-		if (phdr == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[839]) {
+		  if ((phdr == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 839\n");
+		  else
+		    fprintf(stderr, "reached bug index 839\n");
+		}
+		if ((!FIXREVERTER[839] && (phdr == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (-3);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		ptype = ntohs(phdr->param_type);
 		plen = ntohs(phdr->param_length);
 		if (plen < sizeof(struct sctp_paramhdr)) {
@@ -9557,14 +10731,44 @@ sctp_send_cookie_echo(struct mbuf *m,
 			int pad;
 
 			/* found the cookie */
-			if (at + plen > limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[840]) {
+			  if ((at + plen > limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 840\n");
+			  else
+			    fprintf(stderr, "reached bug index 840\n");
+			}
+			if ((!FIXREVERTER[840] && (at + plen > limit ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-7);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			cookie = SCTP_M_COPYM(m, at, plen, M_NOWAIT);
-			if (cookie == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[841]) {
+			  if ((cookie == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 841\n");
+			  else
+			    fprintf(stderr, "reached bug index 841\n");
+			}
+			if ((!FIXREVERTER[841] && (cookie == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* No memory */
 				return (-2);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if ((pad = (plen % 4)) > 0) {
 				pad = 4 - pad;
 			}
@@ -9589,11 +10793,26 @@ sctp_send_cookie_echo(struct mbuf *m,
 	hdr->chunk_flags = 0;
 	/* get the chunk stuff now and place it in the FRONT of the queue */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[842]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 842\n");
+	  else
+	    fprintf(stderr, "reached bug index 842\n");
+	}
+	if ((!FIXREVERTER[842] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(cookie);
 		return (-5);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_COOKIE_ECHO;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -9624,15 +10843,45 @@ sctp_send_heartbeat_ack(struct sctp_tcb *stcb,
 	struct sctp_chunkhdr *chdr;
 	struct sctp_tmit_chunk *chk;
 
-	if (net == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[843]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 843\n");
+	  else
+	    fprintf(stderr, "reached bug index 843\n");
+	}
+	if ((!FIXREVERTER[843] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* must have a net pointer */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	outchain = SCTP_M_COPYM(m, offset, chk_length, M_NOWAIT);
-	if (outchain == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[844]) {
+	  if ((outchain == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 844\n");
+	  else
+	    fprintf(stderr, "reached bug index 844\n");
+	}
+	if ((!FIXREVERTER[844] && (outchain == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* gak out of memory */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(outchain, SCTP_MBUF_ICOPY);
@@ -9645,11 +10894,26 @@ sctp_send_heartbeat_ack(struct sctp_tcb *stcb,
 		sctp_pad_lastmbuf(outchain, 4 - (chk_length % 4), NULL);
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[845]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 845\n");
+	  else
+	    fprintf(stderr, "reached bug index 845\n");
+	}
+	if ((!FIXREVERTER[845] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(outchain);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_HEARTBEAT_ACK;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -9676,17 +10940,47 @@ sctp_send_cookie_ack(struct sctp_tcb *stcb)
 	SCTP_TCB_LOCK_ASSERT(stcb);
 
 	cookie_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_chunkhdr), 0, M_NOWAIT, 1, MT_HEADER);
-	if (cookie_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[846]) {
+	  if ((cookie_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 846\n");
+	  else
+	    fprintf(stderr, "reached bug index 846\n");
+	}
+	if ((!FIXREVERTER[846] && (cookie_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(cookie_ack, SCTP_MIN_OVERHEAD);
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[847]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 847\n");
+	  else
+	    fprintf(stderr, "reached bug index 847\n");
+	}
+	if ((!FIXREVERTER[847] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(cookie_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_COOKIE_ACK;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -9722,17 +11016,47 @@ sctp_send_shutdown_ack(struct sctp_tcb *stcb, struct sctp_nets *net)
 	struct sctp_tmit_chunk *chk;
 
 	m_shutdown_ack = sctp_get_mbuf_for_msg(sizeof(struct sctp_shutdown_ack_chunk), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_shutdown_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[848]) {
+	  if ((m_shutdown_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 848\n");
+	  else
+	    fprintf(stderr, "reached bug index 848\n");
+	}
+	if ((!FIXREVERTER[848] && (m_shutdown_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(m_shutdown_ack, SCTP_MIN_OVERHEAD);
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[849]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 849\n");
+	  else
+	    fprintf(stderr, "reached bug index 849\n");
+	}
+	if ((!FIXREVERTER[849] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_shutdown_ack);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_SHUTDOWN_ACK;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -9776,17 +11100,47 @@ sctp_send_shutdown(struct sctp_tcb *stcb, struct sctp_nets *net)
 	}
 	if (chk == NULL) {
 		m_shutdown = sctp_get_mbuf_for_msg(sizeof(struct sctp_shutdown_chunk), 0, M_NOWAIT, 1, MT_HEADER);
-		if (m_shutdown == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[850]) {
+		  if ((m_shutdown == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 850\n");
+		  else
+		    fprintf(stderr, "reached bug index 850\n");
+		}
+		if ((!FIXREVERTER[850] && (m_shutdown == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no mbuf's */
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_BUF_RESV_UF(m_shutdown, SCTP_MIN_OVERHEAD);
 		sctp_alloc_a_chunk(stcb, chk);
-		if (chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[851]) {
+		  if ((chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 851\n");
+		  else
+		    fprintf(stderr, "reached bug index 851\n");
+		}
+		if ((!FIXREVERTER[851] && (chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no memory */
 			sctp_m_freem(m_shutdown);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chk->copy_by_ref = 0;
 		chk->rec.chunk_id.id = SCTP_SHUTDOWN;
 		chk->rec.chunk_id.can_take_data = 1;
@@ -9842,16 +11196,46 @@ sctp_send_asconf(struct sctp_tcb *stcb, struct sctp_nets *net, int addr_locked)
 
 	/* compose an ASCONF chunk, maximum length is PMTU */
 	m_asconf = sctp_compose_asconf(stcb, &len, addr_locked);
-	if (m_asconf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[852]) {
+	  if ((m_asconf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 852\n");
+	  else
+	    fprintf(stderr, "reached bug index 852\n");
+	}
+	if ((!FIXREVERTER[852] && (m_asconf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[853]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 853\n");
+	  else
+	    fprintf(stderr, "reached bug index 853\n");
+	}
+	if ((!FIXREVERTER[853] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_asconf);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_ASCONF;
@@ -9886,9 +11270,24 @@ sctp_send_asconf_ack(struct sctp_tcb *stcb)
 	SCTP_TCB_LOCK_ASSERT(stcb);
 	/* Get the latest ASCONF-ACK */
 	latest_ack = TAILQ_LAST(&stcb->asoc.asconf_ack_sent, sctp_asconf_ackhead);
-	if (latest_ack == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[854]) {
+	  if ((latest_ack == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 854\n");
+	  else
+	    fprintf(stderr, "reached bug index 854\n");
+	}
+	if ((!FIXREVERTER[854] && (latest_ack == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (latest_ack->last_sent_to != NULL &&
 	    latest_ack->last_sent_to == stcb->asoc.last_control_chunk_from) {
 		/* we're doing a retransmission */
@@ -9920,16 +11319,46 @@ sctp_send_asconf_ack(struct sctp_tcb *stcb)
 	latest_ack->last_sent_to = net;
 
 	TAILQ_FOREACH(ack, &stcb->asoc.asconf_ack_sent, next) {
-		if (ack->data == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[855]) {
+		  if ((ack -> data == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 855\n");
+		  else
+		    fprintf(stderr, "reached bug index 855\n");
+		}
+		if ((!FIXREVERTER[855] && (ack -> data == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		/* copy the asconf_ack */
 		m_ack = SCTP_M_COPYM(ack->data, 0, M_COPYALL, M_NOWAIT);
-		if (m_ack == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[856]) {
+		  if ((m_ack == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 856\n");
+		  else
+		    fprintf(stderr, "reached bug index 856\n");
+		}
+		if ((!FIXREVERTER[856] && (m_ack == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* couldn't copy it */
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef SCTP_MBUF_LOGGING
 		if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 			sctp_log_mbc(m_ack, SCTP_MBUF_ICOPY);
@@ -9937,12 +11366,27 @@ sctp_send_asconf_ack(struct sctp_tcb *stcb)
 #endif
 
 		sctp_alloc_a_chunk(stcb, chk);
-		if (chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[857]) {
+		  if ((chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 857\n");
+		  else
+		    fprintf(stderr, "reached bug index 857\n");
+		}
+		if ((!FIXREVERTER[857] && (chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no memory */
 			if (m_ack)
 				sctp_m_freem(m_ack);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		chk->copy_by_ref = 0;
 		chk->rec.chunk_id.id = SCTP_ASCONF_ACK;
 		chk->rec.chunk_id.can_take_data = 1;
@@ -10033,9 +11477,24 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 		if ((chk->rec.chunk_id.id == SCTP_COOKIE_ECHO) ||
 		    (chk->rec.chunk_id.id == SCTP_STREAM_RESET) ||
 		    (chk->rec.chunk_id.id == SCTP_FORWARD_CUM_TSN)) {
-			if (chk->sent != SCTP_DATAGRAM_RESEND) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[858]) {
+			  if ((chk -> sent != 4 ) && !(0))
+			    fprintf(stderr, "triggered bug index 858\n");
+			  else
+			    fprintf(stderr, "reached bug index 858\n");
+			}
+			if ((!FIXREVERTER[858] && (chk -> sent != 4 ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (chk->rec.chunk_id.id == SCTP_STREAM_RESET) {
 				if (chk != asoc->str_reset) {
 					/*
@@ -10131,15 +11590,45 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 #endif
 	data_auth_reqd = sctp_auth_is_required_chunk(SCTP_DATA, stcb->asoc.peer_auth_chunks);
 	TAILQ_FOREACH(chk, &asoc->sent_queue, sctp_next) {
-		if (chk->sent != SCTP_DATAGRAM_RESEND) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[859]) {
+		  if ((chk -> sent != 4 ) && !(0))
+		    fprintf(stderr, "triggered bug index 859\n");
+		  else
+		    fprintf(stderr, "reached bug index 859\n");
+		}
+		if ((!FIXREVERTER[859] && (chk -> sent != 4 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* No, not sent to this net or not ready for rtx */
 			continue;
 		}
-		if (chk->data == NULL) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[860]) {
+		  if ((chk -> data == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 860\n");
+		  else
+		    fprintf(stderr, "reached bug index 860\n");
+		}
+		if ((!FIXREVERTER[860] && (chk -> data == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_PRINTF("TSN:%x chk->snd_count:%d chk->sent:%d can't retran - no data\n",
 			            chk->rec.data.tsn, chk->snd_count, chk->sent);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if ((SCTP_BASE_SYSCTL(sctp_max_retran_chunk)) &&
 		    (chk->snd_count >= SCTP_BASE_SYSCTL(sctp_max_retran_chunk))) {
 			struct mbuf *op_err;
@@ -10199,11 +11688,28 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 	one_chunk_around:
 		if (asoc->peers_rwnd < mtu) {
 			one_chunk = 1;
-			if ((asoc->peers_rwnd == 0) &&
-			    (asoc->total_flight == 0)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[862]) {
+			  fprintf(stderr, "reached bug index 862\n");
+			}
+			if ((FIXREVERTER[862] && (asoc -> peers_rwnd == 0 )) || (!FIXREVERTER[862] && (asoc -> peers_rwnd == 0 && asoc -> total_flight == 0 ))
+			#else
+			if (asoc -> peers_rwnd == 0 
+			#endif
+			) {
+			      
+			    #ifdef FRCOV
+			      if (!(asoc -> total_flight == 0 ))
+			        fprintf(stderr, "triggered bug index 862\n");
+			      #endif
+			    
 				chk->window_probe = 1;
 				chk->whoTo->window_probe = 1;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 #ifdef SCTP_AUDITING_ENABLED
 		sctp_audit_log(0xC3, 2);
@@ -10216,9 +11722,24 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 			 * if no FR in progress skip destination that have
 			 * flight_size > cwnd.
 			 */
-			if (net->flight_size >= net->cwnd) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[863]) {
+			  if ((net -> flight_size >= net -> cwnd ) && !(0))
+			    fprintf(stderr, "triggered bug index 863\n");
+			  else
+			    fprintf(stderr, "reached bug index 863\n");
+			}
+			if ((!FIXREVERTER[863] && (net -> flight_size >= net -> cwnd ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		} else {
 			/*
 			 * Mark the destination net to have FR recovery
@@ -10256,16 +11777,46 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 				} else if (override_ok) {
 					auth_keyid = chk->auth_keyid;
 					override_ok = 0;
-				} else if (chk->auth_keyid != auth_keyid) {
+				} else 
+				#ifdef FRCOV
+				{if (FIXREVERTER[864]) {
+				  if ((chk -> auth_keyid != auth_keyid ) && !(0))
+				    fprintf(stderr, "triggered bug index 864\n");
+				  else
+				    fprintf(stderr, "reached bug index 864\n");
+				}
+				if ((!FIXREVERTER[864] && (chk -> auth_keyid != auth_keyid ))
+				#else
+				if (0
+				#endif
+				) {
 					/* different keyid, so done bundling */
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			}
 			m = sctp_copy_mbufchain(chk->data, m, &endofchain, 0, chk->send_size, chk->copy_by_ref);
-			if (m == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[865]) {
+			  if ((m == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 865\n");
+			  else
+			    fprintf(stderr, "reached bug index 865\n");
+			}
+			if ((!FIXREVERTER[865] && (m == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 				return (ENOMEM);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* Do clear IP_DF ? */
 			if (chk->flags & CHUNK_FLAGS_FRAGMENT_OK) {
 				no_fragmentflg = 0;
@@ -10286,10 +11837,25 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 			 * up?
 			 */
 			for (fwd = TAILQ_NEXT(chk, sctp_next); fwd != NULL; fwd = TAILQ_NEXT(fwd, sctp_next)) {
-				if (fwd->sent != SCTP_DATAGRAM_RESEND) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[866]) {
+				  if ((fwd -> sent != 4 ) && !(0))
+				    fprintf(stderr, "triggered bug index 866\n");
+				  else
+				    fprintf(stderr, "reached bug index 866\n");
+				}
+				if ((!FIXREVERTER[866] && (fwd -> sent != 4 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* Nope, not for retran */
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (fwd->whoTo != net) {
 					/* Nope, not the net in question */
 					continue;
@@ -10313,16 +11879,46 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 						} else if (override_ok) {
 							auth_keyid = fwd->auth_keyid;
 							override_ok = 0;
-						} else if (fwd->auth_keyid != auth_keyid) {
+						} else 
+						#ifdef FRCOV
+						{if (FIXREVERTER[867]) {
+						  if ((fwd -> auth_keyid != auth_keyid ) && !(0))
+						    fprintf(stderr, "triggered bug index 867\n");
+						  else
+						    fprintf(stderr, "reached bug index 867\n");
+						}
+						if ((!FIXREVERTER[867] && (fwd -> auth_keyid != auth_keyid ))
+						#else
+						if (0
+						#endif
+						) {
 							/* different keyid, so done bundling */
 							break;
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					m = sctp_copy_mbufchain(fwd->data, m, &endofchain, 0, fwd->send_size, fwd->copy_by_ref);
-					if (m == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[868]) {
+					  if ((m == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 868\n");
+					  else
+					    fprintf(stderr, "reached bug index 868\n");
+					}
+					if ((!FIXREVERTER[868] && (m == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 						return (ENOMEM);
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					/* Do clear IP_DF ? */
 					if (fwd->flags & CHUNK_FLAGS_FRAGMENT_OK) {
 						no_fragmentflg = 0;
@@ -10333,9 +11929,24 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 					else
 						mtu = 0;
 					data_list[bundle_at++] = fwd;
-					if (bundle_at >= SCTP_MAX_DATA_BUNDLING) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[869]) {
+					  if ((bundle_at >= 256 ) && !(0))
+					    fprintf(stderr, "triggered bug index 869\n");
+					  else
+					    fprintf(stderr, "reached bug index 869\n");
+					}
+					if ((!FIXREVERTER[869] && (bundle_at >= 256 ))
+					#else
+					if (0
+					#endif
+					) {
 						break;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 				} else {
 					/* can't fit so we are done */
 					break;
@@ -10488,11 +12099,26 @@ sctp_chunk_retransmission(struct sctp_inpcb *inp,
 			/* None will fit */
 			return (1);
 		}
-		if (asoc->sent_queue_retran_cnt <= 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[870]) {
+		  if ((asoc -> sent_queue_retran_cnt <= 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 870\n");
+		  else
+		    fprintf(stderr, "reached bug index 870\n");
+		}
+		if ((!FIXREVERTER[870] && (asoc -> sent_queue_retran_cnt <= 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* all done we have no more to retran */
 			asoc->sent_queue_retran_cnt = 0;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (one_chunk) {
 			/* No more room in rwnd */
 			return (1);
@@ -10776,7 +12402,22 @@ do_it_again:
 		  (burst_cnt < asoc->max_burst)));
 
 	if (SCTP_BASE_SYSCTL(sctp_use_cwnd_based_maxburst) == 0) {
-		if ((asoc->max_burst > 0) && (burst_cnt >= asoc->max_burst)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[874]) {
+		  fprintf(stderr, "reached bug index 874\n");
+		}
+		if ((FIXREVERTER[874] && (asoc -> max_burst > 0 )) || (!FIXREVERTER[874] && (asoc -> max_burst > 0 && burst_cnt >= asoc -> max_burst ))
+		#else
+		if (asoc -> max_burst > 0 
+		#endif
+		) {
+		  
+		#ifdef FRCOV
+		  if (!(burst_cnt >= asoc -> max_burst ))
+		    fprintf(stderr, "triggered bug index 874\n");
+		  #endif
+		
 			SCTP_STAT_INCR(sctps_maxburstqueued);
 			asoc->burst_limit_applied = 1;
 			if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_LOG_MAXBURST_ENABLE) {
@@ -10785,6 +12426,9 @@ do_it_again:
 		} else {
 			asoc->burst_limit_applied = 0;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_LOGGING_ENABLE) {
 		sctp_log_cwnd(stcb, NULL, tot_out, SCTP_SEND_NOW_COMPLETES);
@@ -10887,9 +12531,24 @@ send_forward_tsn(struct sctp_tcb *stcb,
 	}
 	/* Ok if we reach here we must build one */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[877]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 877\n");
+	  else
+	    fprintf(stderr, "reached bug index 877\n");
+	}
+	if ((!FIXREVERTER[877] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc->fwd_tsn_cnt++;
 	chk->copy_by_ref = 0;
 	/*
@@ -10905,10 +12564,25 @@ send_forward_tsn(struct sctp_tcb *stcb,
 	chk->asoc = asoc;
 	chk->whoTo = NULL;
 	chk->data = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[878]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 878\n");
+	  else
+	    fprintf(stderr, "reached bug index 878\n");
+	}
+	if ((!FIXREVERTER[878] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	chk->sent = SCTP_DATAGRAM_UNSENT;
 	chk->snd_count = 0;
@@ -10980,9 +12654,24 @@ sctp_fill_in_rest:
 		if (at != NULL) {
 			for (i = 0; i < cnt_of_skipped; i++) {
 				tp1 = TAILQ_NEXT(at, sctp_next);
-				if (tp1 == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[879]) {
+				  if ((tp1 == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 879\n");
+				  else
+				    fprintf(stderr, "reached bug index 879\n");
+				}
+				if ((!FIXREVERTER[879] && (tp1 == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				at = tp1;
 			}
 		}
@@ -11045,9 +12734,24 @@ sctp_fill_in_rest:
 	 */
 	i = 0;
 	TAILQ_FOREACH(at, &asoc->sent_queue, sctp_next) {
-		if (i >= cnt_of_skipped) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[880]) {
+		  if ((i >= cnt_of_skipped ) && !(0))
+		    fprintf(stderr, "triggered bug index 880\n");
+		  else
+		    fprintf(stderr, "reached bug index 880\n");
+		}
+		if ((!FIXREVERTER[880] && (i >= cnt_of_skipped ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (!asoc->idata_supported && (at->rec.data.rcv_flags & SCTP_DATA_UNORDERED)) {
 			/* We don't report these */
 			continue;
@@ -11140,7 +12844,19 @@ sctp_send_sack(struct sctp_tcb *stcb, int so_locked
 	}
 	if (a_chk == NULL) {
 		sctp_alloc_a_chunk(stcb, a_chk);
-		if (a_chk == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[882]) {
+		  if ((a_chk == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 882\n");
+		  else
+		    fprintf(stderr, "reached bug index 882\n");
+		}
+		if ((!FIXREVERTER[882] && (a_chk == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* No memory so we drop the idea, and set a timer */
 			if (stcb->asoc.delayed_ack) {
 				sctp_timer_stop(SCTP_TIMER_TYPE_RECV,
@@ -11153,6 +12869,9 @@ sctp_send_sack(struct sctp_tcb *stcb, int so_locked
 			}
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		a_chk->copy_by_ref = 0;
 		a_chk->rec.chunk_id.id = type;
 		a_chk->rec.chunk_id.can_take_data = 1;
@@ -11508,7 +13227,19 @@ sctp_send_abort_tcb(struct sctp_tcb *stcb, struct mbuf *operr, int so_locked
 		m_out = NULL;
 	}
 	m_abort = sctp_get_mbuf_for_msg(sizeof(struct sctp_abort_chunk), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_abort == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[883]) {
+	  if ((m_abort == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 883\n");
+	  else
+	    fprintf(stderr, "reached bug index 883\n");
+	}
+	if ((!FIXREVERTER[883] && (m_abort == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (m_out) {
 			sctp_m_freem(m_out);
 		}
@@ -11517,6 +13248,9 @@ sctp_send_abort_tcb(struct sctp_tcb *stcb, struct mbuf *operr, int so_locked
 		}
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* link in any error */
 	SCTP_BUF_NEXT(m_abort) = operr;
 	cause_len = 0;
@@ -11596,10 +13330,25 @@ sctp_send_shutdown_complete(struct sctp_tcb *stcb,
 	uint8_t flags;
 
 	m_shutdown_comp = sctp_get_mbuf_for_msg(sizeof(struct sctp_chunkhdr), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_shutdown_comp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[884]) {
+	  if ((m_shutdown_comp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 884\n");
+	  else
+	    fprintf(stderr, "reached bug index 884\n");
+	}
+	if ((!FIXREVERTER[884] && (m_shutdown_comp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (reflect_vtag) {
 		flags = SCTP_HAD_NO_TCB;
 		vtag = stcb->asoc.my_vtag;
@@ -11726,12 +13475,27 @@ sctp_send_resp_msg(struct sockaddr *src, struct sockaddr *dst,
 #else
 	mout = sctp_get_mbuf_for_msg(len + max_linkhdr, 1, M_NOWAIT, 1, MT_DATA);
 #endif
-	if (mout == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[885]) {
+	  if ((mout == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 885\n");
+	  else
+	    fprintf(stderr, "reached bug index 885\n");
+	}
+	if ((!FIXREVERTER[885] && (mout == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (cause) {
 			sctp_m_freem(cause);
 		}
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)
 	SCTP_BUF_RESV_UF(mout, max_linkhdr);
@@ -12072,9 +13836,24 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 	struct timeval now;
 
 	SCTP_TCB_LOCK_ASSERT(stcb);
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[886]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 886\n");
+	  else
+	    fprintf(stderr, "reached bug index 886\n");
+	}
+	if ((!FIXREVERTER[886] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	(void)SCTP_GETTIME_TIMEVAL(&now);
 	switch (net->ro._l_addr.sa.sa_family) {
 #ifdef INET
@@ -12093,10 +13872,25 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 		return;
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[887]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 887\n");
+	  else
+	    fprintf(stderr, "reached bug index 887\n");
+	}
+	if ((!FIXREVERTER[887] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Gak, can't get a chunk for hb\n");
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_HEARTBEAT_REQUEST;
@@ -12106,10 +13900,25 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 	chk->send_size = sizeof(struct sctp_heartbeat_chunk);
 
 	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[888]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 888\n");
+	  else
+	    fprintf(stderr, "reached bug index 888\n");
+	}
+	if ((!FIXREVERTER[888] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, so_locked);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	SCTP_BUF_LEN(chk->data) = chk->send_size;
 	chk->sent = SCTP_DATAGRAM_UNSENT;
@@ -12211,9 +14020,24 @@ sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 	struct sctp_ecne_chunk *ecne;
 	struct sctp_tmit_chunk *chk;
 
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[889]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 889\n");
+	  else
+	    fprintf(stderr, "reached bug index 889\n");
+	}
+	if ((!FIXREVERTER[889] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	SCTP_TCB_LOCK_ASSERT(stcb);
 	TAILQ_FOREACH(chk, &asoc->control_send_queue, sctp_next) {
@@ -12234,9 +14058,24 @@ sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 	}
 	/* nope could not find one to update so we must build one */
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[890]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 890\n");
+	  else
+	    fprintf(stderr, "reached bug index 890\n");
+	}
+	if ((!FIXREVERTER[890] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_STAT_INCR(sctps_queue_upd_ecne);
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_ECN_ECHO;
@@ -12245,10 +14084,25 @@ sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 	chk->asoc = &stcb->asoc;
 	chk->send_size = sizeof(struct sctp_ecne_chunk);
 	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[891]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 891\n");
+	  else
+	    fprintf(stderr, "reached bug index 891\n");
+	}
+	if ((!FIXREVERTER[891] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	SCTP_BUF_LEN(chk->data) = chk->send_size;
 	chk->sent = SCTP_DATAGRAM_UNSENT;
@@ -12293,13 +14147,43 @@ sctp_send_packet_dropped(struct sctp_tcb *stcb, struct sctp_nets *net,
 		 */
 		return;
 	}
-	if (stcb->sctp_socket == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[892]) {
+	  if ((stcb -> sctp_socket == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 892\n");
+	  else
+	    fprintf(stderr, "reached bug index 892\n");
+	}
+	if ((!FIXREVERTER[892] && (stcb -> sctp_socket == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[893]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 893\n");
+	  else
+	    fprintf(stderr, "reached bug index 893\n");
+	}
+	if ((!FIXREVERTER[893] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_PACKET_DROPPED;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -12347,18 +14231,48 @@ sctp_send_packet_dropped(struct sctp_tcb *stcb, struct sctp_nets *net,
 	}
 	chk->asoc = &stcb->asoc;
 	chk->data = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[894]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 894\n");
+	  else
+	    fprintf(stderr, "reached bug index 894\n");
+	}
+	if ((!FIXREVERTER[894] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 jump_out:
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	drp = mtod(chk->data, struct sctp_pktdrop_chunk *);
-	if (drp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[895]) {
+	  if ((drp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 895\n");
+	  else
+	    fprintf(stderr, "reached bug index 895\n");
+	}
+	if ((!FIXREVERTER[895] && (drp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_m_freem(chk->data);
 		chk->data = NULL;
 		goto jump_out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->book_size = SCTP_SIZE32((chk->send_size + sizeof(struct sctp_pktdrop_chunk) +
 	    sizeof(struct sctphdr) + SCTP_MED_OVERHEAD));
 	chk->book_size_scale = 0;
@@ -12423,9 +14337,24 @@ sctp_send_cwr(struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t high_tsn, u
 	struct sctp_tmit_chunk *chk;
 
 	SCTP_TCB_LOCK_ASSERT(stcb);
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[896]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 896\n");
+	  else
+	    fprintf(stderr, "reached bug index 896\n");
+	}
+	if ((!FIXREVERTER[896] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	TAILQ_FOREACH(chk, &asoc->control_send_queue, sctp_next) {
 		if ((chk->rec.chunk_id.id == SCTP_ECN_CWR) && (net == chk->whoTo)) {
@@ -12444,9 +14373,24 @@ sctp_send_cwr(struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t high_tsn, u
 		}
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[897]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 897\n");
+	  else
+	    fprintf(stderr, "reached bug index 897\n");
+	}
+	if ((!FIXREVERTER[897] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_ECN_CWR;
 	chk->rec.chunk_id.can_take_data = 1;
@@ -12454,10 +14398,25 @@ sctp_send_cwr(struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t high_tsn, u
 	chk->asoc = &stcb->asoc;
 	chk->send_size = sizeof(struct sctp_cwr_chunk);
 	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
-	if (chk->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[898]) {
+	  if ((chk -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 898\n");
+	  else
+	    fprintf(stderr, "reached bug index 898\n");
+	}
+	if ((!FIXREVERTER[898] && (chk -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_RESV_UF(chk->data, SCTP_MIN_OVERHEAD);
 	SCTP_BUF_LEN(chk->data) = chk->send_size;
 	chk->sent = SCTP_DATAGRAM_UNSENT;
@@ -12495,9 +14454,24 @@ sctp_add_stream_reset_out(struct sctp_tcb *stcb, struct sctp_tmit_chunk *chk,
 			number_entries++;
 		}
 	}
-	if (number_entries == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[899]) {
+	  if ((number_entries == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 899\n");
+	  else
+	    fprintf(stderr, "reached bug index 899\n");
+	}
+	if ((!FIXREVERTER[899] && (number_entries == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (number_entries == stcb->asoc.streamoutcnt) {
 		number_entries = 0;
 	}
@@ -12519,9 +14493,24 @@ sctp_add_stream_reset_out(struct sctp_tcb *stcb, struct sctp_tmit_chunk *chk,
 				req_out->list_of_streams[at] = htons(i);
 				at++;
 				stcb->asoc.strmout[i].state = SCTP_STREAM_RESET_IN_FLIGHT;
-				if (at >= number_entries) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[900]) {
+				  if ((at >= number_entries ) && !(0))
+				    fprintf(stderr, "triggered bug index 900\n");
+				  else
+				    fprintf(stderr, "reached bug index 900\n");
+				}
+				if ((!FIXREVERTER[900] && (at >= number_entries ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			}
 		}
 	} else {
@@ -12665,10 +14654,25 @@ sctp_send_deferred_reset_response(struct sctp_tcb *stcb,
 		return;
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[901]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 901\n");
+	  else
+	    fprintf(stderr, "reached bug index 901\n");
+	}
+	if ((!FIXREVERTER[901] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -12817,10 +14821,25 @@ sctp_send_stream_reset_out_if_possible(struct sctp_tcb *stcb, int so_locked)
 		return (EALREADY);
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[902]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 902\n");
+	  else
+	    fprintf(stderr, "reached bug index 902\n");
+	}
+	if ((!FIXREVERTER[902] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -12920,10 +14939,25 @@ sctp_send_str_reset_req(struct sctp_tcb *stcb,
 		return (ENOMEM);
 	}
 	sctp_alloc_a_chunk(stcb, chk);
-	if (chk == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[903]) {
+	  if ((chk == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 903\n");
+	  else
+	    fprintf(stderr, "reached bug index 903\n");
+	}
+	if ((!FIXREVERTER[903] && (chk == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	chk->copy_by_ref = 0;
 	chk->rec.chunk_id.id = SCTP_STREAM_RESET;
 	chk->rec.chunk_id.can_take_data = 0;
@@ -13227,10 +15261,25 @@ sctp_copy_one(struct sctp_stream_queue_pending *sp,
 #elif defined(__FreeBSD__) && __FreeBSD_version > 602000 || defined(__Userspace__)
 	sp->data = m_uiotombuf(uio, M_WAITOK, sp->length,
 	                       resv_upfront, 0);
-	if (sp->data == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[904]) {
+	  if ((sp -> data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 904\n");
+	  else
+	    fprintf(stderr, "reached bug index 904\n");
+	}
+	if ((!FIXREVERTER[904] && (sp -> data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_OUTPUT, ENOBUFS);
 		return (ENOBUFS);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	sp->tail_mbuf = m_last(sp->data);
 	return (0);
@@ -13324,11 +15373,26 @@ sctp_copy_it_in(struct sctp_tcb *stcb,
 		goto out_now;
 	}
 	sctp_alloc_a_strmoq(stcb, sp);
-	if (sp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[905]) {
+	  if ((sp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 905\n");
+	  else
+	    fprintf(stderr, "reached bug index 905\n");
+	}
+	if ((!FIXREVERTER[905] && (sp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, stcb, net, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 		*error = ENOMEM;
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	sp->act_flags = 0;
 	sp->sender_all_done = 0;
 	sp->sinfo_flags = srcv->sinfo_flags;
@@ -13369,9 +15433,24 @@ sctp_copy_it_in(struct sctp_tcb *stcb,
 	sp->put_last_out = 0;
 	resv_in_first = SCTP_DATA_CHUNK_OVERHEAD(stcb);
 	sp->data = sp->tail_mbuf = NULL;
-	if (sp->length == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[906]) {
+	  if ((sp -> length == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 906\n");
+	  else
+	    fprintf(stderr, "reached bug index 906\n");
+	}
+	if ((!FIXREVERTER[906] && (sp -> length == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		goto skip_copy;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (srcv->sinfo_keynumber_valid) {
 		sp->auth_keyid = srcv->sinfo_keynumber;
 	} else {
@@ -13587,11 +15666,26 @@ sctp_lower_sosend(struct socket *so,
 		if (uio_resid(uio) < 0) {
 #endif
 #else
-		if (uio->uio_resid < 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[907]) {
+		  if ((uio -> uio_resid < 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 907\n");
+		  else
+		    fprintf(stderr, "reached bug index 907\n");
+		}
+		if ((!FIXREVERTER[907] && (uio -> uio_resid < 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #endif
 			SCTP_LTRACE_ERR_RET(inp, stcb, net, SCTP_FROM_SCTP_OUTPUT, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD)
 		sndlen = uio->uio_resid;
@@ -13840,10 +15934,25 @@ sctp_lower_sosend(struct socket *so,
 			                       (struct proc *)NULL,
 #endif
 			                       SCTP_INITIALIZE_AUTH_PARAMS);
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[908]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 908\n");
+			  else
+			    fprintf(stderr, "reached bug index 908\n");
+			}
+			if ((!FIXREVERTER[908] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* Error is setup for us in the call */
 				goto out_unlocked;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 				stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 				/* Set the connected flag so we can queue data */
@@ -13976,12 +16085,27 @@ sctp_lower_sosend(struct socket *so,
 		create_lock_applied = 0;
 	}
 	/* Is the stream no. valid? */
-	if (srcv->sinfo_stream >= asoc->streamoutcnt) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[909]) {
+	  if ((srcv -> sinfo_stream >= asoc -> streamoutcnt ) && !(0))
+	    fprintf(stderr, "triggered bug index 909\n");
+	  else
+	    fprintf(stderr, "reached bug index 909\n");
+	}
+	if ((!FIXREVERTER[909] && (srcv -> sinfo_stream >= asoc -> streamoutcnt ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Invalid stream number */
 		SCTP_LTRACE_ERR_RET(inp, stcb, net, SCTP_FROM_SCTP_OUTPUT, EINVAL);
 		error = EINVAL;
 		goto out_unlocked;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((asoc->strmout[srcv->sinfo_stream].state != SCTP_STREAM_OPEN) &&
 	    (asoc->strmout[srcv->sinfo_stream].state != SCTP_STREAM_OPENING)) {
 		/*
@@ -14067,11 +16191,26 @@ sctp_lower_sosend(struct socket *so,
 			}
 			mm = sctp_get_mbuf_for_msg((unsigned int)tot_demand, 0, M_WAITOK, 1, MT_DATA);
 		}
-		if (mm == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[911]) {
+		  if ((mm == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 911\n");
+		  else
+		    fprintf(stderr, "reached bug index 911\n");
+		}
+		if ((!FIXREVERTER[911] && (mm == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(NULL, stcb, net, SCTP_FROM_SCTP_OUTPUT, ENOMEM);
 			error = ENOMEM;
 			goto out;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		max_out = asoc->smallest_mtu - sizeof(struct sctp_paramhdr);
 		max_out -= sizeof(struct sctp_abort_msg);
 		if (tot_out > max_out) {
@@ -14140,12 +16279,27 @@ sctp_lower_sosend(struct socket *so,
 		SCTP_TCB_UNLOCK(stcb);
 		hold_tcblock = 0;
 	}
-	if (asoc->strmout == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[912]) {
+	  if ((asoc -> strmout == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 912\n");
+	  else
+	    fprintf(stderr, "reached bug index 912\n");
+	}
+	if ((!FIXREVERTER[912] && (asoc -> strmout == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* huh? software error */
 		SCTP_LTRACE_ERR_RET(inp, stcb, net, SCTP_FROM_SCTP_OUTPUT, EFAULT);
 		error = EFAULT;
 		goto out_unlocked;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* Unless E_EOR mode is on, we must make a send FIT in one call. */
 	if ((user_marks_eor == 0) &&
@@ -14302,7 +16456,19 @@ skip_preblock:
 			SCTP_TCB_SEND_LOCK(stcb);
 			sp = TAILQ_LAST(&strm->outqueue, sctp_streamhead);
 			SCTP_TCB_SEND_UNLOCK(stcb);
-			if (sp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[913]) {
+			  if ((sp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 913\n");
+			  else
+			    fprintf(stderr, "reached bug index 913\n");
+			}
+			if ((!FIXREVERTER[913] && (sp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/* ???? Huh ??? last msg is gone */
 #ifdef INVARIANTS
 				panic("Warning: Last msg marked incomplete, yet nothing left?");
@@ -14313,6 +16479,9 @@ skip_preblock:
 				goto do_a_copy_in;
 
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD)
@@ -14422,11 +16591,26 @@ skip_preblock:
 			if (uio_resid(uio) == 0) {
 #endif
 #else
-			if (uio->uio_resid == 0) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[914]) {
+			  if ((uio -> uio_resid == 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 914\n");
+			  else
+			    fprintf(stderr, "reached bug index 914\n");
+			}
+			if ((!FIXREVERTER[914] && (uio -> uio_resid == 0 ))
+			#else
+			if (0
+			#endif
+			) {
 #endif
 				/* got it all? */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			/* PR-SCTP? */
 			if ((asoc->prsctp_supported) && (asoc->sent_queue_cnt_removeable > 0)) {
 				/* This is ugly but we must assure locking order */
@@ -14919,9 +17103,23 @@ sctp_add_auth_chunk(struct mbuf *m, struct mbuf **m_end,
 	int chunk_len;
 	struct mbuf *cn;
 
-	if ((m_end == NULL) || (auth_ret == NULL) || (offset == NULL) ||
-	    (stcb == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[918]) {
+	  if ((m_end == (void *) 0 || auth_ret == (void *) 0 || offset == (void *) 0 || stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 918\n");
+	  else
+	    fprintf(stderr, "reached bug index 918\n");
+	}
+	if ((!FIXREVERTER[918] && (m_end == (void *) 0 || auth_ret == (void *) 0 || offset == (void *) 0 || stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (m);
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (stcb->asoc.auth_supported == 0) {
 		return (m);
@@ -14931,10 +17129,25 @@ sctp_add_auth_chunk(struct mbuf *m, struct mbuf **m_end,
 		return (m);
 	}
 	m_auth = sctp_get_mbuf_for_msg(sizeof(*auth), 0, M_NOWAIT, 1, MT_HEADER);
-	if (m_auth == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[919]) {
+	  if ((m_auth == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 919\n");
+	  else
+	    fprintf(stderr, "reached bug index 919\n");
+	}
+	if ((!FIXREVERTER[919] && (m_auth == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no mbuf's */
 		return (m);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* reserve some space if this will be the first mbuf */
 	if (m == NULL)
 		SCTP_BUF_RESV_UF(m_auth, SCTP_MIN_OVERHEAD);
diff --git a/usrsctplib/netinet/sctp_pcb.c b/usrsctplib/netinet/sctp_pcb.c
index 7b4a194..4bbc708 100755
--- a/usrsctplib/netinet/sctp_pcb.c
+++ b/usrsctplib/netinet/sctp_pcb.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -225,13 +229,28 @@ sctp_allocate_vrf(int vrf_id)
 	}
 	SCTP_MALLOC(vrf, struct sctp_vrf *, sizeof(struct sctp_vrf),
 		    SCTP_M_VRF);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[524]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 524\n");
+	  else
+	    fprintf(stderr, "reached bug index 524\n");
+	}
+	if ((!FIXREVERTER[524] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory */
 #ifdef INVARIANTS
 		panic("No memory for VRF:%d", vrf_id);
 #endif
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* setup the VRF */
 	memset(vrf, 0, sizeof(struct sctp_vrf));
 	vrf->vrf_id = vrf_id;
@@ -243,7 +262,19 @@ sctp_allocate_vrf(int vrf_id)
 	/* Init the HASH of addresses */
 	vrf->vrf_addr_hash = SCTP_HASH_INIT(SCTP_VRF_ADDR_HASH_SIZE,
 					    &vrf->vrf_addr_hashmark);
-	if (vrf->vrf_addr_hash == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[525]) {
+	  if ((vrf -> vrf_addr_hash == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 525\n");
+	  else
+	    fprintf(stderr, "reached bug index 525\n");
+	}
+	if ((!FIXREVERTER[525] && (vrf -> vrf_addr_hash == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* No memory */
 #ifdef INVARIANTS
 		panic("No memory for VRF:%d", vrf_id);
@@ -251,6 +282,9 @@ sctp_allocate_vrf(int vrf_id)
 		SCTP_FREE(vrf, SCTP_M_VRF);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/* Add it to the hash table */
 	bucket = &SCTP_BASE_INFO(sctp_vrfhash)[(vrf_id & SCTP_BASE_INFO(hashvrfmark))];
@@ -271,9 +305,24 @@ sctp_find_ifn(void *ifn, uint32_t ifn_index)
 	 */
 	hash_ifn_head = &SCTP_BASE_INFO(vrf_ifn_hash)[(ifn_index & SCTP_BASE_INFO(vrf_ifn_hashmark))];
 	LIST_FOREACH(sctp_ifnp, hash_ifn_head, next_bucket) {
-		if (sctp_ifnp->ifn_index == ifn_index) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[526]) {
+		  if ((sctp_ifnp -> ifn_index == ifn_index ) && !(0))
+		    fprintf(stderr, "triggered bug index 526\n");
+		  else
+		    fprintf(stderr, "reached bug index 526\n");
+		}
+		if ((!FIXREVERTER[526] && (sctp_ifnp -> ifn_index == ifn_index ))
+		#else
+		if (0
+		#endif
+		) {
 			return (sctp_ifnp);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_ifnp->ifn_p && ifn && (sctp_ifnp->ifn_p == ifn)) {
 			return (sctp_ifnp);
 		}
@@ -360,10 +409,25 @@ sctp_delete_ifn(struct sctp_ifn *sctp_ifnp, int hold_addr_lock)
 	struct sctp_ifn *found;
 
 	found = sctp_find_ifn(sctp_ifnp->ifn_p, sctp_ifnp->ifn_index);
-	if (found == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[528]) {
+	  if ((found == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 528\n");
+	  else
+	    fprintf(stderr, "reached bug index 528\n");
+	}
+	if ((!FIXREVERTER[528] && (found == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Not in the list.. sorry */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (hold_addr_lock == 0)
 		SCTP_IPI_ADDR_WLOCK();
 	LIST_REMOVE(sctp_ifnp, next_bucket);
@@ -581,10 +645,25 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 		vrf = sctp_find_vrf(vrf_id);
 		if (vrf == NULL) {
 			vrf = sctp_allocate_vrf(vrf_id);
-			if (vrf == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[535]) {
+			  if ((vrf == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 535\n");
+			  else
+			    fprintf(stderr, "reached bug index 535\n");
+			}
+			if ((!FIXREVERTER[535] && (vrf == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_IPI_ADDR_WUNLOCK();
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 	}
 	if (sctp_ifnp == NULL) {
@@ -594,12 +673,27 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 		SCTP_IPI_ADDR_WUNLOCK();
 		SCTP_MALLOC(sctp_ifnp, struct sctp_ifn *,
 			    sizeof(struct sctp_ifn), SCTP_M_IFN);
-		if (sctp_ifnp == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[536]) {
+		  if ((sctp_ifnp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 536\n");
+		  else
+		    fprintf(stderr, "reached bug index 536\n");
+		}
+		if ((!FIXREVERTER[536] && (sctp_ifnp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #ifdef INVARIANTS
 			panic("No memory for IFN");
 #endif
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		memset(sctp_ifnp, 0, sizeof(struct sctp_ifn));
 		sctp_ifnp->ifn_index = ifn_index;
 		sctp_ifnp->ifn_p = ifn;
@@ -670,12 +764,27 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 	}
 	SCTP_IPI_ADDR_WUNLOCK();
 	SCTP_MALLOC(sctp_ifap, struct sctp_ifa *, sizeof(struct sctp_ifa), SCTP_M_IFA);
-	if (sctp_ifap == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[537]) {
+	  if ((sctp_ifap == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 537\n");
+	  else
+	    fprintf(stderr, "reached bug index 537\n");
+	}
+	if ((!FIXREVERTER[537] && (sctp_ifap == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 #ifdef INVARIANTS
 		panic("No memory for IFA");
 #endif
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(sctp_ifap, 0, sizeof(struct sctp_ifa));
 	sctp_ifap->ifn_p = sctp_ifnp;
 	atomic_add_int(&sctp_ifnp->refcount, 1);
@@ -785,7 +894,19 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 
 		atomic_add_int(&sctp_ifap->refcount, 1);
 		wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-		if (wi == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[538]) {
+		  if ((wi == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 538\n");
+		  else
+		    fprintf(stderr, "reached bug index 538\n");
+		}
+		if ((!FIXREVERTER[538] && (wi == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/*
 			 * Gak, what can we do? We have lost an address
 			 * change can you say HOSED?
@@ -796,6 +917,9 @@ sctp_add_addr_to_vrf(uint32_t vrf_id, void *ifn, uint32_t ifn_index,
 					       if_name);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_INCR_LADDR_COUNT();
 		memset(wi, 0, sizeof(*wi));
 		(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);
@@ -825,10 +949,25 @@ sctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,
 
 	SCTP_IPI_ADDR_WLOCK();
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[539]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 539\n");
+	  else
+	    fprintf(stderr, "reached bug index 539\n");
+	}
+	if ((!FIXREVERTER[539] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_PCB4, "Can't find vrf_id 0x%x\n", vrf_id);
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #ifdef SCTP_DEBUG
 	SCTPDBG(SCTP_DEBUG_PCB4, "vrf_id 0x%x: deleting address:", vrf_id);
@@ -892,7 +1031,19 @@ sctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,
 		struct sctp_laddr *wi;
 
 		wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-		if (wi == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[540]) {
+		  if ((wi == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 540\n");
+		  else
+		    fprintf(stderr, "reached bug index 540\n");
+		}
+		if ((!FIXREVERTER[540] && (wi == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/*
 			 * Gak, what can we do? We have lost an address
 			 * change can you say HOSED?
@@ -903,6 +1054,9 @@ sctp_del_addr_from_vrf(uint32_t vrf_id, struct sockaddr *addr,
 			sctp_free_ifa(sctp_ifap);
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_INCR_LADDR_COUNT();
 		memset(wi, 0, sizeof(*wi));
 		(void)SCTP_GETTIME_TIMEVAL(&wi->start_time);
@@ -957,11 +1111,26 @@ sctp_does_stcb_own_this_addr(struct sctp_tcb *stcb, struct sockaddr *to)
 
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(stcb->asoc.vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[541]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 541\n");
+	  else
+	    fprintf(stderr, "reached bug index 541\n");
+	}
+	if ((!FIXREVERTER[541] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no vrf, no addresses */
 		SCTP_IPI_ADDR_RUNLOCK();
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
@@ -1165,9 +1334,24 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 	int fnd, i;
 #endif
 
-	if ((to == NULL) || (from == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[543]) {
+	  if ((to == (void *) 0 || from == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 543\n");
+	  else
+	    fprintf(stderr, "reached bug index 543\n");
+	}
+	if ((!FIXREVERTER[543] && (to == (void *) 0 || from == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	switch (to->sa_family) {
 #ifdef INET
@@ -1268,10 +1452,25 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 			continue;
 		}
 #else
-		if (inp->def_vrf_id != vrf_id) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[544]) {
+		  if ((inp -> def_vrf_id != vrf_id ) && !(0))
+		    fprintf(stderr, "triggered bug index 544\n");
+		  else
+		    fprintf(stderr, "reached bug index 544\n");
+		}
+		if ((!FIXREVERTER[544] && (inp -> def_vrf_id != vrf_id ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #endif
 		/* check to see if the ep has one of the addresses */
 		if ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {
@@ -1280,10 +1479,25 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 
 			LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
 
-				if (laddr->ifa == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[545]) {
+				  if ((laddr -> ifa == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 545\n");
+				  else
+				    fprintf(stderr, "reached bug index 545\n");
+				}
+				if ((!FIXREVERTER[545] && (laddr -> ifa == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					SCTPDBG(SCTP_DEBUG_PCB1, "%s: NULL ifa\n", __func__);
 					continue;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
 					SCTPDBG(SCTP_DEBUG_PCB1, "ifa being deleted\n");
 					continue;
@@ -1347,22 +1561,52 @@ sctp_tcb_special_locate(struct sctp_inpcb **inp_p, struct sockaddr *from,
 		 */
 		/* XXX: Why don't we TAILQ_FOREACH through sctp_asoc_list? */
 		stcb = LIST_FIRST(&inp->sctp_asoc_list);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[547]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 547\n");
+		  else
+		    fprintf(stderr, "reached bug index 547\n");
+		}
+		if ((!FIXREVERTER[547] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_TCB_LOCK(stcb);
 		if (!sctp_does_stcb_own_this_addr(stcb, to)) {
 			SCTP_TCB_UNLOCK(stcb);
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
-		if (stcb->rport != rport) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[548]) {
+		  if ((stcb -> rport != rport ) && !(0))
+		    fprintf(stderr, "triggered bug index 548\n");
+		  else
+		    fprintf(stderr, "reached bug index 548\n");
+		}
+		if ((!FIXREVERTER[548] && (stcb -> rport != rport ))
+		#else
+		if (0
+		#endif
+		) {
 			/* remote port does not match. */
 			SCTP_TCB_UNLOCK(stcb);
 			SCTP_INP_RUNLOCK(inp);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 			SCTP_TCB_UNLOCK(stcb);
 			SCTP_INP_RUNLOCK(inp);
@@ -1564,11 +1808,26 @@ sctp_findassociation_ep_addr(struct sctp_inpcb **inp_p, struct sockaddr *remote,
 			}
 			SCTP_TCB_LOCK(stcb);
 
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[550]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 550\n");
+			  else
+			    fprintf(stderr, "reached bug index 550\n");
+			}
+			if ((!FIXREVERTER[550] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				/* remote port does not match. */
 				SCTP_TCB_UNLOCK(stcb);
 				goto null_return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 				SCTP_TCB_UNLOCK(stcb);
 				goto null_return;
@@ -1690,10 +1949,25 @@ sctp_findassociation_ep_addr(struct sctp_inpcb **inp_p, struct sockaddr *remote,
 		head = &inp->sctp_tcbhash[SCTP_PCBHASH_ALLADDR(rport,
 		                                               inp->sctp_hashmark)];
 		LIST_FOREACH(stcb, head, sctp_tcbhash) {
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[551]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 551\n");
+			  else
+			    fprintf(stderr, "reached bug index 551\n");
+			}
+			if ((!FIXREVERTER[551] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				/* remote port does not match */
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_TCB_LOCK(stcb);
 			if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 				SCTP_TCB_UNLOCK(stcb);
@@ -1836,21 +2110,51 @@ sctp_findasoc_ep_asocid_locked(struct sctp_inpcb *inp, sctp_assoc_t asoc_id, int
 	struct sctp_tcb *stcb;
 	uint32_t id;
 
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[552]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 552\n");
+	  else
+	    fprintf(stderr, "reached bug index 552\n");
+	}
+	if ((!FIXREVERTER[552] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_PRINTF("TSNH ep_associd\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {
 		SCTP_PRINTF("TSNH ep_associd0\n");
 		return (NULL);
 	}
 	id = (uint32_t)asoc_id;
 	head = &inp->sctp_asocidhash[SCTP_PCBHASH_ASOC(id, inp->hashasocidmark)];
-	if (head == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[553]) {
+	  if ((head == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 553\n");
+	  else
+	    fprintf(stderr, "reached bug index 553\n");
+	}
+	if ((!FIXREVERTER[553] && (head == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* invalid id TSNH */
 		SCTP_PRINTF("TSNH ep_associd1\n");
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_FOREACH(stcb, head, sctp_tcbasocidhash) {
 		if (stcb->asoc.assoc_id == id) {
 			if (inp != stcb->sctp_ep) {
@@ -1940,8 +2244,23 @@ sctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,
 		return (NULL);
 	}
 
-	if (head == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[554]) {
+	  if ((head == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 554\n");
+	  else
+	    fprintf(stderr, "reached bug index 554\n");
+	}
+	if ((!FIXREVERTER[554] && (head == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	LIST_FOREACH(inp, head, sctp_hash) {
 		SCTP_INP_RLOCK(inp);
@@ -2029,9 +2348,24 @@ sctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,
 #endif
 #if defined(__Userspace__)
 	case AF_CONN:
-		if (sconn->sconn_addr == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[556]) {
+		  if ((sconn -> sconn_addr == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 556\n");
+		  else
+		    fprintf(stderr, "reached bug index 556\n");
+		}
+		if ((!FIXREVERTER[556] && (sconn -> sconn_addr == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		break;
 #endif
 	default:
@@ -2078,11 +2412,26 @@ sctp_endpoint_probe(struct sockaddr *nam, struct sctppcbhead *head,
 			continue;
 		}
 		LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-			if (laddr->ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[558]) {
+			  if ((laddr -> ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 558\n");
+			  else
+			    fprintf(stderr, "reached bug index 558\n");
+			}
+			if ((!FIXREVERTER[558] && (laddr -> ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_PCB1, "%s: NULL ifa\n",
 					__func__);
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTPDBG(SCTP_DEBUG_PCB1, "Ok laddr->ifa:%p is possible, ",
 				(void *)laddr->ifa);
 			if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
@@ -2365,9 +2714,24 @@ sctp_findassociation_addr_sa(struct sockaddr *from, struct sockaddr *to,
 		*inp_p = inp;
 	}
 	SCTP_INP_INFO_RUNLOCK();
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[560]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 560\n");
+	  else
+	    fprintf(stderr, "reached bug index 560\n");
+	}
+	if ((!FIXREVERTER[560] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/*
 	 * ok, we have an endpoint, now lets find the assoc for it (if any)
 	 * we now place the source address or from in the to of the find
@@ -2434,9 +2798,24 @@ sctp_findassociation_special_addr(struct mbuf *m, int offset,
 		ptype = ntohs(phdr->param_type);
 #endif
 		plen = ntohs(phdr->param_length);
-		if (plen == 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[561]) {
+		  if ((plen == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 561\n");
+		  else
+		    fprintf(stderr, "reached bug index 561\n");
+		}
+		if ((!FIXREVERTER[561] && (plen == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef INET
 		if (ptype == SCTP_IPV4_ADDRESS &&
 		    plen == sizeof(struct sctp_ipv4addr_param)) {
@@ -2445,9 +2824,24 @@ sctp_findassociation_special_addr(struct mbuf *m, int offset,
 
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)&ip4_param, sizeof(ip4_param));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[562]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 562\n");
+			  else
+			    fprintf(stderr, "reached bug index 562\n");
+			}
+			if ((!FIXREVERTER[562] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			p4 = (struct sctp_ipv4addr_param *)phdr;
 			memcpy(&sin4.sin_addr, &p4->addr, sizeof(p4->addr));
 			/* look it up */
@@ -2466,9 +2860,24 @@ sctp_findassociation_special_addr(struct mbuf *m, int offset,
 
 			phdr = sctp_get_next_param(m, offset,
 			    (struct sctp_paramhdr *)&ip6_param, sizeof(ip6_param));
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[563]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 563\n");
+			  else
+			    fprintf(stderr, "reached bug index 563\n");
+			}
+			if ((!FIXREVERTER[563] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			p6 = (struct sctp_ipv6addr_param *)phdr;
 			memcpy(&sin6.sin6_addr, &p6->addr, sizeof(p6->addr));
 			/* look it up */
@@ -2532,10 +2941,25 @@ sctp_findassoc_by_vtag(struct sockaddr *from, struct sockaddr *to, uint32_t vtag
 		SCTP_INP_RUNLOCK(stcb->sctp_ep);
 		if (stcb->asoc.my_vtag == vtag) {
 			/* candidate */
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[564]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 564\n");
+			  else
+			    fprintf(stderr, "reached bug index 564\n");
+			}
+			if ((!FIXREVERTER[564] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_TCB_UNLOCK(stcb);
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->sctp_ep->sctp_lport != lport) {
 				SCTP_TCB_UNLOCK(stcb);
 				continue;
@@ -2678,11 +3102,26 @@ sctp_findassociation_ep_asconf(struct mbuf *m, int offset,
 	memset(&remote_store, 0, sizeof(remote_store));
 	phdr = sctp_get_next_param(m, offset + sizeof(struct sctp_asconf_chunk),
 				   &param_buf, sizeof(struct sctp_paramhdr));
-	if (phdr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[565]) {
+	  if ((phdr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 565\n");
+	  else
+	    fprintf(stderr, "reached bug index 565\n");
+	}
+	if ((!FIXREVERTER[565] && (phdr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_INPUT3, "%s: failed to get asconf lookup addr\n",
 			__func__);
 		return NULL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	ptype = (int)((uint32_t) ntohs(phdr->param_type));
 	/* get the correlation address */
 	switch (ptype) {
@@ -2698,11 +3137,26 @@ sctp_findassociation_ep_asconf(struct mbuf *m, int offset,
 		p6 = (struct sctp_ipv6addr_param *)sctp_get_next_param(m,
 								       offset + sizeof(struct sctp_asconf_chunk),
 								       &p6_buf.ph, sizeof(p6_buf));
-		if (p6 == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[566]) {
+		  if ((p6 == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 566\n");
+		  else
+		    fprintf(stderr, "reached bug index 566\n");
+		}
+		if ((!FIXREVERTER[566] && (p6 == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s: failed to get asconf v6 lookup addr\n",
 				__func__);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sin6 = &remote_store.sin6;
 		sin6->sin6_family = AF_INET6;
 #ifdef HAVE_SIN6_LEN
@@ -2727,11 +3181,26 @@ sctp_findassociation_ep_asconf(struct mbuf *m, int offset,
 		p4 = (struct sctp_ipv4addr_param *)sctp_get_next_param(m,
 								       offset + sizeof(struct sctp_asconf_chunk),
 								       &p4_buf.ph, sizeof(p4_buf));
-		if (p4 == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[567]) {
+		  if ((p4 == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 567\n");
+		  else
+		    fprintf(stderr, "reached bug index 567\n");
+		}
+		if ((!FIXREVERTER[567] && (p4 == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s: failed to get asconf v4 lookup addr\n",
 				__func__);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sin = &remote_store.sin;
 		sin->sin_family = AF_INET;
 #ifdef HAVE_SIN_LEN
@@ -3159,7 +3628,19 @@ sctp_move_pcb_and_assoc(struct sctp_inpcb *old_inp, struct sctp_inpcb *new_inp,
 		/* Subset bound, so copy in the laddr list from the old_inp */
 		LIST_FOREACH(oladdr, &old_inp->sctp_addr_list, sctp_nxt_addr) {
 			laddr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-			if (laddr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[568]) {
+			  if ((laddr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 568\n");
+			  else
+			    fprintf(stderr, "reached bug index 568\n");
+			}
+			if ((!FIXREVERTER[568] && (laddr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				/*
 				 * Gak, what can we do? This assoc is really
 				 * HOSED. We probably should send an abort
@@ -3168,6 +3649,9 @@ sctp_move_pcb_and_assoc(struct sctp_inpcb *old_inp, struct sctp_inpcb *new_inp,
 				SCTPDBG(SCTP_DEBUG_PCB1, "Association hosed in TCP model, out of laddr memory\n");
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_INCR_LADDR_COUNT();
 			memset(laddr, 0, sizeof(*laddr));
 			(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);
@@ -3213,11 +3697,26 @@ sctp_insert_laddr(struct sctpladdr *list, struct sctp_ifa *ifa, uint32_t act)
 	struct sctp_laddr *laddr;
 
 	laddr = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-	if (laddr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[569]) {
+	  if ((laddr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 569\n");
+	  else
+	    fprintf(stderr, "reached bug index 569\n");
+	}
+	if ((!FIXREVERTER[569] && (laddr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory? */
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INCR_LADDR_COUNT();
 	memset(laddr, 0, sizeof(*laddr));
 	(void)SCTP_GETTIME_TIMEVAL(&laddr->start_time);
@@ -3775,11 +4274,26 @@ sctp_inpcb_bind(struct socket *so, struct sockaddr *addr,
 
 		/* add this address to the endpoint list */
 		error = sctp_insert_laddr(&inp->sctp_addr_list, ifa, 0);
-		if (error != 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[570]) {
+		  if ((error != 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 570\n");
+		  else
+		    fprintf(stderr, "reached bug index 570\n");
+		}
+		if ((!FIXREVERTER[570] && (error != 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_INP_WUNLOCK(inp);
 			SCTP_INP_INFO_WUNLOCK();
 			return (error);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		inp->laddr_count++;
 	}
 	/* find the bucket */
@@ -4500,10 +5014,25 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 		struct sockaddr_conn *sconn;
 
 		sconn = (struct sockaddr_conn *)newaddr;
-		if (sconn->sconn_addr == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[571]) {
+		  if ((sconn -> sconn_addr == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 571\n");
+		  else
+		    fprintf(stderr, "reached bug index 571\n");
+		}
+		if ((!FIXREVERTER[571] && (sconn -> sconn_addr == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* Invalid address */
 			return (-1);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef HAVE_SCONN_LEN
 		sconn->sconn_len = sizeof(struct sockaddr_conn);
 #endif
@@ -4515,9 +5044,24 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 		return (-1);
 	}
 	net = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_net), struct sctp_nets);
-	if (net == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[572]) {
+	  if ((net == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 572\n");
+	  else
+	    fprintf(stderr, "reached bug index 572\n");
+	}
+	if ((!FIXREVERTER[572] && (net == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INCR_RADDR_COUNT();
 	memset(net, 0, sizeof(struct sctp_nets));
 	(void)SCTP_GETTIME_TIMEVAL(&net->start_time);
@@ -4944,11 +5488,26 @@ sctp_aloc_assoc(struct sctp_inpcb *inp, struct sockaddr *firstaddr,
 		*error = ENOBUFS;
 		return (NULL);
 	}
-	if (firstaddr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[573]) {
+	  if ((firstaddr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 573\n");
+	  else
+	    fprintf(stderr, "reached bug index 573\n");
+	}
+	if ((!FIXREVERTER[573] && (firstaddr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, EINVAL);
 		*error = EINVAL;
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_RLOCK(inp);
 	if ((inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) &&
 	    ((sctp_is_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE)) ||
@@ -5090,12 +5649,27 @@ sctp_aloc_assoc(struct sctp_inpcb *inp, struct sockaddr *firstaddr,
 		}
 	}
 	stcb = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_asoc), struct sctp_tcb);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[574]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 574\n");
+	  else
+	    fprintf(stderr, "reached bug index 574\n");
+	}
+	if ((!FIXREVERTER[574] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* out of memory? */
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);
 		*error = ENOMEM;
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INCR_ASOC_COUNT();
 
 	memset(stcb, 0, sizeof(*stcb));
@@ -5347,10 +5921,25 @@ sctp_add_vtag_to_timewait(uint32_t tag, uint32_t time, uint16_t lport, uint16_t
 	struct timeval now;
 	int set, i;
 
-	if (time == 0) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[575]) {
+	  if ((time == 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 575\n");
+	  else
+	    fprintf(stderr, "reached bug index 575\n");
+	}
+	if ((!FIXREVERTER[575] && (time == 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Its disabled */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	(void)SCTP_GETTIME_TIMEVAL(&now);
 	chain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];
 	set = 0;
@@ -5394,12 +5983,27 @@ sctp_add_vtag_to_timewait(uint32_t tag, uint32_t time, uint16_t lport, uint16_t
 	if (!set) {
 		SCTP_MALLOC(twait_block, struct sctp_tagblock *,
 		    sizeof(struct sctp_tagblock), SCTP_M_TIMW);
-		if (twait_block == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[576]) {
+		  if ((twait_block == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 576\n");
+		  else
+		    fprintf(stderr, "reached bug index 576\n");
+		}
+		if ((!FIXREVERTER[576] && (twait_block == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #ifdef INVARIANTS
 			panic("Can not alloc tagblock");
 #endif
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		memset(twait_block, 0, sizeof(struct sctp_tagblock));
 		LIST_INSERT_HEAD(chain, twait_block, sctp_nxt_tagblock);
 		twait_block->vtag_block[0].tv_sec_at_expire = now.tv_sec + time;
@@ -6130,11 +6734,26 @@ sctp_update_ep_vflag(struct sctp_inpcb *inp)
 #endif
 	/* set the flag based on addresses on the ep list */
 	LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[577]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 577\n");
+		  else
+		    fprintf(stderr, "reached bug index 577\n");
+		}
+		if ((!FIXREVERTER[577] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTPDBG(SCTP_DEBUG_PCB1, "%s: NULL ifa\n",
 				__func__);
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		if (laddr->ifa->localifa_flags & SCTP_BEING_DELETED) {
 			continue;
@@ -6303,9 +6922,24 @@ sctp_del_local_addr_ep(struct sctp_inpcb *inp, struct sctp_ifa *ifa)
 		struct sctp_tcb *stcb;
 
 		/* clean up "next_addr_touse" */
-		if (inp->next_addr_touse == laddr)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[579]) {
+		  if ((inp -> next_addr_touse == laddr  ) && !(0))
+		    fprintf(stderr, "triggered bug index 579\n");
+		  else
+		    fprintf(stderr, "reached bug index 579\n");
+		}
+		if ((!FIXREVERTER[579] && (inp -> next_addr_touse == laddr  ))
+		#else
+		if (0
+		#endif
+		)
 			/* delete this address */
 			inp->next_addr_touse = NULL;
+			#ifdef FRCOV
+			}
+			#endif
 
 		/* clean up "last_used_address" */
 		LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
@@ -6410,8 +7044,23 @@ sctp_del_local_addr_restricted(struct sctp_tcb *stcb, struct sctp_ifa *ifa)
 	}
 	LIST_FOREACH(laddr, &stcb->asoc.sctp_restricted_addrs, sctp_nxt_addr) {
 		/* remove the address if it exists */
-		if (laddr->ifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[580]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 580\n");
+		  else
+		    fprintf(stderr, "reached bug index 580\n");
+		}
+		if ((!FIXREVERTER[580] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (laddr->ifa == ifa) {
 			sctp_remove_laddr(laddr);
 			return;
@@ -7247,12 +7896,42 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 		 * SCTP_PRINTF("ptype => %0x, plen => %d\n", (uint32_t)ptype,
 		 * (int)plen);
 		 */
-		if (offset + plen > limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[584]) {
+		  if ((offset + plen > limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 584\n");
+		  else
+		    fprintf(stderr, "reached bug index 584\n");
+		}
+		if ((!FIXREVERTER[584] && (offset + plen > limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
-		if (plen == 0) {
+		#ifdef FRCOV
+		}
+		#endif
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[585]) {
+		  if ((plen == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 585\n");
+		  else
+		    fprintf(stderr, "reached bug index 585\n");
+		}
+		if ((!FIXREVERTER[585] && (plen == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #ifdef INET
 		if (ptype == SCTP_IPV4_ADDRESS) {
 			if (stcb->asoc.scope.ipv4_addr_legal) {
@@ -7463,15 +8142,45 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			if (stcb->asoc.asconf_supported == 0) {
 				return (-100);
 			}
-			if (plen > sizeof(lstore)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[588]) {
+			  if ((plen > sizeof ( lstore ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 588\n");
+			  else
+			    fprintf(stderr, "reached bug index 588\n");
+			}
+			if ((!FIXREVERTER[588] && (plen > sizeof ( lstore ) ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-23);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)&lstore,
 						   plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[589]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 589\n");
+			  else
+			    fprintf(stderr, "reached bug index 589\n");
+			}
+			if ((!FIXREVERTER[589] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-24);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			fee = (struct sctp_asconf_addr_param *)phdr;
 			lptype = ntohs(fee->addrp.ph.param_type);
 			switch (lptype) {
@@ -7521,14 +8230,44 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			uint8_t local_store[SCTP_PARAM_BUFFER_SIZE];
 			int num_ent, i;
 
-			if (plen > sizeof(local_store)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[591]) {
+			  if ((plen > sizeof ( local_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 591\n");
+			  else
+			    fprintf(stderr, "reached bug index 591\n");
+			}
+			if ((!FIXREVERTER[591] && (plen > sizeof ( local_store ) ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-35);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)&local_store, plen);
-			if (phdr == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[592]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 592\n");
+			  else
+			    fprintf(stderr, "reached bug index 592\n");
+			}
+			if ((!FIXREVERTER[592] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (-25);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			pr_supported = (struct sctp_supported_chunk_types_param *)phdr;
 			num_ent = plen - sizeof(struct sctp_paramhdr);
 			for (i = 0; i < num_ent; i++) {
@@ -7564,8 +8303,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 				}
 			}
 		} else if (ptype == SCTP_RANDOM) {
-			if (plen > sizeof(random_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[593]) {
+			  if ((plen > sizeof ( random_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 593\n");
+			  else
+			    fprintf(stderr, "reached bug index 593\n");
+			}
+			if ((!FIXREVERTER[593] && (plen > sizeof ( random_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			if (got_random) {
 				/* already processed a RANDOM */
 				goto next_param;
@@ -7573,22 +8327,67 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)random_store,
 						   plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[594]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 594\n");
+			  else
+			    fprintf(stderr, "reached bug index 594\n");
+			}
+			if ((!FIXREVERTER[594] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return (-26);
+				#ifdef FRCOV
+				}
+				#endif
 			p_random = (struct sctp_auth_random *)phdr;
 			random_len = plen - sizeof(*p_random);
 			/* enforce the random length */
-			if (random_len != SCTP_AUTH_RANDOM_SIZE_REQUIRED) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[595]) {
+			  if ((random_len != 32 ) && !(0))
+			    fprintf(stderr, "triggered bug index 595\n");
+			  else
+			    fprintf(stderr, "reached bug index 595\n");
+			}
+			if ((!FIXREVERTER[595] && (random_len != 32 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTPDBG(SCTP_DEBUG_AUTH1, "SCTP: invalid RANDOM len\n");
 				return (-27);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			got_random = 1;
 		} else if (ptype == SCTP_HMAC_LIST) {
 			uint16_t num_hmacs;
 			uint16_t i;
 
-			if (plen > sizeof(hmacs_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[596]) {
+			  if ((plen > sizeof ( hmacs_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 596\n");
+			  else
+			    fprintf(stderr, "reached bug index 596\n");
+			}
+			if ((!FIXREVERTER[596] && (plen > sizeof ( hmacs_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			if (got_hmacs) {
 				/* already processed a HMAC list */
 				goto next_param;
@@ -7596,8 +8395,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)hmacs_store,
 						   plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[597]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 597\n");
+			  else
+			    fprintf(stderr, "reached bug index 597\n");
+			}
+			if ((!FIXREVERTER[597] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return (-28);
+				#ifdef FRCOV
+				}
+				#endif
 			hmacs = (struct sctp_auth_hmac_algo *)phdr;
 			hmacs_len = plen - sizeof(*hmacs);
 			num_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]);
@@ -7618,8 +8432,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 		} else if (ptype == SCTP_CHUNK_LIST) {
 			int i;
 
-			if (plen > sizeof(chunks_store))
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[598]) {
+			  if ((plen > sizeof ( chunks_store ) ) && !(0))
+			    fprintf(stderr, "triggered bug index 598\n");
+			  else
+			    fprintf(stderr, "reached bug index 598\n");
+			}
+			if ((!FIXREVERTER[598] && (plen > sizeof ( chunks_store ) ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			if (got_chklist) {
 				/* already processed a Chunks list */
 				goto next_param;
@@ -7627,8 +8456,23 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 			phdr = sctp_get_next_param(m, offset,
 						   (struct sctp_paramhdr *)chunks_store,
 						   plen);
-			if (phdr == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[599]) {
+			  if ((phdr == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 599\n");
+			  else
+			    fprintf(stderr, "reached bug index 599\n");
+			}
+			if ((!FIXREVERTER[599] && (phdr == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				return (-30);
+				#ifdef FRCOV
+				}
+				#endif
 			chunks = (struct sctp_auth_chunk_list *)phdr;
 			num_chunks = plen - sizeof(*chunks);
 			if (stcb->asoc.peer_auth_chunks != NULL)
@@ -7671,9 +8515,24 @@ sctp_load_addresses_from_init(struct sctp_tcb *stcb, struct mbuf *m,
 
 	next_param:
 		offset += SCTP_SIZE32(plen);
-		if (offset >= limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[600]) {
+		  if ((offset >= limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 600\n");
+		  else
+		    fprintf(stderr, "reached bug index 600\n");
+		}
+		if ((!FIXREVERTER[600] && (offset >= limit ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		phdr = sctp_get_next_param(m, offset, &param_buf,
 					   sizeof(param_buf));
 	}
@@ -7845,9 +8704,24 @@ sctp_is_vtag_good(uint32_t tag, uint16_t lport, uint16_t rport, struct timeval *
 		}
 		if (stcb->asoc.my_vtag == tag) {
 			/* candidate */
-			if (stcb->rport != rport) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[602]) {
+			  if ((stcb -> rport != rport ) && !(0))
+			    fprintf(stderr, "triggered bug index 602\n");
+			  else
+			    fprintf(stderr, "reached bug index 602\n");
+			}
+			if ((!FIXREVERTER[602] && (stcb -> rport != rport ))
+			#else
+			if (0
+			#endif
+			) {
 				continue;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (stcb->sctp_ep->sctp_lport != lport) {
 				continue;
 			}
@@ -8168,9 +9042,24 @@ sctp_initiate_iterator(inp_func inpf,
 {
 	struct sctp_iterator *it = NULL;
 
-	if (af == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[604]) {
+	  if ((af == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 604\n");
+	  else
+	    fprintf(stderr, "reached bug index 604\n");
+	}
+	if ((!FIXREVERTER[604] && (af == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (SCTP_BASE_VAR(sctp_pcb_initialized) == 0) {
 		SCTP_PRINTF("%s: abort on initialize being %d\n", __func__,
 		            SCTP_BASE_VAR(sctp_pcb_initialized));
@@ -8178,10 +9067,25 @@ sctp_initiate_iterator(inp_func inpf,
 	}
 	SCTP_MALLOC(it, struct sctp_iterator *, sizeof(struct sctp_iterator),
 		    SCTP_M_ITER);
-	if (it == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[605]) {
+	  if ((it == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 605\n");
+	  else
+	    fprintf(stderr, "reached bug index 605\n");
+	}
+	if ((!FIXREVERTER[605] && (it == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTP_PCB, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(it, 0, sizeof(*it));
 	it->function_assoc = af;
 	it->function_inp = inpf;
diff --git a/usrsctplib/netinet/sctp_timer.c b/usrsctplib/netinet/sctp_timer.c
index 98fafec..0185290 100755
--- a/usrsctplib/netinet/sctp_timer.c
+++ b/usrsctplib/netinet/sctp_timer.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -116,8 +120,22 @@ sctp_threshold_management(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				    stcb, 0,
 				    (void *)net, SCTP_SO_NOT_LOCKED);
 			}
-		} else if ((net->pf_threshold < net->failure_threshold) &&
-		           (net->error_count > net->pf_threshold)) {
+		} else 
+		#ifdef FRCOV
+		{if (FIXREVERTER[23]) {
+		  fprintf(stderr, "reached bug index 23\n");
+		}
+		if ((FIXREVERTER[23] && (net -> pf_threshold < net -> failure_threshold )) || (!FIXREVERTER[23] && (net -> pf_threshold < net -> failure_threshold && net -> error_count > net -> pf_threshold ))
+		#else
+		if (net -> pf_threshold < net -> failure_threshold 
+		#endif
+		) {
+		             
+		           #ifdef FRCOV
+		             if (!(net -> error_count > net -> pf_threshold ))
+		               fprintf(stderr, "triggered bug index 23\n");
+		             #endif
+		           
 			if (!(net->dest_state & SCTP_ADDR_PF)) {
 				net->dest_state |= SCTP_ADDR_PF;
 				net->last_active = sctp_get_tick_count();
@@ -128,9 +146,27 @@ sctp_threshold_management(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 			}
 		}
-	}
-	if (stcb == NULL)
+		#ifdef FRCOV
+		}
+		#endif
+	}
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[24]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 24\n");
+	  else
+	    fprintf(stderr, "reached bug index 24\n");
+	}
+	if ((!FIXREVERTER[24] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (net) {
 		if ((net->dest_state & SCTP_ADDR_UNCONFIRMED) == 0) {
@@ -228,11 +264,28 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 					} else if (mnet->error_count + 1 < min_errors) {
 						min_errors = mnet->error_count + 1;
 						min_errors_net = mnet;
-					} else if (mnet->error_count + 1 == min_errors
-								&& mnet->last_active > min_errors_net->last_active) {
+					} else 
+					#ifdef FRCOV
+					{if (FIXREVERTER[25]) {
+					  fprintf(stderr, "reached bug index 25\n");
+					}
+					if ((FIXREVERTER[25] && (mnet -> error_count + 1 == min_errors )) || (!FIXREVERTER[25] && (mnet -> error_count + 1 == min_errors && mnet -> last_active > min_errors_net -> last_active ))
+					#else
+					if (mnet -> error_count + 1 == min_errors 
+					#endif
+					) {
+								  
+								#ifdef FRCOV
+								  if (!(mnet -> last_active > min_errors_net -> last_active ))
+								    fprintf(stderr, "triggered bug index 25\n");
+								  #endif
+								
 						min_errors_net = mnet;
 						min_errors = mnet->error_count + 1;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					continue;
 				} else {
 					if (min_errors == -1) {
@@ -241,11 +294,28 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 					} else if (mnet->error_count < min_errors) {
 						min_errors = mnet->error_count;
 						min_errors_net = mnet;
-					} else if (mnet->error_count == min_errors
-								&& mnet->last_active > min_errors_net->last_active) {
+					} else 
+					#ifdef FRCOV
+					{if (FIXREVERTER[26]) {
+					  fprintf(stderr, "reached bug index 26\n");
+					}
+					if ((FIXREVERTER[26] && (mnet -> error_count == min_errors )) || (!FIXREVERTER[26] && (mnet -> error_count == min_errors && mnet -> last_active > min_errors_net -> last_active ))
+					#else
+					if (mnet -> error_count == min_errors 
+					#endif
+					) {
+								  
+								#ifdef FRCOV
+								  if (!(mnet -> last_active > min_errors_net -> last_active ))
+								    fprintf(stderr, "triggered bug index 26\n");
+								  #endif
+								
 						min_errors_net = mnet;
 						min_errors = mnet->error_count;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					continue;
 				}
 			}
@@ -280,9 +350,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 			}
 		}
 		if (max_cwnd_net == NULL) {
-			if (min_errors_net == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[27]) {
+			  if ((min_errors_net == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 27\n");
+			  else
+			    fprintf(stderr, "reached bug index 27\n");
+			}
+			if ((!FIXREVERTER[27] && (min_errors_net == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (net);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			return (min_errors_net);
 		} else {
 			return (max_cwnd_net);
@@ -332,9 +417,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 
 	if (mnet == NULL) {
 		mnet = TAILQ_FIRST(&stcb->asoc.nets);
-		if (mnet == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[28]) {
+		  if ((mnet == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 28\n");
+		  else
+		    fprintf(stderr, "reached bug index 28\n");
+		}
+		if ((!FIXREVERTER[28] && (mnet == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	for (;;) {
 		alt = TAILQ_NEXT(mnet, sctp_next);
@@ -344,9 +444,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 				break;
 			}
 			alt = TAILQ_FIRST(&stcb->asoc.nets);
-			if (alt == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[30]) {
+			  if ((alt == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 30\n");
+			  else
+			    fprintf(stderr, "reached bug index 30\n");
+			}
+			if ((!FIXREVERTER[30] && (alt == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (NULL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 		if (alt->ro.ro_rt == NULL) {
 			if (alt->ro._s_addr) {
@@ -370,9 +485,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 		once = 0;
 		mnet = net;
 		for (;;) {
-			if (mnet == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[31]) {
+			  if ((mnet == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 31\n");
+			  else
+			    fprintf(stderr, "reached bug index 31\n");
+			}
+			if ((!FIXREVERTER[31] && (mnet == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return (TAILQ_FIRST(&stcb->asoc.nets));
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			alt = TAILQ_NEXT(mnet, sctp_next);
 			if (alt == NULL) {
 				once++;
@@ -380,9 +510,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 					break;
 				}
 				alt = TAILQ_FIRST(&stcb->asoc.nets);
-				if (alt == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[33]) {
+				  if ((alt == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 33\n");
+				  else
+				    fprintf(stderr, "reached bug index 33\n");
+				}
+				if ((!FIXREVERTER[33] && (alt == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			}
 			if ((!(alt->dest_state & SCTP_ADDR_UNCONFIRMED)) &&
 			    (alt != net)) {
@@ -392,9 +537,24 @@ sctp_find_alternate_net(struct sctp_tcb *stcb,
 			mnet = alt;
 		}
 	}
-	if (alt == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[34]) {
+	  if ((alt == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 34\n");
+	  else
+	    fprintf(stderr, "reached bug index 34\n");
+	}
+	if ((!FIXREVERTER[34] && (alt == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (net);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	return (alt);
 }
 
@@ -1056,7 +1216,19 @@ sctp_cookie_timer(struct sctp_inpcb *inp,
 			break;
 		}
 	}
-	if (cookie == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[35]) {
+	  if ((cookie == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 35\n");
+	  else
+	    fprintf(stderr, "reached bug index 35\n");
+	}
+	if ((!FIXREVERTER[35] && (cookie == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		if (SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_ECHOED) {
 			/* FOOBAR! */
 			struct mbuf *op_err;
@@ -1075,6 +1247,9 @@ sctp_cookie_timer(struct sctp_inpcb *inp,
 		}
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Ok we found the cookie, threshold management next */
 	if (sctp_threshold_management(inp, stcb, cookie->whoTo,
 	    stcb->asoc.max_init_times)) {
@@ -1119,9 +1294,24 @@ sctp_strreset_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	}
 	/* find the existing STRRESET, we use the seq number we sent out on */
 	(void)sctp_find_stream_reset(stcb, stcb->asoc.str_reset_seq_out, &strrst);
-	if (strrst == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[36]) {
+	  if ((strrst == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 36\n");
+	  else
+	    fprintf(stderr, "reached bug index 36\n");
+	}
+	if ((!FIXREVERTER[36] && (strrst == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* do threshold management */
 	if (sctp_threshold_management(inp, stcb, strrst->whoTo,
 	    stcb->asoc.max_send_times)) {
@@ -1188,9 +1378,24 @@ sctp_asconf_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 
 		/* find the existing ASCONF */
 		asconf = TAILQ_FIRST(&stcb->asoc.asconf_send_queue);
-		if (asconf == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[37]) {
+		  if ((asconf == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 37\n");
+		  else
+		    fprintf(stderr, "reached bug index 37\n");
+		}
+		if ((!FIXREVERTER[37] && (asconf == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (0);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* do threshold management */
 		if (sctp_threshold_management(inp, stcb, asconf->whoTo,
 		    stcb->asoc.max_send_times)) {
@@ -1240,8 +1445,25 @@ sctp_asconf_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				chk->whoTo = alt;
 				atomic_add_int(&alt->ref_count, 1);
 			}
-			if (asconf->sent != SCTP_DATAGRAM_RESEND && chk->sent != SCTP_DATAGRAM_UNSENT)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[38]) {
+			  fprintf(stderr, "reached bug index 38\n");
+			}
+			if ((FIXREVERTER[38] && (asconf -> sent != 4 )) || (!FIXREVERTER[38] && (asconf -> sent != 4 && chk -> sent != 0 ))
+			#else
+			if (asconf -> sent != 4 
+			#endif
+			)
+				
+				#ifdef FRCOV
+				  {if (!(chk -> sent != 0 ))
+				    fprintf(stderr, "triggered bug index 38\n");
+				  #endif
 				sctp_ucount_incr(stcb->asoc.sent_queue_retran_cnt);
+				#ifdef FRCOV
+				}}
+				#endif
 			chk->sent = SCTP_DATAGRAM_RESEND;
 			chk->flags |= CHUNK_FLAGS_FRAGMENT_OK;
 		}
@@ -1344,8 +1566,23 @@ sctp_audit_stream_queues_for_size(struct sctp_inpcb *inp,
 	/*
 	 * This function is ONLY called when the send/sent queues are empty.
 	 */
-	if ((stcb == NULL) || (inp == NULL))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[39]) {
+	  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 39\n");
+	  else
+	    fprintf(stderr, "reached bug index 39\n");
+	}
+	if ((!FIXREVERTER[39] && (stcb == (void *) 0 || inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	if (stcb->asoc.sent_queue_retran_cnt) {
 		SCTP_PRINTF("Hmm, sent_queue_retran_cnt is non-zero %d\n",
@@ -1474,7 +1711,22 @@ sctp_pathmtu_timer(struct sctp_inpcb *inp,
 
 	next_mtu = sctp_get_next_mtu(net->mtu);
 
-	if ((next_mtu > net->mtu) && (net->port == 0)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[40]) {
+	  fprintf(stderr, "reached bug index 40\n");
+	}
+	if ((FIXREVERTER[40] && (next_mtu > net -> mtu )) || (!FIXREVERTER[40] && (next_mtu > net -> mtu && net -> port == 0 ))
+	#else
+	if (next_mtu > net -> mtu 
+	#endif
+	) {
+	  
+	#ifdef FRCOV
+	  if (!(net -> port == 0 ))
+	    fprintf(stderr, "triggered bug index 40\n");
+	  #endif
+	
 		if ((net->src_addr_selected == 0) ||
 		    (net->ro._s_addr == NULL) ||
 		    (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
@@ -1533,6 +1785,9 @@ sctp_pathmtu_timer(struct sctp_inpcb *inp,
 			}
 		}
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* restart the timer */
 	sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 }
diff --git a/usrsctplib/netinet/sctp_usrreq.c b/usrsctplib/netinet/sctp_usrreq.c
index dd5929d..20fc85d 100755
--- a/usrsctplib/netinet/sctp_usrreq.c
+++ b/usrsctplib/netinet/sctp_usrreq.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -677,7 +681,19 @@ sctp_abort(struct socket *so)
 	uint32_t flags;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[316]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 316\n");
+	  else
+	    fprintf(stderr, "reached bug index 316\n");
+	}
+	if ((!FIXREVERTER[316] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 #if defined(__FreeBSD__) && __FreeBSD_version > 690000
 		return;
 #else
@@ -685,6 +701,9 @@ sctp_abort(struct socket *so)
 		return (EINVAL);
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
  sctp_must_try_again:
 	flags = inp->sctp_flags;
@@ -796,20 +815,50 @@ sctp_bind(struct socket *so, struct mbuf *nam, struct proc *p)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[317]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 317\n");
+	  else
+	    fprintf(stderr, "reached bug index 317\n");
+	}
+	if ((!FIXREVERTER[317] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (addr != NULL) {
 #ifdef HAVE_SA_LEN
 		if ((addr->sa_family != AF_INET) ||
 		    (addr->sa_len != sizeof(struct sockaddr_in))) {
 #else
-		if (addr->sa_family != AF_INET) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[318]) {
+		  if ((addr -> sa_family != 2 ) && !(0))
+		    fprintf(stderr, "triggered bug index 318\n");
+		  else
+		    fprintf(stderr, "reached bug index 318\n");
+		}
+		if ((!FIXREVERTER[318] && (addr -> sa_family != 2 ))
+		#else
+		if (0
+		#endif
+		) {
 #endif
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	return (sctp_inpcb_bind(so, addr, NULL, p));
 }
@@ -856,20 +905,50 @@ sctpconn_bind(struct socket *so, struct sockaddr *addr)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[319]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 319\n");
+	  else
+	    fprintf(stderr, "reached bug index 319\n");
+	}
+	if ((!FIXREVERTER[319] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (addr != NULL) {
 #ifdef HAVE_SA_LEN
 		if ((addr->sa_family != AF_CONN) ||
 		    (addr->sa_len != sizeof(struct sockaddr_conn))) {
 #else
-		if (addr->sa_family != AF_CONN) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[320]) {
+		  if ((addr -> sa_family != 123 ) && !(0))
+		    fprintf(stderr, "triggered bug index 320\n");
+		  else
+		    fprintf(stderr, "reached bug index 320\n");
+		}
+		if ((!FIXREVERTER[320] && (addr -> sa_family != 123 ))
+		#else
+		if (0
+		#endif
+		) {
 #endif
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	return (sctp_inpcb_bind(so, addr, NULL, NULL));
 }
@@ -883,8 +962,23 @@ sctp_close(struct socket *so)
 	uint32_t flags;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[321]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 321\n");
+	  else
+	    fprintf(stderr, "reached bug index 321\n");
+	}
+	if ((!FIXREVERTER[321] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* Inform all the lower layer assoc that we
 	 * are done.
@@ -1126,10 +1220,25 @@ sctp_disconnect(struct socket *so)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[322]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 322\n");
+	  else
+	    fprintf(stderr, "reached bug index 322\n");
+	}
+	if ((!FIXREVERTER[322] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOTCONN);
 		return (ENOTCONN);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_RLOCK(inp);
 	if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 	    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {
@@ -1142,11 +1251,26 @@ sctp_disconnect(struct socket *so)
 			struct sctp_tcb *stcb;
 
 			stcb = LIST_FIRST(&inp->sctp_asoc_list);
-			if (stcb == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[323]) {
+			  if ((stcb == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 323\n");
+			  else
+			    fprintf(stderr, "reached bug index 323\n");
+			}
+			if ((!FIXREVERTER[323] && (stcb == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_INP_RUNLOCK(inp);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				return (EINVAL);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_TCB_LOCK(stcb);
 			asoc = &stcb->asoc;
 			if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
@@ -1580,9 +1704,24 @@ sctp_fill_up_addresses_vrf(struct sctp_inpcb *inp,
 		}
 	}
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[328]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 328\n");
+	  else
+	    fprintf(stderr, "reached bug index 328\n");
+	}
+	if ((!FIXREVERTER[328] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		LIST_FOREACH(sctp_ifn, &vrf->ifnlist, next_ifn) {
 			if ((loopback_scope == 0) &&
@@ -1777,9 +1916,24 @@ sctp_fill_up_addresses_vrf(struct sctp_inpcb *inp,
 				break;
 			}
 #endif
-			if (actual + sa_len > limit) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[330]) {
+			  if ((actual + sa_len > limit ) && !(0))
+			    fprintf(stderr, "triggered bug index 330\n");
+			  else
+			    fprintf(stderr, "reached bug index 330\n");
+			}
+			if ((!FIXREVERTER[330] && (actual + sa_len > limit ))
+			#else
+			if (0
+			#endif
+			) {
 				return (actual);
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if (sctp_fill_user_address(sas, &laddr->ifa->address.sa))
 				continue;
 			switch (laddr->ifa->address.sa.sa_family) {
@@ -1858,9 +2012,24 @@ sctp_count_max_addresses_vrf(struct sctp_inpcb *inp, uint32_t vrf_id)
 	 * addresses as well.
 	 */
 	vrf = sctp_find_vrf(vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[331]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 331\n");
+	  else
+	    fprintf(stderr, "reached bug index 331\n");
+	}
+	if ((!FIXREVERTER[331] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		struct sctp_ifn *sctp_ifn;
 		struct sctp_ifa *sctp_ifa;
@@ -2057,10 +2226,25 @@ sctp_do_connect_x(struct socket *so, struct sctp_inpcb *inp, void *optval,
 	                       (struct proc *)p,
 #endif
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[332]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 332\n");
+	  else
+	    fprintf(stderr, "reached bug index 332\n");
+	}
+	if ((!FIXREVERTER[332] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
@@ -2152,16 +2336,46 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 	int error, val = 0;
 	struct sctp_tcb *stcb = NULL;
 
-	if (optval == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[333]) {
+	  if ((optval == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 333\n");
+	  else
+	    fprintf(stderr, "reached bug index 333\n");
+	}
+	if ((!FIXREVERTER[333] && (optval == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[334]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 334\n");
+	  else
+	    fprintf(stderr, "reached bug index 334\n");
+	}
+	if ((!FIXREVERTER[334] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return EINVAL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	error = 0;
 
 	switch (optname) {
@@ -2501,11 +2715,26 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 		LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 			if (at < limit) {
 				ids->gaids_assoc_id[at++] = sctp_get_associd(stcb);
-				if (at == 0) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[335]) {
+				  if ((at == 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 335\n");
+				  else
+				    fprintf(stderr, "reached bug index 335\n");
+				}
+				if ((!FIXREVERTER[335] && (at == 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					error = EINVAL;
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 			} else {
 				error = EINVAL;
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
@@ -2914,13 +3143,43 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 					cpsz = 0;
 					break;
 				}
-				if (cpsz == 0) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[336]) {
+				  if ((cpsz == 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 336\n");
+				  else
+				    fprintf(stderr, "reached bug index 336\n");
+				}
+				if ((!FIXREVERTER[336] && (cpsz == 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					break;
 				}
-				if (left < cpsz) {
+				#ifdef FRCOV
+				}
+				#endif
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[337]) {
+				  if ((left < cpsz ) && !(0))
+				    fprintf(stderr, "triggered bug index 337\n");
+				  else
+				    fprintf(stderr, "reached bug index 337\n");
+				}
+				if ((!FIXREVERTER[337] && (left < cpsz ))
+				#else
+				if (0
+				#endif
+				) {
 					/* not enough room. */
 					break;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 #if defined(INET) && defined(INET6)
 				if ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_NEEDS_MAPPED_V4)) &&
 				    (net->ro._l_addr.sa.sa_family == AF_INET)) {
@@ -3287,11 +3546,26 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 		SCTP_CHECK_AND_CAST(sstat, optval, struct sctp_status, *optsize);
 		SCTP_FIND_STCB(inp, stcb, sstat->sstat_assoc_id);
 
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[338]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 338\n");
+		  else
+		    fprintf(stderr, "reached bug index 338\n");
+		}
+		if ((!FIXREVERTER[338] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sstat->sstat_state = sctp_map_assoc_state(stcb->asoc.state);
 		sstat->sstat_assoc_id = sctp_get_associd(stcb);
 		sstat->sstat_rwnd = stcb->asoc.peers_rwnd;
@@ -3559,12 +3833,27 @@ sctp_getopt(struct socket *so, int optname, void *optval, size_t *optsize,
 
 		SCTP_INP_RLOCK(inp);
 		hmaclist = inp->sctp_ep.local_hmacs;
-		if (hmaclist == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[339]) {
+		  if ((hmaclist == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 339\n");
+		  else
+		    fprintf(stderr, "reached bug index 339\n");
+		}
+		if ((!FIXREVERTER[339] && (hmaclist == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* no HMACs to return */
 			*optsize = sizeof(*shmac);
 			SCTP_INP_RUNLOCK(inp);
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* is there room for all of the hmac ids? */
 		size = sizeof(*shmac) + (hmaclist->num_algo *
 					 sizeof(shmac->shmac_idents[0]));
@@ -4472,15 +4761,45 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 	struct sctp_inpcb *inp = NULL;
 	uint32_t vrf_id;
 
-	if (optval == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[340]) {
+	  if ((optval == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 340\n");
+	  else
+	    fprintf(stderr, "reached bug index 340\n");
+	}
+	if ((!FIXREVERTER[340] && (optval == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[341]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 341\n");
+	  else
+	    fprintf(stderr, "reached bug index 341\n");
+	}
+	if ((!FIXREVERTER[341] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	vrf_id = inp->def_vrf_id;
 
 	error = 0;
@@ -4653,11 +4972,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			struct sctp_assoc_value *av;
 
 			SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
-			if (av->assoc_value > SCTP_CMT_MAX) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[342]) {
+			  if ((av -> assoc_value > 4 ) && !(0))
+			    fprintf(stderr, "triggered bug index 342\n");
+			  else
+			    fprintf(stderr, "reached bug index 342\n");
+			}
+			if ((!FIXREVERTER[342] && (av -> assoc_value > 4 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 			if (stcb) {
 				stcb->asoc.sctp_cmt_on_off = av->assoc_value;
@@ -5038,8 +5372,23 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 		SCTP_CHECK_AND_CAST(sack, optval, struct sctp_sack_info, optsize);
 		SCTP_FIND_STCB(inp, stcb, sack->sack_assoc_id);
 		if (sack->sack_delay) {
-			if (sack->sack_delay > SCTP_MAX_SACK_DELAY)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[343]) {
+			  if ((sack -> sack_delay > 500  ) && !(0))
+			    fprintf(stderr, "triggered bug index 343\n");
+			  else
+			    fprintf(stderr, "reached bug index 343\n");
+			}
+			if ((!FIXREVERTER[343] && (sack -> sack_delay > 500  ))
+			#else
+			if (0
+			#endif
+			)
 				sack->sack_delay = SCTP_MAX_SACK_DELAY;
+				#ifdef FRCOV
+				}
+				#endif
 			if (MSEC_TO_TICKS(sack->sack_delay) < 1) {
 				sack->sack_delay = TICKS_TO_MSEC(1);
 			}
@@ -5203,17 +5552,47 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					 */
 					if (size > 0) {
 						key = sctp_set_key(sca->sca_key, (uint32_t) size);
-						if (key == NULL) {
+						
+						#ifdef FRCOV
+						{if (FIXREVERTER[344]) {
+						  if ((key == (void *) 0 ) && !(0))
+						    fprintf(stderr, "triggered bug index 344\n");
+						  else
+						    fprintf(stderr, "reached bug index 344\n");
+						}
+						if ((!FIXREVERTER[344] && (key == (void *) 0 ))
+						#else
+						if (0
+						#endif
+						) {
 							SCTP_TCB_UNLOCK(stcb);
 							continue;
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					shared_key = sctp_alloc_sharedkey();
-					if (shared_key == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[345]) {
+					  if ((shared_key == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 345\n");
+					  else
+					    fprintf(stderr, "reached bug index 345\n");
+					}
+					if ((!FIXREVERTER[345] && (shared_key == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						sctp_free_key(key);
 						SCTP_TCB_UNLOCK(stcb);
 						continue;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					shared_key->key = key;
 					shared_key->keyid = sca->sca_keynumber;
 					error = sctp_insert_sharedkey(shared_keys, shared_key);
@@ -5240,11 +5619,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 		}
 
 		hmaclist = sctp_alloc_hmaclist((uint16_t)shmac->shmac_number_of_idents);
-		if (hmaclist == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[346]) {
+		  if ((hmaclist == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 346\n");
+		  else
+		    fprintf(stderr, "reached bug index 346\n");
+		}
+		if ((!FIXREVERTER[346] && (hmaclist == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 			error = ENOMEM;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		for (i = 0; i < shmac->shmac_number_of_idents; i++) {
 			hmacid = shmac->shmac_idents[i];
 			if (sctp_auth_add_hmacid(hmaclist, hmacid)) {
@@ -5443,11 +5837,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 
 		SCTP_CHECK_AND_CAST(strrst, optval, struct sctp_reset_streams, optsize);
 		SCTP_FIND_STCB(inp, stcb, strrst->srs_assoc_id);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[347]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 347\n");
+		  else
+		    fprintf(stderr, "reached bug index 347\n");
+		}
+		if ((!FIXREVERTER[347] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
@@ -5561,11 +5970,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 
 		SCTP_CHECK_AND_CAST(stradd, optval, struct sctp_add_streams, optsize);
 		SCTP_FIND_STCB(inp, stcb, stradd->sas_assoc_id);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[348]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 348\n");
+		  else
+		    fprintf(stderr, "reached bug index 348\n");
+		}
+		if ((!FIXREVERTER[348] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
@@ -5634,11 +6058,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 
 		SCTP_CHECK_AND_CAST(value, optval, uint32_t, optsize);
 		SCTP_FIND_STCB(inp, stcb, (sctp_assoc_t) *value);
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[350]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 350\n");
+		  else
+		    fprintf(stderr, "reached bug index 350\n");
+		}
+		if ((!FIXREVERTER[350] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 		        SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
@@ -5723,11 +6162,26 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			}
 		}
 
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[351]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 351\n");
+		  else
+		    fprintf(stderr, "reached bug index 351\n");
+		}
+		if ((!FIXREVERTER[351] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.delayed_connection == 1) {
 			stcb->asoc.delayed_connection = 0;
 			(void)SCTP_GETTIME_TIMEVAL(&stcb->asoc.time_entered);
@@ -6215,8 +6669,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							net->dest_state &= ~SCTP_ADDR_PF;
 						}
 					} else {
-						if ((net->error_count <= paddrp->spp_pathmaxrxt) &&
-						    (net->error_count > net->pf_threshold)) {
+						
+						#ifdef FRCOV
+						{if (FIXREVERTER[352]) {
+						  fprintf(stderr, "reached bug index 352\n");
+						}
+						if ((FIXREVERTER[352] && (net -> error_count <= paddrp -> spp_pathmaxrxt )) || (!FIXREVERTER[352] && (net -> error_count <= paddrp -> spp_pathmaxrxt && net -> error_count > net -> pf_threshold ))
+						#else
+						if (net -> error_count <= paddrp -> spp_pathmaxrxt 
+						#endif
+						) {
+						      
+						    #ifdef FRCOV
+						      if (!(net -> error_count > net -> pf_threshold ))
+						        fprintf(stderr, "triggered bug index 352\n");
+						      #endif
+						    
 							net->dest_state |= SCTP_ADDR_PF;
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -6224,6 +6692,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					if (net->dest_state & SCTP_ADDR_REACHABLE) {
 						if (net->error_count > paddrp->spp_pathmaxrxt) {
@@ -6260,8 +6731,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								net->dest_state &= ~SCTP_ADDR_PF;
 							}
 						} else {
-							if ((net->error_count <= paddrp->spp_pathmaxrxt) &&
-							    (net->error_count > net->pf_threshold)) {
+							
+							#ifdef FRCOV
+							{if (FIXREVERTER[353]) {
+							  fprintf(stderr, "reached bug index 353\n");
+							}
+							if ((FIXREVERTER[353] && (net -> error_count <= paddrp -> spp_pathmaxrxt )) || (!FIXREVERTER[353] && (net -> error_count <= paddrp -> spp_pathmaxrxt && net -> error_count > net -> pf_threshold ))
+							#else
+							if (net -> error_count <= paddrp -> spp_pathmaxrxt 
+							#endif
+							) {
+							      
+							    #ifdef FRCOV
+							      if (!(net -> error_count > net -> pf_threshold ))
+							        fprintf(stderr, "triggered bug index 353\n");
+							      #endif
+							    
 								net->dest_state |= SCTP_ADDR_PF;
 								sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -6269,6 +6754,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
 								sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 							}
+							#ifdef FRCOV
+							}
+							#endif
 						}
 						if (net->dest_state & SCTP_ADDR_REACHABLE) {
 							if (net->error_count > paddrp->spp_pathmaxrxt) {
@@ -6403,8 +6891,23 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO)
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = 0;
 				else if (paddrp->spp_hbinterval != 0) {
-					if (paddrp->spp_hbinterval > SCTP_MAX_HB_INTERVAL)
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[354]) {
+					  if ((paddrp -> spp_hbinterval > 14400000  ) && !(0))
+					    fprintf(stderr, "triggered bug index 354\n");
+					  else
+					    fprintf(stderr, "reached bug index 354\n");
+					}
+					if ((!FIXREVERTER[354] && (paddrp -> spp_hbinterval > 14400000  ))
+					#else
+					if (0
+					#endif
+					)
 						paddrp->spp_hbinterval= SCTP_MAX_HB_INTERVAL;
+						#ifdef FRCOV
+						}
+						#endif
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = MSEC_TO_TICKS(paddrp->spp_hbinterval);
 				}
 
@@ -6468,7 +6971,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				new_min = srto->srto_min;
 			else
 				new_min = stcb->asoc.minrto;
-			if ((new_min <= new_init) && (new_init <= new_max)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[355]) {
+			  fprintf(stderr, "reached bug index 355\n");
+			}
+			if ((FIXREVERTER[355] && (new_min <= new_init )) || (!FIXREVERTER[355] && (new_min <= new_init && new_init <= new_max ))
+			#else
+			if (new_min <= new_init 
+			#endif
+			) {
+			  
+			#ifdef FRCOV
+			  if (!(new_init <= new_max ))
+			    fprintf(stderr, "triggered bug index 355\n");
+			  #endif
+			
 				stcb->asoc.initial_rto = new_init;
 				stcb->asoc.maxrto = new_max;
 				stcb->asoc.minrto = new_min;
@@ -6476,6 +6994,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
@@ -6494,7 +7015,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					new_min = srto->srto_min;
 				else
 					new_min = inp->sctp_ep.sctp_minrto;
-				if ((new_min <= new_init) && (new_init <= new_max)) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[356]) {
+				  fprintf(stderr, "reached bug index 356\n");
+				}
+				if ((FIXREVERTER[356] && (new_min <= new_init )) || (!FIXREVERTER[356] && (new_min <= new_init && new_init <= new_max ))
+				#else
+				if (new_min <= new_init 
+				#endif
+				) {
+				  
+				#ifdef FRCOV
+				  if (!(new_init <= new_max ))
+				    fprintf(stderr, "triggered bug index 356\n");
+				  #endif
+				
 					inp->sctp_ep.initial_rto = new_init;
 					inp->sctp_ep.sctp_maxrto = new_max;
 					inp->sctp_ep.sctp_minrto = new_min;
@@ -6502,6 +7038,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
@@ -6518,8 +7057,23 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 		SCTP_FIND_STCB(inp, stcb, sasoc->sasoc_assoc_id);
 		if (sasoc->sasoc_cookie_life) {
 			/* boundary check the cookie life */
-			if (sasoc->sasoc_cookie_life < 1000)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[357]) {
+			  if ((sasoc -> sasoc_cookie_life < 1000  ) && !(0))
+			    fprintf(stderr, "triggered bug index 357\n");
+			  else
+			    fprintf(stderr, "reached bug index 357\n");
+			}
+			if ((!FIXREVERTER[357] && (sasoc -> sasoc_cookie_life < 1000  ))
+			#else
+			if (0
+			#endif
+			)
 				sasoc->sasoc_cookie_life = 1000;
+				#ifdef FRCOV
+				}
+				#endif
 			if (sasoc->sasoc_cookie_life > SCTP_MAX_COOKIE_LIFE) {
 				sasoc->sasoc_cookie_life = SCTP_MAX_COOKIE_LIFE;
 			}
@@ -6725,22 +7279,52 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			addr = (struct sockaddr *)&sspp->sspp_addr;
 #endif
 			ifa = sctp_find_ifa_by_addr(addr, stcb->asoc.vrf_id, SCTP_ADDR_NOT_LOCKED);
-			if (ifa == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[358]) {
+			  if ((ifa == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 358\n");
+			  else
+			    fprintf(stderr, "reached bug index 358\n");
+			}
+			if ((!FIXREVERTER[358] && (ifa == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				goto out_of_it;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {
 				/* Must validate the ifa found is in our ep */
 				struct sctp_laddr *laddr;
 				int found = 0;
 
 				LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-					if (laddr->ifa == NULL) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[359]) {
+					  if ((laddr -> ifa == (void *) 0 ) && !(0))
+					    fprintf(stderr, "triggered bug index 359\n");
+					  else
+					    fprintf(stderr, "reached bug index 359\n");
+					}
+					if ((!FIXREVERTER[359] && (laddr -> ifa == (void *) 0 ))
+					#else
+					if (0
+					#endif
+					) {
 						SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 							__func__);
 						continue;
 					}
+					#ifdef FRCOV
+					}
+					#endif
 					if ((sctp_is_addr_restricted(stcb, laddr->ifa)) &&
 					    (!sctp_is_addr_pending(stcb, laddr->ifa))) {
 						continue;
@@ -7282,8 +7866,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						net->dest_state &= ~SCTP_ADDR_PF;
 					}
 				} else {
-					if ((net->error_count > net->pf_threshold) &&
-					    (net->error_count <= net->failure_threshold)) {
+					
+					#ifdef FRCOV
+					{if (FIXREVERTER[360]) {
+					  fprintf(stderr, "reached bug index 360\n");
+					}
+					if ((FIXREVERTER[360] && (net -> error_count > net -> pf_threshold )) || (!FIXREVERTER[360] && (net -> error_count > net -> pf_threshold && net -> error_count <= net -> failure_threshold ))
+					#else
+					if (net -> error_count > net -> pf_threshold 
+					#endif
+					) {
+					      
+					    #ifdef FRCOV
+					      if (!(net -> error_count <= net -> failure_threshold ))
+					        fprintf(stderr, "triggered bug index 360\n");
+					      #endif
+					    
 						net->dest_state |= SCTP_ADDR_PF;
 						sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -7291,6 +7889,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 					}
+					#ifdef FRCOV
+					}
+					#endif
 				}
 				if (net->dest_state & SCTP_ADDR_REACHABLE) {
 					if (net->error_count > net->failure_threshold) {
@@ -7313,8 +7914,22 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							net->dest_state &= ~SCTP_ADDR_PF;
 						}
 					} else {
-						if ((net->error_count > net->pf_threshold) &&
-						    (net->error_count <= net->failure_threshold)) {
+						
+						#ifdef FRCOV
+						{if (FIXREVERTER[361]) {
+						  fprintf(stderr, "reached bug index 361\n");
+						}
+						if ((FIXREVERTER[361] && (net -> error_count > net -> pf_threshold )) || (!FIXREVERTER[361] && (net -> error_count > net -> pf_threshold && net -> error_count <= net -> failure_threshold ))
+						#else
+						if (net -> error_count > net -> pf_threshold 
+						#endif
+						) {
+						      
+						    #ifdef FRCOV
+						      if (!(net -> error_count <= net -> failure_threshold ))
+						        fprintf(stderr, "triggered bug index 361\n");
+						      #endif
+						    
 							net->dest_state |= SCTP_ADDR_PF;
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
@@ -7322,6 +7937,9 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
+						#ifdef FRCOV
+						}
+						#endif
 					}
 					if (net->dest_state & SCTP_ADDR_REACHABLE) {
 						if (net->error_count > net->failure_threshold) {
@@ -7853,15 +8471,45 @@ sctp_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 	struct sctp_tcb *stcb = NULL;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[362]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 362\n");
+	  else
+	    fprintf(stderr, "reached bug index 362\n");
+	}
+	if ((!FIXREVERTER[362] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* I made the same as TCP since we are not setup? */
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (ECONNRESET);
 	}
-	if (addr == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[363]) {
+	  if ((addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 363\n");
+	  else
+	    fprintf(stderr, "reached bug index 363\n");
+	}
+	if ((!FIXREVERTER[363] && (addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return EINVAL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #if defined(__Userspace__)
         /* TODO __Userspace__ falls into this code for IPv6 stuff at the moment... */
@@ -8010,10 +8658,25 @@ sctp_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 	                       inp->sctp_ep.pre_open_stream_count,
 	                       inp->sctp_ep.port, p,
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[364]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 364\n");
+	  else
+	    fprintf(stderr, "reached bug index 364\n");
+	}
+	if ((!FIXREVERTER[364] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
@@ -8049,15 +8712,45 @@ sctpconn_connect(struct socket *so, struct sockaddr *addr)
 	struct sctp_tcb *stcb = NULL;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[365]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 365\n");
+	  else
+	    fprintf(stderr, "reached bug index 365\n");
+	}
+	if ((!FIXREVERTER[365] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* I made the same as TCP since we are not setup? */
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (ECONNRESET);
 	}
-	if (addr == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[366]) {
+	  if ((addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 366\n");
+	  else
+	    fprintf(stderr, "reached bug index 366\n");
+	}
+	if ((!FIXREVERTER[366] && (addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return EINVAL;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	switch (addr->sa_family) {
 #ifdef INET
 	case AF_INET:
@@ -8175,10 +8868,25 @@ sctpconn_connect(struct socket *so, struct sockaddr *addr)
 	                       inp->sctp_ep.pre_open_stream_count,
 	                       inp->sctp_ep.port, p,
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[367]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 367\n");
+	  else
+	    fprintf(stderr, "reached bug index 367\n");
+	}
+	if ((!FIXREVERTER[367] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		goto out_now;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
@@ -9029,9 +9737,24 @@ register_recv_cb(struct socket *so,
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *) so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[378]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 378\n");
+	  else
+	    fprintf(stderr, "reached bug index 378\n");
+	}
+	if ((!FIXREVERTER[378] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_WLOCK(inp);
 	inp->recv_callback = receive_cb;
 	SCTP_INP_WUNLOCK(inp);
@@ -9044,9 +9767,24 @@ register_send_cb(struct socket *so, uint32_t sb_threshold, int (*send_cb)(struct
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *) so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[379]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 379\n");
+	  else
+	    fprintf(stderr, "reached bug index 379\n");
+	}
+	if ((!FIXREVERTER[379] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_WLOCK(inp);
 	inp->send_callback = send_cb;
 	inp->send_sb_threshold = sb_threshold;
@@ -9065,9 +9803,24 @@ register_ulp_info (struct socket *so, void *ulp_info)
 	struct sctp_inpcb *inp;
 
 	inp = (struct sctp_inpcb *) so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[380]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 380\n");
+	  else
+	    fprintf(stderr, "reached bug index 380\n");
+	}
+	if ((!FIXREVERTER[380] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_INP_WLOCK(inp);
 	inp->ulp_info = ulp_info;
 	SCTP_INP_WUNLOCK(inp);
diff --git a/usrsctplib/netinet/sctputil.c b/usrsctplib/netinet/sctputil.c
index a350574..c365e86 100755
--- a/usrsctplib/netinet/sctputil.c
+++ b/usrsctplib/netinet/sctputil.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -974,10 +978,25 @@ sctp_select_a_tag(struct sctp_inpcb *inp, uint16_t lport, uint16_t rport, int ch
 	}
 	for (;;) {
 		x = sctp_select_initial_TSN(&inp->sctp_ep);
-		if (x == 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[409]) {
+		  if ((x == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 409\n");
+		  else
+		    fprintf(stderr, "reached bug index 409\n");
+		}
+		if ((!FIXREVERTER[409] && (x == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* we never use 0 */
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (!check || sctp_is_vtag_good(x, lport, rport, &now)) {
 			break;
 		}
@@ -1208,11 +1227,26 @@ sctp_init_asoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	SCTP_MALLOC(asoc->strmout, struct sctp_stream_out *,
 		    asoc->streamoutcnt * sizeof(struct sctp_stream_out),
 		    SCTP_M_STRMO);
-	if (asoc->strmout == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[410]) {
+	  if ((asoc -> strmout == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 410\n");
+	  else
+	    fprintf(stderr, "reached bug index 410\n");
+	}
+	if ((!FIXREVERTER[410] && (asoc -> strmout == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* big trouble no memory */
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTPUTIL, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	for (i = 0; i < asoc->streamoutcnt; i++) {
 		/*
 		 * inbound side must be set to 0xffff, also NOTE when we get
@@ -1246,11 +1280,26 @@ sctp_init_asoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	asoc->mapping_array_size = SCTP_INITIAL_MAPPING_ARRAY;
 	SCTP_MALLOC(asoc->mapping_array, uint8_t *, asoc->mapping_array_size,
 		    SCTP_M_MAP);
-	if (asoc->mapping_array == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[411]) {
+	  if ((asoc -> mapping_array == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 411\n");
+	  else
+	    fprintf(stderr, "reached bug index 411\n");
+	}
+	if ((!FIXREVERTER[411] && (asoc -> mapping_array == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_FREE(asoc->strmout, SCTP_M_STRMO);
 		SCTP_LTRACE_ERR_RET(NULL, stcb, NULL, SCTP_FROM_SCTPUTIL, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(asoc->mapping_array, 0, asoc->mapping_array_size);
 	SCTP_MALLOC(asoc->nr_mapping_array, uint8_t *, asoc->mapping_array_size,
 	    SCTP_M_MAP);
@@ -1567,7 +1616,19 @@ sctp_handle_addr_wq(void)
 
 	SCTP_MALLOC(asc, struct sctp_asconf_iterator *,
 		    sizeof(struct sctp_asconf_iterator), SCTP_M_ASC_IT);
-	if (asc == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[417]) {
+	  if ((asc == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 417\n");
+	  else
+	    fprintf(stderr, "reached bug index 417\n");
+	}
+	if ((!FIXREVERTER[417] && (asc == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Try later, no memory */
 		sctp_timer_start(SCTP_TIMER_TYPE_ADDR_WQ,
 				 (struct sctp_inpcb *)NULL,
@@ -1575,6 +1636,9 @@ sctp_handle_addr_wq(void)
 				 (struct sctp_nets *)NULL);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	LIST_INIT(&asc->list_of_work);
 	asc->cnt = 0;
 
@@ -1780,9 +1844,24 @@ sctp_timeout_handler(void *t)
 		sctp_handle_addr_wq();
 		break;
 	case SCTP_TIMER_TYPE_SEND:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[418]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 418\n");
+		  else
+		    fprintf(stderr, "reached bug index 418\n");
+		}
+		if ((!FIXREVERTER[418] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timodata);
 		stcb->asoc.timodata++;
 		stcb->asoc.num_send_timers_up--;
@@ -1816,9 +1895,24 @@ sctp_timeout_handler(void *t)
 		}
 		break;
 	case SCTP_TIMER_TYPE_INIT:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[419]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 419\n");
+		  else
+		    fprintf(stderr, "reached bug index 419\n");
+		}
+		if ((!FIXREVERTER[419] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoinit);
 		stcb->asoc.timoinit++;
 		if (sctp_t1init_timer(inp, stcb, net)) {
@@ -1829,9 +1923,24 @@ sctp_timeout_handler(void *t)
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_RECV:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[420]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 420\n");
+		  else
+		    fprintf(stderr, "reached bug index 420\n");
+		}
+		if ((!FIXREVERTER[420] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timosack);
 		stcb->asoc.timosack++;
 		sctp_send_sack(stcb, SCTP_SO_NOT_LOCKED);
@@ -1841,9 +1950,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_SACK_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWN:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[421]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 421\n");
+		  else
+		    fprintf(stderr, "reached bug index 421\n");
+		}
+		if ((!FIXREVERTER[421] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_shutdown_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1856,9 +1980,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_SHUT_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_HEARTBEAT:
-		if ((stcb == NULL) || (inp == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[422]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 422\n");
+		  else
+		    fprintf(stderr, "reached bug index 422\n");
+		}
+		if ((!FIXREVERTER[422] && (stcb == (void *) 0 || inp == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoheartbeat);
 		stcb->asoc.timoheartbeat++;
 		if (sctp_heartbeat_timer(inp, stcb, net)) {
@@ -1874,9 +2013,24 @@ sctp_timeout_handler(void *t)
 		}
 		break;
 	case SCTP_TIMER_TYPE_COOKIE:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[423]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 423\n");
+		  else
+		    fprintf(stderr, "reached bug index 423\n");
+		}
+		if ((!FIXREVERTER[423] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		if (sctp_cookie_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
@@ -1897,9 +2051,24 @@ sctp_timeout_handler(void *t)
 		{
 			struct timeval tv;
 			int i, secret;
-			if (inp == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[424]) {
+			  if ((inp == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 424\n");
+			  else
+			    fprintf(stderr, "reached bug index 424\n");
+			}
+			if ((!FIXREVERTER[424] && (inp == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				break;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			SCTP_STAT_INCR(sctps_timosecret);
 			(void)SCTP_GETTIME_TIMEVAL(&tv);
 			inp->sctp_ep.time_of_secret_change = tv.tv_sec;
@@ -1920,17 +2089,47 @@ sctp_timeout_handler(void *t)
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_PATHMTURAISE:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[425]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 425\n");
+		  else
+		    fprintf(stderr, "reached bug index 425\n");
+		}
+		if ((!FIXREVERTER[425] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timopathmtu);
 		sctp_pathmtu_timer(inp, stcb, net);
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNACK:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[426]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 426\n");
+		  else
+		    fprintf(stderr, "reached bug index 426\n");
+		}
+		if ((!FIXREVERTER[426] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_shutdownack_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1943,9 +2142,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_SHUT_ACK_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNGUARD:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[427]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 427\n");
+		  else
+		    fprintf(stderr, "reached bug index 427\n");
+		}
+		if ((!FIXREVERTER[427] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoshutdownguard);
 		op_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),
 		                             "Shutdown guard timer expired");
@@ -1954,9 +2168,24 @@ sctp_timeout_handler(void *t)
 		goto out_decr;
 
 	case SCTP_TIMER_TYPE_STRRESET:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[428]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 428\n");
+		  else
+		    fprintf(stderr, "reached bug index 428\n");
+		}
+		if ((!FIXREVERTER[428] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_strreset_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1965,9 +2194,24 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_STRRST_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_ASCONF:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[429]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 429\n");
+		  else
+		    fprintf(stderr, "reached bug index 429\n");
+		}
+		if ((!FIXREVERTER[429] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (sctp_asconf_timer(inp, stcb, net)) {
 			/* no need to unlock on tcb its gone */
 			goto out_decr;
@@ -1979,26 +2223,71 @@ sctp_timeout_handler(void *t)
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_ASCONF_TMR, SCTP_SO_NOT_LOCKED);
 		break;
 	case SCTP_TIMER_TYPE_PRIM_DELETED:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[430]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 430\n");
+		  else
+		    fprintf(stderr, "reached bug index 430\n");
+		}
+		if ((!FIXREVERTER[430] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		sctp_delete_prim_timer(inp, stcb, net);
 		SCTP_STAT_INCR(sctps_timodelprim);
 		break;
 
 	case SCTP_TIMER_TYPE_AUTOCLOSE:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[431]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 431\n");
+		  else
+		    fprintf(stderr, "reached bug index 431\n");
+		}
+		if ((!FIXREVERTER[431] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoautoclose);
 		sctp_autoclose_timer(inp, stcb, net);
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_AUTOCLOSE_TMR, SCTP_SO_NOT_LOCKED);
 		did_output = 0;
 		break;
 	case SCTP_TIMER_TYPE_ASOCKILL:
-		if ((stcb == NULL) || (inp == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[432]) {
+		  if ((stcb == (void *) 0 || inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 432\n");
+		  else
+		    fprintf(stderr, "reached bug index 432\n");
+		}
+		if ((!FIXREVERTER[432] && (stcb == (void *) 0 || inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_STAT_INCR(sctps_timoassockill);
 		/* Can we free it yet? */
 		SCTP_INP_DECR_REF(inp);
@@ -2025,9 +2314,24 @@ sctp_timeout_handler(void *t)
 		goto out_no_decr;
 	case SCTP_TIMER_TYPE_INPKILL:
 		SCTP_STAT_INCR(sctps_timoinpkill);
-		if (inp == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[433]) {
+		  if ((inp == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 433\n");
+		  else
+		    fprintf(stderr, "reached bug index 433\n");
+		}
+		if ((!FIXREVERTER[433] && (inp == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/*
 		 * special case, take away our increment since WE are the
 		 * killer
@@ -2122,9 +2426,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		{
 			int rto_val;
 
-			if ((stcb == NULL) || (net == NULL)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[434]) {
+			  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 434\n");
+			  else
+			    fprintf(stderr, "reached bug index 434\n");
+			}
+			if ((!FIXREVERTER[434] && (stcb == (void *) 0 || net == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				return;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 			tmr = &net->rxt_timer;
 			if (net->RTO == 0) {
 				rto_val = stcb->asoc.initial_rto;
@@ -2139,9 +2458,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the INIT timer default usually about 1
 		 * minute.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[435]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 435\n");
+		  else
+		    fprintf(stderr, "reached bug index 435\n");
+		}
+		if ((!FIXREVERTER[435] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
@@ -2154,17 +2488,47 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the Delayed-Ack timer value from the inp
 		 * ususually about 200ms.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[436]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 436\n");
+		  else
+		    fprintf(stderr, "reached bug index 436\n");
+		}
+		if ((!FIXREVERTER[436] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.dack_timer;
 		to_ticks = MSEC_TO_TICKS(stcb->asoc.delayed_ack);
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWN:
 		/* Here we use the RTO of the destination. */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[437]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 437\n");
+		  else
+		    fprintf(stderr, "reached bug index 437\n");
+		}
+		if ((!FIXREVERTER[437] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2218,9 +2582,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * RTT was compelete. If a retran happened then we will be
 		 * using the RTO initial value.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[438]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 438\n");
+		  else
+		    fprintf(stderr, "reached bug index 438\n");
+		}
+		if ((!FIXREVERTER[438] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2237,9 +2616,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		to_ticks = inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_SIGNATURE];
 		break;
 	case SCTP_TIMER_TYPE_ASOCKILL:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[439]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 439\n");
+		  else
+		    fprintf(stderr, "reached bug index 439\n");
+		}
+		if ((!FIXREVERTER[439] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.strreset_timer;
 		to_ticks = MSEC_TO_TICKS(SCTP_ASOC_KILL_TIMEOUT);
 		break;
@@ -2257,9 +2651,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the value found in the EP for PMTU ususually
 		 * about 10 minutes.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[440]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 440\n");
+		  else
+		    fprintf(stderr, "reached bug index 440\n");
+		}
+		if ((!FIXREVERTER[440] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->dest_state & SCTP_ADDR_NO_PMTUD) {
 			return;
 		}
@@ -2268,9 +2677,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNACK:
 		/* Here we use the RTO of the destination */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[441]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 441\n");
+		  else
+		    fprintf(stderr, "reached bug index 441\n");
+		}
+		if ((!FIXREVERTER[441] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2283,9 +2707,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here we use the endpoints shutdown guard timer usually
 		 * about 3 minutes.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[442]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 442\n");
+		  else
+		    fprintf(stderr, "reached bug index 442\n");
+		}
+		if ((!FIXREVERTER[442] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_MAXSHUTDOWN] == 0) {
 			to_ticks = 5 * MSEC_TO_TICKS(stcb->asoc.maxrto);
 		} else {
@@ -2298,9 +2737,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here the timer comes from the stcb but its value is from
 		 * the net's RTO.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[443]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 443\n");
+		  else
+		    fprintf(stderr, "reached bug index 443\n");
+		}
+		if ((!FIXREVERTER[443] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2313,9 +2767,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		 * Here the timer comes from the stcb but its value is from
 		 * the net's RTO.
 		 */
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[444]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 444\n");
+		  else
+		    fprintf(stderr, "reached bug index 444\n");
+		}
+		if ((!FIXREVERTER[444] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (net->RTO == 0) {
 			to_ticks = MSEC_TO_TICKS(stcb->asoc.initial_rto);
 		} else {
@@ -2331,9 +2800,24 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		tmr = &stcb->asoc.delete_prim_timer;
 		break;
 	case SCTP_TIMER_TYPE_AUTOCLOSE:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[445]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 445\n");
+		  else
+		    fprintf(stderr, "reached bug index 445\n");
+		}
+		if ((!FIXREVERTER[445] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (stcb->asoc.sctp_autoclose_ticks == 0) {
 			/*
 			 * Really an error since stcb is NOT set to
@@ -2350,11 +2834,26 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		return;
 		break;
 	}
-	if ((to_ticks <= 0) || (tmr == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[446]) {
+	  if ((to_ticks <= 0 || tmr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 446\n");
+	  else
+	    fprintf(stderr, "reached bug index 446\n");
+	}
+	if ((!FIXREVERTER[446] && (to_ticks <= 0 || tmr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTPDBG(SCTP_DEBUG_TIMER1, "%s: %d:software error to_ticks:%d tmr:%p not set ??\n",
 			__func__, t_type, to_ticks, (void *)tmr);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (SCTP_OS_TIMER_PENDING(&tmr->timer)) {
 		/*
 		 * we do NOT allow you to have it already running. if it is
@@ -2401,39 +2900,129 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		tmr = &SCTP_BASE_INFO(addr_wq_timer);
 		break;
 	case SCTP_TIMER_TYPE_SEND:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[447]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 447\n");
+		  else
+		    fprintf(stderr, "reached bug index 447\n");
+		}
+		if ((!FIXREVERTER[447] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_INIT:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[448]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 448\n");
+		  else
+		    fprintf(stderr, "reached bug index 448\n");
+		}
+		if ((!FIXREVERTER[448] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_RECV:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[449]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 449\n");
+		  else
+		    fprintf(stderr, "reached bug index 449\n");
+		}
+		if ((!FIXREVERTER[449] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.dack_timer;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWN:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[450]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 450\n");
+		  else
+		    fprintf(stderr, "reached bug index 450\n");
+		}
+		if ((!FIXREVERTER[450] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_HEARTBEAT:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[451]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 451\n");
+		  else
+		    fprintf(stderr, "reached bug index 451\n");
+		}
+		if ((!FIXREVERTER[451] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->hb_timer;
 		break;
 	case SCTP_TIMER_TYPE_COOKIE:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[452]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 452\n");
+		  else
+		    fprintf(stderr, "reached bug index 452\n");
+		}
+		if ((!FIXREVERTER[452] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_NEWCOOKIE:
@@ -2448,9 +3037,24 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		/*
 		 * Stop the asoc kill timer.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[453]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 453\n");
+		  else
+		    fprintf(stderr, "reached bug index 453\n");
+		}
+		if ((!FIXREVERTER[453] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.strreset_timer;
 		break;
 
@@ -2463,45 +3067,150 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		tmr = &inp->sctp_ep.signature_change;
 		break;
 	case SCTP_TIMER_TYPE_PATHMTURAISE:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[454]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 454\n");
+		  else
+		    fprintf(stderr, "reached bug index 454\n");
+		}
+		if ((!FIXREVERTER[454] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->pmtu_timer;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNACK:
-		if ((stcb == NULL) || (net == NULL)) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[455]) {
+		  if ((stcb == (void *) 0 || net == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 455\n");
+		  else
+		    fprintf(stderr, "reached bug index 455\n");
+		}
+		if ((!FIXREVERTER[455] && (stcb == (void *) 0 || net == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &net->rxt_timer;
 		break;
 	case SCTP_TIMER_TYPE_SHUTDOWNGUARD:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[456]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 456\n");
+		  else
+		    fprintf(stderr, "reached bug index 456\n");
+		}
+		if ((!FIXREVERTER[456] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.shut_guard_timer;
 		break;
 	case SCTP_TIMER_TYPE_STRRESET:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[457]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 457\n");
+		  else
+		    fprintf(stderr, "reached bug index 457\n");
+		}
+		if ((!FIXREVERTER[457] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.strreset_timer;
 		break;
 	case SCTP_TIMER_TYPE_ASCONF:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[458]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 458\n");
+		  else
+		    fprintf(stderr, "reached bug index 458\n");
+		}
+		if ((!FIXREVERTER[458] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.asconf_timer;
 		break;
 	case SCTP_TIMER_TYPE_PRIM_DELETED:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[459]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 459\n");
+		  else
+		    fprintf(stderr, "reached bug index 459\n");
+		}
+		if ((!FIXREVERTER[459] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.delete_prim_timer;
 		break;
 	case SCTP_TIMER_TYPE_AUTOCLOSE:
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[460]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 460\n");
+		  else
+		    fprintf(stderr, "reached bug index 460\n");
+		}
+		if ((!FIXREVERTER[460] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		tmr = &stcb->asoc.autoclose_timer;
 		break;
 	default:
@@ -2509,9 +3218,24 @@ sctp_timer_stop(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 			__func__, t_type);
 		break;
 	}
-	if (tmr == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[461]) {
+	  if ((tmr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 461\n");
+	  else
+	    fprintf(stderr, "reached bug index 461\n");
+	}
+	if ((!FIXREVERTER[461] && (tmr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((tmr->type != t_type) && tmr->type) {
 		/*
 		 * Ok we have a timer that is under joint use. Cookie timer
@@ -2615,10 +3339,25 @@ sctp_calculate_rto(struct sctp_tcb *stcb,
 	}
 	timevalsub(&now, old);
 	rtt_us = (uint64_t)1000000 * (uint64_t)now.tv_sec + (uint64_t)now.tv_usec;
-	if (rtt_us > SCTP_RTO_UPPER_BOUND * 1000) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[462]) {
+	  if ((rtt_us > 60000 * 1000 ) && !(0))
+	    fprintf(stderr, "triggered bug index 462\n");
+	  else
+	    fprintf(stderr, "reached bug index 462\n");
+	}
+	if ((!FIXREVERTER[462] && (rtt_us > 60000 * 1000 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* The RTT is larger than a sane value. */
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* store the current RTT in us */
 	net->rtt = rtt_us;
 	/* compute rtt in ms */
@@ -2707,8 +3446,23 @@ sctp_m_getptr(struct mbuf *m, int off, int len, uint8_t * in_ptr)
 	uint8_t *ptr;
 
 	ptr = in_ptr;
-	if ((off < 0) || (len <= 0))
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[463]) {
+	  if ((off < 0 ) && !(len <= 0 ))
+	    fprintf(stderr, "triggered bug index 463\n");
+	  else
+	    fprintf(stderr, "reached bug index 463\n");
+	}
+	if ((FIXREVERTER[463] && (len <= 0 )) || (!FIXREVERTER[463] && (off < 0 || len <= 0 ))
+	#else
+	if (len <= 0 
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* find the desired start location */
 	while ((m != NULL) && (off > 0)) {
@@ -2760,9 +3514,24 @@ sctp_add_pad_tombuf(struct mbuf *m, int padlen)
 	struct mbuf *m_last;
 	caddr_t dp;
 
-	if (padlen > 3) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[465]) {
+	  if ((padlen > 3 ) && !(0))
+	    fprintf(stderr, "triggered bug index 465\n");
+	  else
+	    fprintf(stderr, "reached bug index 465\n");
+	}
+	if ((!FIXREVERTER[465] && (padlen > 3 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (padlen <= M_TRAILINGSPACE(m)) {
 		/*
 		 * The easy way. We hope the majority of the time we hit
@@ -2772,9 +3541,24 @@ sctp_add_pad_tombuf(struct mbuf *m, int padlen)
 	} else {
 		/* Hard way we must grow the mbuf chain */
 		m_last = sctp_get_mbuf_for_msg(padlen, 0, M_NOWAIT, 1, MT_DATA);
-		if (m_last == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[466]) {
+		  if ((m_last == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 466\n");
+		  else
+		    fprintf(stderr, "reached bug index 466\n");
+		}
+		if ((!FIXREVERTER[466] && (m_last == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_BUF_LEN(m_last) = 0;
 		SCTP_BUF_NEXT(m_last) = NULL;
 		SCTP_BUF_NEXT(m) = m_last;
@@ -2821,9 +3605,24 @@ sctp_notify_assoc_change(uint16_t state, struct sctp_tcb *stcb,
 	struct socket *so;
 #endif
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[467]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 467\n");
+	  else
+	    fprintf(stderr, "reached bug index 467\n");
+	}
+	if ((!FIXREVERTER[467] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVASSOCEVNT)) {
 		notif_len = (unsigned int)sizeof(struct sctp_assoc_change);
 		if (abort != NULL) {
@@ -2848,9 +3647,24 @@ sctp_notify_assoc_change(uint16_t state, struct sctp_tcb *stcb,
 			/* Retry with smaller value. */
 			notif_len = (unsigned int)sizeof(struct sctp_assoc_change);
 			m_notify = sctp_get_mbuf_for_msg(notif_len, 0, M_NOWAIT, 1, MT_DATA);
-			if (m_notify == NULL) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[468]) {
+			  if ((m_notify == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 468\n");
+			  else
+			    fprintf(stderr, "reached bug index 468\n");
+			}
+			if ((!FIXREVERTER[468] && (m_notify == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			) {
 				goto set_error;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 		SCTP_BUF_NEXT(m_notify) = NULL;
 		sac = mtod(m_notify, struct sctp_assoc_change *);
@@ -2982,8 +3796,23 @@ sctp_notify_peer_addr_change(struct sctp_tcb *stcb, uint32_t state,
 		return;
 	}
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_paddr_change), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[470]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 470\n");
+	  else
+	    fprintf(stderr, "reached bug index 470\n");
+	}
+	if ((!FIXREVERTER[470] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	spc = mtod(m_notify, struct sctp_paddr_change *);
 	memset(spc, 0, sizeof(struct sctp_paddr_change));
@@ -3053,11 +3882,26 @@ sctp_notify_peer_addr_change(struct sctp_tcb *stcb, uint32_t state,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[471]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 471\n");
+	  else
+	    fprintf(stderr, "reached bug index 471\n");
+	}
+	if ((!FIXREVERTER[471] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3098,9 +3942,24 @@ sctp_notify_send_failed(struct sctp_tcb *stcb, uint8_t sent, uint32_t error,
 		notifhdr_len = sizeof(struct sctp_send_failed);
 	}
 	m_notify = sctp_get_mbuf_for_msg(notifhdr_len, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[472]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 472\n");
+	  else
+	    fprintf(stderr, "reached bug index 472\n");
+	}
+	if ((!FIXREVERTER[472] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = notifhdr_len;
 	if (stcb->asoc.idata_supported) {
 		chkhdr_len = sizeof(struct sctp_idata_chunk);
@@ -3118,12 +3977,28 @@ sctp_notify_send_failed(struct sctp_tcb *stcb, uint8_t sent, uint32_t error,
 		chkhdr = mtod(chk->data, struct sctp_chunkhdr *);
 		if (chkhdr != NULL) {
 			chk_len = ntohs(chkhdr->chunk_length);
-			if ((chk_len >= chkhdr_len) &&
-			    (chk->send_size >= chk_len) &&
-			    (chk->send_size - chk_len < 4)) {
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[473]) {
+			  fprintf(stderr, "reached bug index 473\n");
+			}
+			if ((FIXREVERTER[473] && (chk_len >= chkhdr_len && chk -> send_size >= chk_len )) || (!FIXREVERTER[473] && (chk_len >= chkhdr_len && chk -> send_size >= chk_len && chk -> send_size - chk_len < 4 ))
+			#else
+			if (chk_len >= chkhdr_len && chk -> send_size >= chk_len 
+			#endif
+			) {
+			      
+			    #ifdef FRCOV
+			      if (!(chk -> send_size - chk_len < 4 ))
+			        fprintf(stderr, "triggered bug index 473\n");
+			      #endif
+			    
 				padding_len = chk->send_size - chk_len;
 				payload_len = chk->send_size - chkhdr_len - padding_len;
 			}
+			#ifdef FRCOV
+			}
+			#endif
 		}
 	}
 	if (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVNSENDFAILEVNT)) {
@@ -3189,11 +4064,26 @@ sctp_notify_send_failed(struct sctp_tcb *stcb, uint8_t sent, uint32_t error,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[474]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 474\n");
+	  else
+	    fprintf(stderr, "reached bug index 474\n");
+	}
+	if ((!FIXREVERTER[474] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3232,10 +4122,25 @@ sctp_notify_send_failed2(struct sctp_tcb *stcb, uint32_t error,
 		notifhdr_len = sizeof(struct sctp_send_failed);
 	}
 	m_notify = sctp_get_mbuf_for_msg(notifhdr_len, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[475]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 475\n");
+	  else
+	    fprintf(stderr, "reached bug index 475\n");
+	}
+	if ((!FIXREVERTER[475] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no space left */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(m_notify) = notifhdr_len;
 	if (sctp_stcb_is_feature_on(stcb->sctp_ep, stcb, SCTP_PCB_FLAGS_RECVNSENDFAILEVNT)) {
 		ssfe = mtod(m_notify, struct sctp_send_failed_event *);
@@ -3292,11 +4197,26 @@ sctp_notify_send_failed2(struct sctp_tcb *stcb, uint32_t error,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[476]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 476\n");
+	  else
+	    fprintf(stderr, "reached bug index 476\n");
+	}
+	if ((!FIXREVERTER[476] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3322,9 +4242,24 @@ sctp_notify_adaptation_layer(struct sctp_tcb *stcb)
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_adaption_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[477]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 477\n");
+	  else
+	    fprintf(stderr, "reached bug index 477\n");
+	}
+	if ((!FIXREVERTER[477] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	sai = mtod(m_notify, struct sctp_adaptation_event *);
 	memset(sai, 0, sizeof(struct sctp_adaptation_event));
@@ -3341,11 +4276,26 @@ sctp_notify_adaptation_layer(struct sctp_tcb *stcb)
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[478]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 478\n");
+	  else
+	    fprintf(stderr, "reached bug index 478\n");
+	}
+	if ((!FIXREVERTER[478] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3379,9 +4329,24 @@ sctp_notify_partial_delivery_indication(struct sctp_tcb *stcb, uint32_t error,
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_pdapi_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[479]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 479\n");
+	  else
+	    fprintf(stderr, "reached bug index 479\n");
+	}
+	if ((!FIXREVERTER[479] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	pdapi = mtod(m_notify, struct sctp_pdapi_event *);
 	memset(pdapi, 0, sizeof(struct sctp_pdapi_event));
@@ -3398,11 +4363,26 @@ sctp_notify_partial_delivery_indication(struct sctp_tcb *stcb, uint32_t error,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 					 0, 0, stcb->asoc.context, 0, 0, 0,
 					 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[480]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 480\n");
+	  else
+	    fprintf(stderr, "reached bug index 480\n");
+	}
+	if ((!FIXREVERTER[480] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3488,9 +4468,24 @@ sctp_notify_shutdown_event(struct sctp_tcb *stcb)
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_shutdown_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[481]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 481\n");
+	  else
+	    fprintf(stderr, "reached bug index 481\n");
+	}
+	if ((!FIXREVERTER[481] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	sse = mtod(m_notify, struct sctp_shutdown_event *);
 	memset(sse, 0, sizeof(struct sctp_shutdown_event));
 	sse->sse_type = SCTP_SHUTDOWN_EVENT;
@@ -3505,11 +4500,26 @@ sctp_notify_shutdown_event(struct sctp_tcb *stcb)
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[482]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 482\n");
+	  else
+	    fprintf(stderr, "reached bug index 482\n");
+	}
+	if ((!FIXREVERTER[482] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3538,10 +4548,25 @@ sctp_notify_sender_dry_event(struct sctp_tcb *stcb,
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_sender_dry_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[483]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 483\n");
+	  else
+	    fprintf(stderr, "reached bug index 483\n");
+	}
+	if ((!FIXREVERTER[483] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no space left */
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	event = mtod(m_notify, struct sctp_sender_dry_event *);
 	memset(event, 0, sizeof(struct sctp_sender_dry_event));
@@ -3557,11 +4582,26 @@ sctp_notify_sender_dry_event(struct sctp_tcb *stcb,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[484]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 484\n");
+	  else
+	    fprintf(stderr, "reached bug index 484\n");
+	}
+	if ((!FIXREVERTER[484] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3590,9 +4630,24 @@ sctp_notify_stream_reset_add(struct sctp_tcb *stcb, uint16_t numberin, uint16_t
 	}
 	stcb->asoc.peer_req_out = 0;
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_stream_change_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[485]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 485\n");
+	  else
+	    fprintf(stderr, "reached bug index 485\n");
+	}
+	if ((!FIXREVERTER[485] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	stradd = mtod(m_notify, struct sctp_stream_change_event *);
 	memset(stradd, 0, sizeof(struct sctp_stream_change_event));
@@ -3613,11 +4668,26 @@ sctp_notify_stream_reset_add(struct sctp_tcb *stcb, uint16_t numberin, uint16_t
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[486]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 486\n");
+	  else
+	    fprintf(stderr, "reached bug index 486\n");
+	}
+	if ((!FIXREVERTER[486] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3640,9 +4710,24 @@ sctp_notify_stream_reset_tsn(struct sctp_tcb *stcb, uint32_t sending_tsn, uint32
 		return;
 	}
 	m_notify = sctp_get_mbuf_for_msg(sizeof(struct sctp_assoc_reset_event), 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[487]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 487\n");
+	  else
+	    fprintf(stderr, "reached bug index 487\n");
+	}
+	if ((!FIXREVERTER[487] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	strasoc = mtod(m_notify, struct sctp_assoc_reset_event  *);
 	memset(strasoc, 0, sizeof(struct sctp_assoc_reset_event));
@@ -3663,11 +4748,26 @@ sctp_notify_stream_reset_tsn(struct sctp_tcb *stcb, uint32_t sending_tsn, uint32
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[488]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 488\n");
+	  else
+	    fprintf(stderr, "reached bug index 488\n");
+	}
+	if ((!FIXREVERTER[488] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3695,9 +4795,24 @@ sctp_notify_stream_reset(struct sctp_tcb *stcb,
 	}
 
 	m_notify = sctp_get_mbuf_for_msg(MCLBYTES, 0, M_NOWAIT, 1, MT_DATA);
-	if (m_notify == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[489]) {
+	  if ((m_notify == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 489\n");
+	  else
+	    fprintf(stderr, "reached bug index 489\n");
+	}
+	if ((!FIXREVERTER[489] && (m_notify == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		/* no space left */
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	SCTP_BUF_LEN(m_notify) = 0;
 	len = sizeof(struct sctp_stream_reset_event) + (number_entries * sizeof(uint16_t));
 	if (len > M_TRAILINGSPACE(m_notify)) {
@@ -3729,11 +4844,26 @@ sctp_notify_stream_reset(struct sctp_tcb *stcb,
 	control = sctp_build_readq_entry(stcb, stcb->asoc.primary_destination,
 	                                 0, 0, stcb->asoc.context, 0, 0, 0,
 	                                 m_notify);
-	if (control == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[490]) {
+	  if ((control == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 490\n");
+	  else
+	    fprintf(stderr, "reached bug index 490\n");
+	}
+	if ((!FIXREVERTER[490] && (control == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no memory */
 		sctp_m_freem(m_notify);
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	control->length = SCTP_BUF_LEN(m_notify);
 	control->spec_flags = M_NOTIFICATION;
 	/* not that we need this */
@@ -3775,9 +4905,24 @@ sctp_notify_remote_error(struct sctp_tcb *stcb, uint16_t error, struct sctp_erro
 		/* Retry with smaller value. */
 		notif_len = (unsigned int)sizeof(struct sctp_remote_error);
 		m_notify = sctp_get_mbuf_for_msg(notif_len, 0, M_NOWAIT, 1, MT_DATA);
-		if (m_notify == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[491]) {
+		  if ((m_notify == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 491\n");
+		  else
+		    fprintf(stderr, "reached bug index 491\n");
+		}
+		if ((!FIXREVERTER[491] && (m_notify == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			return;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 	}
 	SCTP_BUF_NEXT(m_notify) = NULL;
 	sre = mtod(m_notify, struct sctp_remote_error *);
@@ -4029,9 +5174,24 @@ sctp_report_all_outbound(struct sctp_tcb *stcb, uint16_t error, int holds_lock,
 	struct sctp_stream_queue_pending *sp, *nsp;
 	int i;
 
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[494]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 494\n");
+	  else
+	    fprintf(stderr, "reached bug index 494\n");
+	}
+	if ((!FIXREVERTER[494] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	asoc = &stcb->asoc;
 	if (asoc->state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 		/* already being freed */
@@ -4143,9 +5303,24 @@ sctp_abort_notification(struct sctp_tcb *stcb, uint8_t from_peer, uint16_t error
 #endif
     )
 {
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[495]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 495\n");
+	  else
+	    fprintf(stderr, "reached bug index 495\n");
+	}
+	if ((!FIXREVERTER[495] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__APPLE__)
 	if (so_locked) {
 		sctp_lock_assert(SCTP_INP_SO(stcb->sctp_ep));
@@ -4521,8 +5696,23 @@ sctp_is_same_scope(struct sockaddr_in6 *addr1, struct sockaddr_in6 *addr2)
 	if (a.sin6_scope_id != b.sin6_scope_id)
 		return (0);
 #else
-	if (addr1->sin6_scope_id != addr2->sin6_scope_id)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[496]) {
+	  if ((addr1 -> sin6_scope_id != addr2 -> sin6_scope_id ) && !(0))
+	    fprintf(stderr, "triggered bug index 496\n");
+	  else
+	    fprintf(stderr, "reached bug index 496\n");
+	}
+	if ((!FIXREVERTER[496] && (addr1 -> sin6_scope_id != addr2 -> sin6_scope_id ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 #endif /* SCTP_EMBEDDED_V6_SCOPE */
 
 	return (1);
@@ -4569,12 +5759,42 @@ sctp_cmpaddr(struct sockaddr *sa1, struct sockaddr *sa2)
 {
 
 	/* must be valid */
-	if (sa1 == NULL || sa2 == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[497]) {
+	  if ((sa1 == (void *) 0 || sa2 == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 497\n");
+	  else
+	    fprintf(stderr, "reached bug index 497\n");
+	}
+	if ((!FIXREVERTER[497] && (sa1 == (void *) 0 || sa2 == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	/* must be the same family */
-	if (sa1->sa_family != sa2->sa_family)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[498]) {
+	  if ((sa1 -> sa_family != sa2 -> sa_family ) && !(0))
+	    fprintf(stderr, "triggered bug index 498\n");
+	  else
+	    fprintf(stderr, "reached bug index 498\n");
+	}
+	if ((!FIXREVERTER[498] && (sa1 -> sa_family != sa2 -> sa_family ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	switch (sa1->sa_family) {
 #ifdef INET6
@@ -4945,13 +6165,28 @@ sctp_add_to_readq(struct sctp_inpcb *inp,
 	 */
 	struct mbuf *m, *prev = NULL;
 
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[500]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 500\n");
+	  else
+	    fprintf(stderr, "reached bug index 500\n");
+	}
+	if ((!FIXREVERTER[500] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak, TSNH!! */
 #ifdef INVARIANTS
 		panic("Gak, inp NULL on add_to_readq");
 #endif
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if defined(__APPLE__)
 	if (so_locked) {
 		sctp_lock_assert(SCTP_INP_SO(inp));
@@ -5053,9 +6288,24 @@ sctp_generate_cause(uint16_t code, char *info)
 	size_t info_len;
 	uint16_t len;
 
-	if ((code == 0) || (info == NULL)) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[501]) {
+	  if ((info == (void *) 0 ) && !(code == 0 ))
+	    fprintf(stderr, "triggered bug index 501\n");
+	  else
+	    fprintf(stderr, "reached bug index 501\n");
+	}
+	if ((FIXREVERTER[501] && (code == 0 )) || (!FIXREVERTER[501] && (code == 0 || info == (void *) 0 ))
+	#else
+	if (code == 0 
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	info_len = strlen(info);
 	if (info_len > (SCTP_MAX_CAUSE_LENGTH - sizeof(struct sctp_paramhdr))) {
 		return (NULL);
@@ -5271,7 +6521,19 @@ sctp_release_pr_sctp_chunk(struct sctp_tcb *stcb, struct sctp_tmit_chunk *tp1,
 			if (chk == NULL) {
 				/* Yep, we have to */
 				sctp_alloc_a_chunk(stcb, chk);
-				if (chk == NULL) {
+				
+				#ifdef FRCOV
+				{if (FIXREVERTER[503]) {
+				  if ((chk == (void *) 0 ) && !(0))
+				    fprintf(stderr, "triggered bug index 503\n");
+				  else
+				    fprintf(stderr, "reached bug index 503\n");
+				}
+				if ((!FIXREVERTER[503] && (chk == (void *) 0 ))
+				#else
+				if (0
+				#endif
+				) {
 					/* we are hosed. All we can
 					 * do is nothing.. which will
 					 * cause an abort if the peer is
@@ -5279,6 +6541,9 @@ sctp_release_pr_sctp_chunk(struct sctp_tcb *stcb, struct sctp_tmit_chunk *tp1,
 					 */
 					goto oh_well;
 				}
+				#ifdef FRCOV
+				}
+				#endif
 				memset(chk, 0, sizeof(*chk));
 				chk->rec.data.rcv_flags = 0;
 				chk->sent = SCTP_FORWARD_TSN_SKIP;
@@ -5389,8 +6654,23 @@ sctp_find_ifa_in_ep(struct sctp_inpcb *inp, struct sockaddr *addr,
 	}
 
 	LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
-		if (laddr->ifa == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[504]) {
+		  if ((laddr -> ifa == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 504\n");
+		  else
+		    fprintf(stderr, "reached bug index 504\n");
+		}
+		if ((!FIXREVERTER[504] && (laddr -> ifa == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			continue;
+			#ifdef FRCOV
+			}
+			#endif
 		if (addr->sa_family != laddr->ifa->address.sa.sa_family)
 			continue;
 #ifdef INET
@@ -5575,8 +6855,23 @@ sctp_user_rcvd(struct sctp_tcb *stcb, uint32_t *freed_so_far, int hold_rlock,
 	uint32_t dif, rwnd;
 	struct socket *so = NULL;
 
-	if (stcb == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[506]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 506\n");
+	  else
+	    fprintf(stderr, "reached bug index 506\n");
+	}
+	if ((!FIXREVERTER[506] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 
 	atomic_add_int(&stcb->asoc.refcnt, 1);
 
@@ -5591,9 +6886,24 @@ sctp_user_rcvd(struct sctp_tcb *stcb, uint32_t *freed_so_far, int hold_rlock,
 		goto out;
 	}
 	so = stcb->sctp_socket;
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[507]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 507\n");
+	  else
+	    fprintf(stderr, "reached bug index 507\n");
+	}
+	if ((!FIXREVERTER[507] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		goto out;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	atomic_add_int(&stcb->freed_by_sorcv_sincelast, *freed_so_far);
 	/* Have you have freed enough to look */
 	*freed_so_far = 0;
@@ -5691,10 +7001,25 @@ sctp_sorecvmsg(struct socket *so,
 	int sockbuf_lock = 0;
 #endif
 
-	if (uio == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[508]) {
+	  if ((uio == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 508\n");
+	  else
+	    fprintf(stderr, "reached bug index 508\n");
+	}
+	if ((!FIXREVERTER[508] && (uio == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTPUTIL, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (msg_flags) {
 		in_flags = *msg_flags;
@@ -5732,10 +7057,25 @@ sctp_sorecvmsg(struct socket *so,
 	}
 	/* setup the endpoint */
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[509]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 509\n");
+	  else
+	    fprintf(stderr, "reached bug index 509\n");
+	}
+	if ((!FIXREVERTER[509] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTPUTIL, EFAULT);
 		return (EFAULT);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	rwnd_req = (SCTP_SB_LIMIT_RCV(so) >> SCTP_RWND_HIWAT_SHIFT);
 	/* Must be at least a MTU's worth */
 	if (rwnd_req < SCTP_MIN_RWND)
@@ -6047,8 +7387,23 @@ sctp_sorecvmsg(struct socket *so,
 	if (stcb) {
 		if ((control->do_not_ref_stcb == 0) &&
 		    (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED)) {
-			if (freecnt_applied == 0)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[511]) {
+			  if ((freecnt_applied == 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 511\n");
+			  else
+			    fprintf(stderr, "reached bug index 511\n");
+			}
+			if ((!FIXREVERTER[511] && (freecnt_applied == 0 ))
+			#else
+			if (0
+			#endif
+			)
 				stcb = NULL;
+				#ifdef FRCOV
+				}
+				#endif
 		} else if (control->do_not_ref_stcb == 0) {
 			/* you can't free it on me please */
 			/*
@@ -6699,7 +8054,19 @@ sctp_sorecvmsg(struct socket *so,
 		 * the sender uses the tcb_lock to increment, we need to use
 		 * the atomic add to the refcnt.
 		 */
-		if (stcb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[515]) {
+		  if ((stcb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 515\n");
+		  else
+		    fprintf(stderr, "reached bug index 515\n");
+		}
+		if ((!FIXREVERTER[515] && (stcb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 #ifdef INVARIANTS
 			panic("stcb for refcnt has gone NULL?");
 			goto stage_left;
@@ -6707,6 +8074,9 @@ sctp_sorecvmsg(struct socket *so,
 			goto stage_left;
 #endif
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		/* Save the value back for next time */
 		stcb->freed_by_sorcv_sincelast = freed_so_far;
 		atomic_add_int(&stcb->asoc.refcnt, -1);
@@ -6779,18 +8149,48 @@ sctp_dynamic_set_primary(struct sockaddr *sa, uint32_t vrf_id)
 	struct sctp_laddr *wi;
 
 	ifa = sctp_find_ifa_by_addr(sa, vrf_id, 0);
-	if (ifa == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[516]) {
+	  if ((ifa == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 516\n");
+	  else
+	    fprintf(stderr, "reached bug index 516\n");
+	}
+	if ((!FIXREVERTER[516] && (ifa == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTPUTIL, EADDRNOTAVAIL);
 		return (EADDRNOTAVAIL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now that we have the ifa we must awaken the
 	 * iterator with this message.
 	 */
 	wi = SCTP_ZONE_GET(SCTP_BASE_INFO(ipi_zone_laddr), struct sctp_laddr);
-	if (wi == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[517]) {
+	  if ((wi == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 517\n");
+	  else
+	    fprintf(stderr, "reached bug index 517\n");
+	}
+	if ((!FIXREVERTER[517] && (wi == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(NULL, NULL, NULL, SCTP_FROM_SCTPUTIL, ENOMEM);
 		return (ENOMEM);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Now incr the count and int wi structure */
 	SCTP_INCR_LADDR_COUNT();
 	memset(wi, 0, sizeof(*wi));
@@ -6996,8 +8396,23 @@ sctp_hashinit_flags(int elements, struct malloc_type *type,
 	}
 
 	/* no memory? */
-	if (hashtbl == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[519]) {
+	  if ((hashtbl == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 519\n");
+	  else
+	    fprintf(stderr, "reached bug index 519\n");
+	}
+	if ((!FIXREVERTER[519] && (hashtbl == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 
 	for (i = 0; i < hashsize; i++)
 		LIST_INIT(&hashtbl[i]);
@@ -7202,9 +8617,24 @@ sctp_connectx_helper_find(struct sctp_inpcb *inp, struct sockaddr *addr,
 		default:
 			return (EINVAL);
 		}
-		if ((at + incr) > limit) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[521]) {
+		  if ((at + incr > limit ) && !(0))
+		    fprintf(stderr, "triggered bug index 521\n");
+		  else
+		    fprintf(stderr, "reached bug index 521\n");
+		}
+		if ((!FIXREVERTER[521] && (at + incr > limit ))
+		#else
+		if (0
+		#endif
+		) {
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		SCTP_INP_INCR_REF(inp);
 		stcb = sctp_findassociation_ep_addr(&inp, sa, NULL, NULL, NULL);
 		if (stcb != NULL) {
@@ -7521,11 +8951,26 @@ sctp_local_addr_count(struct sctp_tcb *stcb)
 #endif
 	SCTP_IPI_ADDR_RLOCK();
 	vrf = sctp_find_vrf(stcb->asoc.vrf_id);
-	if (vrf == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[522]) {
+	  if ((vrf == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 522\n");
+	  else
+	    fprintf(stderr, "reached bug index 522\n");
+	}
+	if ((!FIXREVERTER[522] && (vrf == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* no vrf, no addresses */
 		SCTP_IPI_ADDR_RUNLOCK();
 		return (0);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 		/*
diff --git a/usrsctplib/netinet6/meson.build b/usrsctplib/netinet6/meson.build
old mode 100644
new mode 100755
diff --git a/usrsctplib/netinet6/sctp6_usrreq.c b/usrsctplib/netinet6/sctp6_usrreq.c
old mode 100644
new mode 100755
index e9c3bfb..df0e8c0
--- a/usrsctplib/netinet6/sctp6_usrreq.c
+++ b/usrsctplib/netinet6/sctp6_usrreq.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -710,7 +714,19 @@ sctp6_abort(struct socket *so)
 	uint32_t flags;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[615]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 615\n");
+	  else
+	    fprintf(stderr, "reached bug index 615\n");
+	}
+	if ((!FIXREVERTER[615] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 #if (defined(__FreeBSD__) && __FreeBSD_version > 690000) || defined(__Windows__)
 		return;
@@ -718,6 +734,9 @@ sctp6_abort(struct socket *so)
 		return (EINVAL);
 #endif
 	}
+	#ifdef FRCOV
+	}
+	#endif
  sctp_must_try_again:
 	flags = inp->sctp_flags;
 #ifdef SCTP_LOG_CLOSING
@@ -842,10 +861,25 @@ sctp6_bind(struct socket *so, struct mbuf *nam, struct proc *p)
 	int error;
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[616]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 616\n");
+	  else
+	    fprintf(stderr, "reached bug index 616\n");
+	}
+	if ((!FIXREVERTER[616] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 #if !defined(__Windows__)
 	if (addr) {
@@ -938,11 +972,26 @@ sctp6_bind(struct socket *so, struct mbuf *nam, struct proc *p)
 
 		/* IPV6_V6ONLY socket */
 #ifdef INET
-		if (addr->sa_family == AF_INET) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[617]) {
+		  if ((addr -> sa_family == 2 ) && !(0))
+		    fprintf(stderr, "triggered bug index 617\n");
+		  else
+		    fprintf(stderr, "reached bug index 617\n");
+		}
+		if ((!FIXREVERTER[617] && (addr -> sa_family == 2 ))
+		#else
+		if (0
+		#endif
+		) {
 			/* can't bind v4 addr to v6 only socket! */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 #endif
 		sin6_p = (struct sockaddr_in6 *)addr;
 
@@ -1167,15 +1216,45 @@ sctp6_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 #endif
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
-	if (inp == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[618]) {
+	  if ((inp == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 618\n");
+	  else
+	    fprintf(stderr, "reached bug index 618\n");
+	}
+	if ((!FIXREVERTER[618] && (inp == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, ECONNRESET);
 		return (ECONNRESET);	/* I made the same as TCP since we are
 					 * not setup? */
 	}
-	if (addr == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[619]) {
+	  if ((addr == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 619\n");
+	  else
+	    fprintf(stderr, "reached bug index 619\n");
+	}
+	if ((!FIXREVERTER[619] && (addr == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP6_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 #if !defined(__Windows__)
 	switch (addr->sa_family) {
 #ifdef INET
@@ -1286,10 +1365,25 @@ sctp6_connect(struct socket *so, struct mbuf *nam, struct proc *p)
 	                       inp->sctp_ep.port, p,
 	                       SCTP_INITIALIZE_AUTH_PARAMS);
 	SCTP_ASOC_CREATE_UNLOCK(inp);
-	if (stcb == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[620]) {
+	  if ((stcb == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 620\n");
+	  else
+	    fprintf(stderr, "reached bug index 620\n");
+	}
+	if ((!FIXREVERTER[620] && (stcb == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		/* Gak! no memory */
 		return (error);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		stcb->sctp_ep->sctp_flags |= SCTP_PCB_FLAGS_CONNECTED;
 		/* Set the connected flag so we can queue data */
diff --git a/usrsctplib/user_mbuf.c b/usrsctplib/user_mbuf.c
index a503724..af391b5 100755
--- a/usrsctplib/user_mbuf.c
+++ b/usrsctplib/user_mbuf.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * Copyright (c) 1982, 1986, 1988, 1993
  *      The Regents of the University of California.
@@ -81,8 +85,23 @@ static void	mb_dtor_clust(void *, void *);
 static int mbuf_constructor_dup(struct mbuf *m, int pkthdr, short type)
 {
 	int flags = pkthdr;
-	if (type == MT_NOINIT)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[381]) {
+	  if ((type == 255 ) && !(0))
+	    fprintf(stderr, "triggered bug index 381\n");
+	  else
+	    fprintf(stderr, "reached bug index 381\n");
+	}
+	if ((!FIXREVERTER[381] && (type == 255 ))
+	#else
+	if (0
+	#endif
+	)
 		return (0);
+		#ifdef FRCOV
+		}
+		#endif
 
 	m->m_next = NULL;
 	m->m_nextpkt = NULL;
@@ -210,9 +229,24 @@ clust_constructor_dup(caddr_t m_clust, struct mbuf* m)
 	u_int *refcnt;
 	int type, size;
 
-	if (m == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[382]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 382\n");
+	  else
+	    fprintf(stderr, "reached bug index 382\n");
+	}
+	if ((!FIXREVERTER[382] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	/* Assigning cluster of MCLBYTES. TODO: Add jumbo frame functionality */
 	type = EXT_CLUSTER;
 	size = MCLBYTES;
@@ -331,11 +365,26 @@ m_getm2(struct mbuf *m, int len, int how, short type, int flags, int allonebuf)
 		}
 
 		/* Fail the whole operation if one mbuf can't be allocated. */
-		if (mb == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[383]) {
+		  if ((mb == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 383\n");
+		  else
+		    fprintf(stderr, "reached bug index 383\n");
+		}
+		if ((!FIXREVERTER[383] && (mb == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			if (nm != NULL)
 				m_freem(nm);
 			return (NULL);
 		}
+		#ifdef FRCOV
+		}
+		#endif
 
 		if (allonebuf != 0 && size < space_needed) {
 			m_freem(mb);
@@ -397,8 +446,23 @@ m_uiotombuf(struct uio *uio, int how, int len, int align, int flags)
 	 * If len is zero return the smallest empty mbuf.
 	 */
 	m = m_getm2(NULL, (int)max(total + align, 1), how, MT_DATA, flags, 0);
-	if (m == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[384]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 384\n");
+	  else
+	    fprintf(stderr, "reached bug index 384\n");
+	}
+	if ((!FIXREVERTER[384] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	m->m_data += align;
 
 	/* Fill all mbufs with uio data and update header information. */
@@ -882,8 +946,23 @@ m_pullup(struct mbuf *n, int len)
 		if (len > MHLEN)
 			goto bad;
 		MGET(m, M_NOWAIT, n->m_type);
-		if (m == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[386]) {
+		  if ((m == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 386\n");
+		  else
+		    fprintf(stderr, "reached bug index 386\n");
+		}
+		if ((!FIXREVERTER[386] && (m == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			goto bad;
+			#ifdef FRCOV
+			}
+			#endif
 		m->m_len = 0;
 		if (n->m_flags & M_PKTHDR)
 			M_MOVE_PKTHDR(m, n);
@@ -1166,17 +1245,47 @@ m_copym(struct mbuf *m, int off0, int len, int wait)
 	np = &top;
 	top = 0;
 	while (len > 0) {
-		if (m == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[392]) {
+		  if ((m == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 392\n");
+		  else
+		    fprintf(stderr, "reached bug index 392\n");
+		}
+		if ((!FIXREVERTER[392] && (m == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			KASSERT(len == M_COPYALL, ("m_copym, length > size of mbuf chain"));
 			break;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (copyhdr)
 			MGETHDR(n, wait, m->m_type);
 		else
 			MGET(n, wait, m->m_type);
 		*np = n;
-		if (n == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[393]) {
+		  if ((n == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 393\n");
+		  else
+		    fprintf(stderr, "reached bug index 393\n");
+		}
+		if ((!FIXREVERTER[393] && (n == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			goto nospace;
+			#ifdef FRCOV
+			}
+			#endif
 		if (copyhdr) {
 			if (!m_dup_pkthdr(n, m, wait))
 				goto nospace;
@@ -1218,10 +1327,25 @@ m_tag_copy_chain(struct mbuf *to, struct mbuf *from, int how)
 	m_tag_delete_chain(to, NULL);
 	SLIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
 		t = m_tag_copy(p, how);
-		if (t == NULL) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[394]) {
+		  if ((t == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 394\n");
+		  else
+		    fprintf(stderr, "reached bug index 394\n");
+		}
+		if ((!FIXREVERTER[394] && (t == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			m_tag_delete_chain(to, NULL);
 			return 0;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (tprev == NULL)
 			SLIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
 		else
@@ -1258,8 +1382,23 @@ m_tag_copy(struct m_tag *t, int how)
 
 	KASSERT(t, ("m_tag_copy: null tag"));
 	p = m_tag_alloc(t->m_tag_cookie, t->m_tag_id, t->m_tag_len, how);
-	if (p == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[395]) {
+	  if ((p == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 395\n");
+	  else
+	    fprintf(stderr, "reached bug index 395\n");
+	}
+	if ((!FIXREVERTER[395] && (p == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	memcpy(p + 1, t + 1, t->m_tag_len); /* Copy the data */
 	return p;
 }
@@ -1270,11 +1409,41 @@ m_tag_alloc(u_int32_t cookie, int type, int len, int wait)
 {
 	struct m_tag *t;
 
-	if (len < 0)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[397]) {
+	  if ((len < 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 397\n");
+	  else
+	    fprintf(stderr, "reached bug index 397\n");
+	}
+	if ((!FIXREVERTER[397] && (len < 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return NULL;
+		#ifdef FRCOV
+		}
+		#endif
 	t = malloc(len + sizeof(struct m_tag));
-	if (t == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[398]) {
+	  if ((t == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 398\n");
+	  else
+	    fprintf(stderr, "reached bug index 398\n");
+	}
+	if ((!FIXREVERTER[398] && (t == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return NULL;
+		#ifdef FRCOV
+		}
+		#endif
 	m_tag_setup(t, cookie, type, len);
 	t->m_tag_free = m_tag_free_default;
 	return t;
@@ -1299,15 +1468,45 @@ m_copyback(struct mbuf *m0, int off, int len, caddr_t cp)
 	struct mbuf *m = m0, *n;
 	int totlen = 0;
 
-	if (m0 == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[399]) {
+	  if ((m0 == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 399\n");
+	  else
+	    fprintf(stderr, "reached bug index 399\n");
+	}
+	if ((!FIXREVERTER[399] && (m0 == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return;
+		#ifdef FRCOV
+		}
+		#endif
 	while (off > (mlen = m->m_len)) {
 		off -= mlen;
 		totlen += mlen;
 		if (m->m_next == NULL) {
 			n = m_get(M_NOWAIT, m->m_type);
-			if (n == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[400]) {
+			  if ((n == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 400\n");
+			  else
+			    fprintf(stderr, "reached bug index 400\n");
+			}
+			if ((!FIXREVERTER[400] && (n == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				goto out;
+				#ifdef FRCOV
+				}
+				#endif
 			memset(mtod(n, caddr_t), 0, MLEN);
 			n->m_len = min(MLEN, len + off);
 			m->m_next = n;
@@ -1326,8 +1525,23 @@ m_copyback(struct mbuf *m0, int off, int len, caddr_t cp)
 			break;
 		if (m->m_next == NULL) {
 			n = m_get(M_NOWAIT, m->m_type);
-			if (n == NULL)
+			
+			#ifdef FRCOV
+			{if (FIXREVERTER[402]) {
+			  if ((n == (void *) 0 ) && !(0))
+			    fprintf(stderr, "triggered bug index 402\n");
+			  else
+			    fprintf(stderr, "reached bug index 402\n");
+			}
+			if ((!FIXREVERTER[402] && (n == (void *) 0 ))
+			#else
+			if (0
+			#endif
+			)
 				break;
+				#ifdef FRCOV
+				}
+				#endif
 			n->m_len = min(MLEN, len);
 			m->m_next = n;
 		}
@@ -1352,10 +1566,25 @@ m_prepend(struct mbuf *m, int len, int how)
 		MGETHDR(mn, how, m->m_type);
 	else
 		MGET(mn, how, m->m_type);
-	if (mn == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[403]) {
+	  if ((mn == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 403\n");
+	  else
+	    fprintf(stderr, "reached bug index 403\n");
+	}
+	if ((!FIXREVERTER[403] && (mn == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		m_freem(m);
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (m->m_flags & M_PKTHDR)
 		M_MOVE_PKTHDR(mn, m);
 	mn->m_next = m;
@@ -1476,8 +1705,23 @@ m_adj(struct mbuf *mp, int req_len)
 			return;
 		}
 		count -= len;
-		if (count < 0)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[404]) {
+		  if ((count < 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 404\n");
+		  else
+		    fprintf(stderr, "reached bug index 404\n");
+		}
+		if ((!FIXREVERTER[404] && (count < 0 ))
+		#else
+		if (0
+		#endif
+		)
 			count = 0;
+			#ifdef FRCOV
+			}
+			#endif
 		/*
 		 * Correct length for chain is "count".
 		 * Find the mbuf with last data, adjust its length,
@@ -1522,13 +1766,43 @@ m_split(struct mbuf *m0, int len0, int wait)
 	/* MBUF_CHECKSLEEP(wait); */
 	for (m = m0; m && (int)len > m->m_len; m = m->m_next)
 		len -= m->m_len;
-	if (m == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[405]) {
+	  if ((m == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 405\n");
+	  else
+	    fprintf(stderr, "reached bug index 405\n");
+	}
+	if ((!FIXREVERTER[405] && (m == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	remain = m->m_len - len;
 	if (m0->m_flags & M_PKTHDR) {
 		MGETHDR(n, wait, m0->m_type);
-		if (n == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[406]) {
+		  if ((n == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 406\n");
+		  else
+		    fprintf(stderr, "reached bug index 406\n");
+		}
+		if ((!FIXREVERTER[406] && (n == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			return (NULL);
+			#ifdef FRCOV
+			}
+			#endif
 		n->m_pkthdr.rcvif = m0->m_pkthdr.rcvif;
 		n->m_pkthdr.len = m0->m_pkthdr.len - len0;
 		m0->m_pkthdr.len = len0;
@@ -1553,8 +1827,23 @@ m_split(struct mbuf *m0, int len0, int wait)
 		return (n);
 	} else {
 		MGET(n, wait, m->m_type);
-		if (n == NULL)
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[407]) {
+		  if ((n == (void *) 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 407\n");
+		  else
+		    fprintf(stderr, "reached bug index 407\n");
+		}
+		if ((!FIXREVERTER[407] && (n == (void *) 0 ))
+		#else
+		if (0
+		#endif
+		)
 			return (NULL);
+			#ifdef FRCOV
+			}
+			#endif
 		M_ALIGN(n, remain);
 	}
 extpacket:
diff --git a/usrsctplib/user_socket.c b/usrsctplib/user_socket.c
index df4dbec..a5ace15 100755
--- a/usrsctplib/user_socket.c
+++ b/usrsctplib/user_socket.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*-
  * Copyright (c) 1982, 1986, 1988, 1990, 1993
  *      The Regents of the University of California.
@@ -216,9 +220,24 @@ soalloc(void)
 
 	so = (struct socket *)malloc(sizeof(struct socket));
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[238]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 238\n");
+	  else
+	    fprintf(stderr, "reached bug index 238\n");
+	}
+	if ((!FIXREVERTER[238] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (NULL);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(so, 0, sizeof(struct socket));
 
 	/* __Userspace__ Initializing the socket locks here */
@@ -479,8 +498,23 @@ sonewconn(struct socket *head, int connstatus)
 #endif
 		return (NULL);
 	so = soalloc();
-	if (so == NULL)
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[239]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 239\n");
+	  else
+	    fprintf(stderr, "reached bug index 239\n");
+	}
+	if ((!FIXREVERTER[239] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	)
 		return (NULL);
+		#ifdef FRCOV
+		}
+		#endif
 	so->so_head = head;
 	so->so_type = head->so_type;
 	so->so_options = head->so_options &~ SCTP_SO_ACCEPTCONN;
@@ -655,11 +689,26 @@ uiomove(void *cp, int n, struct uio *uio)
 	while (n > 0 && uio->uio_resid) {
 		iov = uio->uio_iov;
 		cnt = iov->iov_len;
-		if (cnt == 0) {
+		
+		#ifdef FRCOV
+		{if (FIXREVERTER[243]) {
+		  if ((cnt == 0 ) && !(0))
+		    fprintf(stderr, "triggered bug index 243\n");
+		  else
+		    fprintf(stderr, "reached bug index 243\n");
+		}
+		if ((!FIXREVERTER[243] && (cnt == 0 ))
+		#else
+		if (0
+		#endif
+		) {
 			uio->uio_iov++;
 			uio->uio_iovcnt--;
 			continue;
 		}
+		#ifdef FRCOV
+		}
+		#endif
 		if (cnt > (size_t)n)
 			cnt = n;
 
@@ -850,14 +899,44 @@ usrsctp_sendv(struct socket *so,
 	int use_sinfo;
 	sctp_assoc_t *assoc_id;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[250]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 250\n");
+	  else
+	    fprintf(stderr, "reached bug index 250\n");
+	}
+	if ((!FIXREVERTER[250] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
-	if (data == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[251]) {
+	  if ((data == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 251\n");
+	  else
+	    fprintf(stderr, "reached bug index 251\n");
+	}
+	if ((!FIXREVERTER[251] && (data == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EFAULT;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	memset(&sinfo, 0, sizeof(struct sctp_sndrcvinfo));
 	assoc_id = NULL;
 	use_sinfo = 0;
@@ -1130,10 +1209,25 @@ usrsctp_recvv(struct socket *so,
 	struct sctp_recvv_rn *rn;
 	struct sctp_extrcvinfo seinfo;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[256]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 256\n");
+	  else
+	    fprintf(stderr, "reached bug index 256\n");
+	}
+	if ((!FIXREVERTER[256] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	iov[0].iov_base = dbuf;
 	iov[0].iov_len = len;
 
@@ -1284,9 +1378,24 @@ socreate(int dom, struct socket **aso, int type, int proto)
 	}
 
 	so = soalloc();
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[258]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 258\n");
+	  else
+	    fprintf(stderr, "reached bug index 258\n");
+	}
+	if ((!FIXREVERTER[258] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		return (ENOBUFS);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	/*
 	 * so_incomp represents a queue of connections that
@@ -1651,10 +1760,25 @@ usrsctp_bind(struct socket *so, struct sockaddr *name, int namelen)
 {
 	struct sockaddr *sa;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[259]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 259\n");
+	  else
+	    fprintf(stderr, "reached bug index 259\n");
+	}
+	if ((!FIXREVERTER[259] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if ((errno = getsockaddr(&sa, (caddr_t)name, namelen)) != 0)
 		return (-1);
 
@@ -2007,10 +2131,25 @@ sodisconnect(struct socket *so)
 int
 usrsctp_set_non_blocking(struct socket *so, int onoff)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[263]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 263\n");
+	  else
+	    fprintf(stderr, "reached bug index 263\n");
+	}
+	if ((!FIXREVERTER[263] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	SOCK_LOCK(so);
 	if (onoff != 0) {
 		so->so_state |= SS_NBIO;
@@ -2089,10 +2228,25 @@ int user_connect(struct socket *so, struct sockaddr *sa)
 	int error;
 	int interrupted = 0;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[265]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 265\n");
+	  else
+	    fprintf(stderr, "reached bug index 265\n");
+	}
+	if ((!FIXREVERTER[265] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		error = EBADF;
 		goto done1;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	if (so->so_state & SS_ISCONNECTING) {
 		error = EALREADY;
 		goto done1;
@@ -2275,10 +2429,25 @@ int
 usrsctp_setsockopt(struct socket *so, int level, int option_name,
                    const void *option_value, socklen_t option_len)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[267]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 267\n");
+	  else
+	    fprintf(stderr, "reached bug index 267\n");
+	}
+	if ((!FIXREVERTER[267] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	switch (level) {
 	case SOL_SOCKET:
 	{
@@ -2365,14 +2534,44 @@ int
 usrsctp_getsockopt(struct socket *so, int level, int option_name,
                    void *option_value, socklen_t *option_len)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[268]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 268\n");
+	  else
+	    fprintf(stderr, "reached bug index 268\n");
+	}
+	if ((!FIXREVERTER[268] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
-	if (option_len == NULL) {
+	#ifdef FRCOV
+	}
+	#endif
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[269]) {
+	  if ((option_len == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 269\n");
+	  else
+	    fprintf(stderr, "reached bug index 269\n");
+	}
+	if ((!FIXREVERTER[269] && (option_len == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EFAULT;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 	switch (level) {
 	case SOL_SOCKET:
 		switch (option_name) {
@@ -3538,10 +3737,25 @@ usrsctp_get_events(struct socket *so)
 {
 	int events = 0;
 
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[290]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 290\n");
+	  else
+	    fprintf(stderr, "reached bug index 290\n");
+	}
+	if ((!FIXREVERTER[290] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return -1;
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	SOCK_LOCK(so);
 	if (soreadable(so)) {
@@ -3561,10 +3775,25 @@ usrsctp_get_events(struct socket *so)
 int
 usrsctp_set_upcall(struct socket *so, void (*upcall)(struct socket *, void *, int), void *arg)
 {
-	if (so == NULL) {
+	
+	#ifdef FRCOV
+	{if (FIXREVERTER[291]) {
+	  if ((so == (void *) 0 ) && !(0))
+	    fprintf(stderr, "triggered bug index 291\n");
+	  else
+	    fprintf(stderr, "reached bug index 291\n");
+	}
+	if ((!FIXREVERTER[291] && (so == (void *) 0 ))
+	#else
+	if (0
+	#endif
+	) {
 		errno = EBADF;
 		return (-1);
 	}
+	#ifdef FRCOV
+	}
+	#endif
 
 	SOCK_LOCK(so);
 	so->so_upcall = upcall;
diff --git a/usrsctplib/usrsctp.h b/usrsctplib/usrsctp.h
old mode 100644
new mode 100755
